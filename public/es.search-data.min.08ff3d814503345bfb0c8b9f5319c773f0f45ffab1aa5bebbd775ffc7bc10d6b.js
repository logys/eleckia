'use strict';(function(){const b={cache:!0};b.doc={id:'id',field:['title','content'],store:['title','href','section']};const a=FlexSearch.create('balance',b);window.bookSearchIndex=a,a.add({id:0,href:'/docs/workstation/',title:"Estación de trabajo.",section:"Docs",content:"Hay que trabajar, hay que aprender, hay que comer, hay que descansar y también hay que jugar, esas son las bases del entrenamiento del maestro Roshi para tener una buena condición. #  Kame Senin.\n"}),a.add({id:1,href:'/docs/avr/',title:"Programación Avr en C.",section:"Docs",content:"Una línea de othello sobre un bebedor, ahora un hombre sensible; por el alcohol se convierte en bestia, eso lo explica todo. #  Barney Gómez.\nEn esta sección introduzco algunos conceptos de C que considero necesarios para programar.\n"}),a.add({id:2,href:'/docs/avr/programando-avr-en-c-arreglos/',title:"Programando Avr en C. Arreglos.",section:"Programación Avr en C.",content:"Los arreglos o arrays son elementos que permiten hacer colecciones de datos del tipo indicado, su uso es amplio en prácticamente todos los lenguajes de programación, en C los arreglos se declaran con la siguiente sintaxis,\ntipo_dato nombre_array[TAMAÑO]; Por ejemplo para declarar un arreglo de 5 enteros llamado horas:\nint horas[5]; Para declarar un arreglo de 3 boleanos llamado respuestas:\n#include\u0026lt;stdbool.h\u0026gt; bool respuestas[3]; Los arreglos pueden ser de cualquier tipo de dato. El número entre corchetes (paréntesis cuadrados) indica la cantidad de elementos que puede almacenar, en el caso del arreglo horas, este puede almacenar hasta 5 enteros, la forma de asignar los valores es la siguiente:\nint horas[5] = {1, 2, 1, 2, 3}; //o también int horas[5]; horas[0] = 1; horas[1] = 2; horas[2] = 1; horas[3] = 2; horas[4] = 3; Ambas asignaciones resultaran en los mismos enteros para el arreglo, nótese que cuando asignamos los valores, la primera posición es cero y no uno, esto implica que la última posición sea cuatro y no cinco, si asignáramos horas[5] = 4; obtendríamos un error en tiempo de ejecución, este error es muy diferente de el error en tiempo de compilación, de hecho el programa compilara sin error, pero si se intenta ejecutar dentro del microcontrolador la ejecución sera errática, probablemente el programa se reinicie al tratar de ejecutar la instrucción o tal vez se detenga en ese instante, o tal vez no pase nada, depende de la forma en que se organiza la memoria en el micro, por lo tanto hay que tener cuidado en no rebasar el indice, el máximo es igual a el tamaño menos uno.\nArreglos y apuntadores. #  Los arreglos y apuntadores tienen una relación importante, el nombre de un arreglo es un apuntador que apunta a la dirección del primer elemento o elemento cero,\nint numeros[2] = {1, 4}; int a = *numeros + numeros[1]; //a contendra el valor de 5 A pesar de esta equivalencia, prefiero utilizar los corchetes cuando de arreglos se trata, esto me evita la sobrecargar de conceptos en la cabeza y me permite diferenciar claramente el propósito de un arreglo y el de un apuntador, con el arreglo quiero manejar una colección de datos, mientras que con los apuntadores quiero manejar el acceso a objetos individuales.\n"}),a.add({id:3,href:'/posts/principio-de-responsabilidad-unica-srp/',title:"Principio de responsabilidad única (SRP)",section:"Posts",content:"En el desarrollo ágil, el principio de responsabilidad única es uno de los cinco principios fundamentales, el principio define lo siguiente:\nUn módulo debe tener un solo motivo para cambiar.\nY eso es todo, ¿fácil no?, yo también lo creo, ¿qué es lo que creo?, no lo entiendo. Vamos por partes, las palabras son obvias, pero la frase es un poco ambigua, el meollo del asunto es claramente un solo motivo para cambiar, podemos apoyarnos en el nombre del principio, responsabilidad única, mmm parece ser que ambas frases se refieren a lo mismo, ¿a qué mismo?, mmm, lo que esta claro es que un módulo solo debe tener una sola responsabilidad, por ejemplo suponiendo que requerimos un sistema que controle el movimiento de un robot móvil, el robot puede ir hacia adelante, atrás y rotar las ruedas de dirección, una forma de visualizarlo es la siguiente,\nSeparación obvia.\nSe sugiere una separación de responsabilidades, en lugar de que el módulo robot_posición administre el avance, retroceso y giro, separamos las responsabilidades y las asignamos a nuevos módulos, esta separación es lo primero que se me vino a la mente, ¿pero esta separación es la más adecuada?, las repuesta no es evidente ni definitiva, es aquí donde recurrimos a la definición un solo motivo para cambiar, los módulos traslación y rotación cumplen con el principio srp, solo si al requerir una nueva característica, solo uno de los dos módulos necesita modificarse.\nSuponiendo que los requerimientos cambian y que se requiere que la velocidad a la que se mueve el robot hacia adelante y atrás sea controlable, es evidente que el módulo traslación sera el único que cambie, por lo tanto la separación que se realizo es adecuada y cumple con el principio srp.\nAhora suponiendo que la especificación cambia, se desea que el robot tenga movimiento continuo, es decir que el robot avance hacia adelante o atrás mientras está rotando. Ahora nuestros módulos no cumplen con el principio, pues ambos deben ser modificados para alcanzar los nuevos requerimientos, este será un buen momento para replantear nuestra anterior separación en módulos, una refactorización nos da el siguiente modelo,\nDe esta manera velocidad solo se encarga de mover los motores avance y de retroceso, tren_de_giro se encarga de girar un motor de dirección o el ajuste necesario dependiendo de la forma del robot.\nCon esto quiero decir que los módulos deben agruparse de tal forma que las razones por las que cambian estén juntas, con esto logramos que al agregar nuevos cambios, solo debamos modificar el mínimo de módulos.\n¿Y cuales son esas razones de cambio?, la respuesta es el cliente, el usuario, si el cliente del módulo hace una nueva especificación que implique un cambio y para lograr la implementación se requieren modificar más de un módulo se debe replantear la forma y el tamaño de los módulos.\nRepito, el objetivo del SRP es proveer una forma de \u0026ldquo;modularizar\u0026rdquo; el programa en base a peticiones de cambios, aunque exista la tentación de agrupar módulos por forma, color, sabor, etc, que pudieran parecer más naturales, agrupar por motivos de cambios, nos dará como resultado un software altamente ágil en el sentido de nuevas características.\nEn el ejemplo anterior, ¿que sentido tendría mezclar el código de control de posición con el código de control visión del robot?, si nosotros requerimos modificar el contraste o el brillo de la imagen, ¿sería necesario modificar la velocidad del robot?, las respuesta obvia es que no, sin embargo piensa que las cámaras aveces son muy lentas, quizá requerimos tomar una imagen cuando el robot se acerque a un objeto, entonces si la cámara es lenta necesariamente requerimos bajar la velocidad, ni modo, es triste, pero debemos refactorizar los módulos en harás de lograr el objetivo.\nEl SRP es el principio más sencillo de describir, pero el más difícil de asimilar, requiere práctica, esfuerzo, experiencia y mucha meditación.\n"}),a.add({id:4,href:'/posts/solid/',title:"SOLID",section:"Posts",content:"_Soy malo y eso es bueno, yo jamás seré bueno y eso no es malo, no hay nadie que quiera ser además de mi. #  - Ralph el demoledor._\nSOLID #  Dentro del mundo de la programación existen los famosos paradigmas de programación, entre ellos: la programación funcional, la programación orientada a eventos, la programación estructurada, la programación orientada a objetos y otros más. En esta fecha 2020, la programación orientada a objetos sin duda domina la forma en que se escribe el software en general, vale la pena aprender este paradigma pues no será raro encontrarnos con programas basados en él.\nEl éxito de la programación orientada a objetos, se basa en la abstracción de objetos, ¿qué es la abstracción de objetos?, personalmente la defino como una combinación entre imaginar, separar y simplificar, es decir tomamos un objeto real por ejemplo un motor, identificamos lo que nos interesa por ejemplo la velocidad y la dirección de giro y descartamos el resto de detalles, el tipo de motor, la potencia, la tensión de entrada, el par, marca, color, peso, etc, este motor que únicamente gira a la velocidad y dirección indicada, es una abstracción de un motor real, esto que parece tan trivial tiene la cualidad de simplificar la forma en que se resuelven los problema, pues los humanos estamos adaptados a pensar en objetos abstractos.\nDentro de la programación orientada a objetos han surgido diferentes corrientes de desarrollo, en los últimos años el desarrollo ágil gano una popularidad importante. En las catacumbas de un lugar de cuyo nombre no quiero acordarme, se reunió un grupo de programadores con gran experiencia en el desarrollo de software, conspirando en contra de la técnicas tradicionales escribieron el manifiesto ágil,\nhttps://agilemanifesto.org/iso/es/manifesto.html\nuna vez popularizado el desarrollo ágil comenzaron a desarrollarse numerosas metodologías de trabajo, entre ellas: scrum, kaban, xp, tdd, etc, como mencione las personas funcionamos en base a abstracciones por lo que las metodologías ágiles pueden salir del mundo de la programación e implementarse en otros rubros de la humanidad.\nPersonalmente yo no me sentí seguro con mi código hasta que aprendí TDD (Test Driven Development), Desarrollo Guiado por Pruebas.\nAquí tratare de describir los cinco principios fundamentales del desarrollo ágil, acuñados por Robert C. Martin, Agile Software Development, Principles, Patterns, and Practices. Es un excelente referencia para cualquiera que pretenda aprender a programar.\nSOLID es un acrónimo formador por los cinco principios del desarrollo ágil.\nS Single responsibility principle (Principio de responsabilidad única)\nO Open/closed principle (Principio Abierto/Cerrado)\nL Liskov substitution principle (Principio de sustitución de Liskov)\nI Interface segregation principle (Principio de segregación de la interfaz)\nD Dependency inversion principle (Principio de inversión de dependencia)\nSi cumplimos con estos principios dentro de nuestro código, entonces podemos decir que nuestro código es ágil\n Sigue mi blog #  Recibe nuevo contenido directamente en tu bandeja de entrada.\n[jetpack_subscription_form subscribe_placeholder=\u0026ldquo;Introduce tu dirección de correo electrónico\u0026rdquo; show_subscribers_total=\u0026ldquo;false\u0026rdquo; button_on_newline=\u0026ldquo;false\u0026rdquo; submit_button_text=\u0026ldquo;Registrarse\u0026rdquo; custom_background_emailfield_color=\u0026ldquo;undefined\u0026rdquo; custom_background_button_color=\u0026ldquo;undefined\u0026rdquo; custom_text_button_color=\u0026ldquo;undefined\u0026rdquo; custom_font_size=\u0026ldquo;16\u0026rdquo; custom_border_radius=\u0026ldquo;0\u0026rdquo; custom_border_weight=\u0026ldquo;1\u0026rdquo; custom_border_color=\u0026ldquo;undefined\u0026rdquo; custom_padding=\u0026ldquo;15\u0026rdquo; custom_spacing=\u0026ldquo;10\u0026rdquo; submit_button_classes=\u0026quot;\u0026quot; email_field_classes=\u0026quot;\u0026quot; show_only_email_and_button=\u0026ldquo;true\u0026rdquo; ]\n"}),a.add({id:5,href:'/posts/electronica/',title:"Electrónica",section:"Posts",content:"Ah, ¿pero que oigo?, una intromisión, debe ser #  Lisa Simpson, la respuesta a una pregunta que\nnunca hizo nadie.\n-Ned Flanders\n Sigue mi blog #  Recibe nuevo contenido directamente en tu bandeja de entrada.\n[jetpack_subscription_form show_only_email_and_button=\u0026ldquo;true\u0026rdquo; custom_background_button_color=\u0026ldquo;undefined\u0026rdquo; custom_text_button_color=\u0026ldquo;undefined\u0026rdquo; submit_button_text=\u0026ldquo;Suscribir\u0026rdquo; submit_button_classes=\u0026ldquo;undefined\u0026rdquo; show_subscribers_total=\u0026ldquo;false\u0026rdquo; ]\n"}),a.add({id:6,href:'/docs/perifericos/gpio/perifericos-atmega328p-puertos-de-entrada-salida-de-proposito-general-gpio-vii-display-siete-segmentos/',title:"Display Siete Segmentos VI.",section:"GPIO",content:"La función setNumber puede ser mejorada, antes de ello quiero hacer una modificación de diseño, el módulo display7 hace varias cosas, configura los puertos, convierte de decimal a la colección adecuada de pines de salida y finalmente escribe las salidas a los puertos, este último par de acciones en nuestra implementación se realizan en la misma función setNumber, se recomienda que las funciones sean responsables de una sola acción bien definida.\nTomando en cuenta lo anterior sugiero lo siguiente,\nvoid display7\\_setNumber(short number) { uint8\\_t pines7 = decoder7(number); writeTo7(pines7); } de esta manera separamos las dos acciones y la función setNumber únicamente se encarga de controlar el flujo. Nos concentramos en implementar la función decoder7, recibe un número decimal y lo convierte en un código (codificación) 7 segmentos. Cuando pasamos el número 5 por ejemplo, decoder7 retorna el valor binario 0b0110 1101 que en decimal corresponde a 109, la correspondencia es la siguiente\n GFE DCBA 0b0110 1101 //Cada bit corresponde a un led //para el número cero GFE DCBA 0b0010 1111 //Cada bit corresponde a un led la implementación es de la forma\nstatic uint8\\_t decoder7(short number) { if(number == 0) return 0b0111111; else if(number == 5) return 0b01101101; } la notación 0b, es una notación no estándar, prefiero utilizar una notación hexadecimal,\nstatic uint8\\_t decoder7(short number) { if(number == 0) //0b0011 1111 return 0x3f; else if(number == 1) //0b0000 0110 return 0x06; else if(number == 2) //0b0101 1011 return 0x5A; else if(number == 3) //0b0100 1111 return 0x4F; else if(number == 4) //0b0110 0110 return 0x66; else if(number == 5) //0b0110 1101 return 0x6D; else if(number == 6) //0b0111 1101 return 0x7D; else if(number == 7) //0b0000 0111 return 0x07; else if(number == 8) //0b0111 1111 return 0x7F; else if(number == 9) //0b0110 1111 return 0x6F; } La solución está bien, pero es horriblemente grande, efectivamente requerimos un nuevo look, la refactorización es muy simple, guardamos todos los valores en un arreglo y retornamos el valor al cual apunta el indice,\nstatic uint8\\_t decoder7(short number) { const uint8\\_t code7\\[10\\] = { 0x3f,	//0 0b0011 1111 0x06,	//1 0b0000 0110 0x5B,	//2 0b0101 1011 0x4F,	//3 0b0100 1111 0x66,	//4 0b0110 0110 0x6D,	//5 0b0110 1101 0x7D,	//6 0b0111 1101 0x07,	//7 0b0000 0111 0x7F,	//8 0b0111 1111 0x6F	//9 0b0110 1111 }; return code7\\[number\\]; } mucho mejor. Ahora implementaremos writeTo7, debemos tomar los pines retornados por decoder7 y escribirlos en los puertos PORTD y PORTB, sabemos que\ndecorder7 retorna 8 bits de la forma 0b0GFE DCBA y nuestros puertos, aceptan 8 bits de la forma PORTD 0bFEDC BA00 PORTB 0b0000 000G la solución consiste en corrimientos, se propone\nstatic void writeTo7(uint8\\_t pines\\_to\\_set) { uint8\\_t port\\_D; port\\_D = pines\\_to\\_set\u0026lt;\u0026lt;2; uint8\\_t port\\_B; port\\_B = pines\\_to\\_set \u0026gt;\u0026gt; 6; pinoutLevelLow(); setBits(\u0026amp;PORTD, port\\_D); setBits(\u0026amp;PORTB, port\\_B); } refactorizamos las primeras 4 lineas en una sola función, esto para evitar tener más de una acción dentro de la función write7\nstatic getLedsToPorts(uint8\\_t \\* port\\_D, uint8\\_t \\* port\\_B, uint8\\_t pines\\_to\\_set) { \\*port\\_D = pines\\_to\\_set\u0026lt;\u0026lt;2; \\*port\\_B = pines\\_to\\_set \u0026gt;\u0026gt; 6; } static void writeTo7(uint8\\_t pines\\_to\\_set) { uint8\\_t port\\_D; uint8\\_t port\\_B; getLedsToPorts(\u0026amp;port\\_D, \u0026amp;port\\_B, pines\\_to\\_set); pinoutLevelLow(); setBits(\u0026amp;PORTD, port\\_D); setBits(\u0026amp;PORTB, port\\_B); } nuestro programa esta casi listo, como última modificación debemos agregar un guardia a la función setNumber, ¿que pasa si convertimos el número 10 o el número negativo -1?, setNumber(10), el comportamiento no esta definido por nosotros, para evitar comportamientos no definidos agregamos una condición que nos maneje dichos casos\nvoid display7\\_setNumber(short number) { if(number \u0026gt; 9 || number \u0026lt; 0){ return ; } uint8\\_t pines7 = decoder7(number); writeTo7(pines7); } en mi caso, tan solo le indico que quiero ignorar tales casos. Hemos terminado nuestra implementación, el programa funciona perfectamente bien, cumple con las expectativas (las especificaciones), podemos modificar la función main y cambiar el orden de los números decimales sin el más mínimo miedo de pensar que el módulo se romperá, literalmente aislamos al display de el programa principal.\nPero, ¿es necesario todo este trabajo para un simple display de 7 segmentos?, pues eso depende de tu proyecto y un juicio de valores personal, menciono lo que logramos\n Aislamos el módulo. El módulo se puede utilizar en otros módulos. Los usuarios del módulo tan solo utilizaran 3 funciones. Minimizamos la posibilidad de errores.  Todo esto en 292 bytes, que corresponden a menos del 1% del espacio disponible. Pienso que no esta nada mal, anexo la implementación completa\n//display7.c #include\u0026quot;display7.h\u0026quot; #include\u0026lt;avr/io.h\u0026gt; #include\u0026lt;stdint.h\u0026gt; #define led\\_A (1\u0026lt;\u0026lt;PD2) #define led\\_B (1\u0026lt;\u0026lt;PD3) #define led\\_C (1\u0026lt;\u0026lt;PD4) #define led\\_D (1\u0026lt;\u0026lt;PD5) #define led\\_E (1\u0026lt;\u0026lt;PD6) #define led\\_F (1\u0026lt;\u0026lt;PD7) #define led\\_G (1\u0026lt;\u0026lt;PB0) static void setBits(uint8\\_t \\*regi, uint8\\_t bits) { \\*regi |= bits; } static void clearBits(uint8\\_t \\*regi, uint8\\_t bits) { \\*regi \u0026amp;= ~bits; } typedef enum {DIRECTION, LEVEL}PORT\\_TYPE; static void selectPorts(uint8\\_t \\*\\* port1, uint8\\_t \\*\\* port2, PORT\\_TYPE port\\_type) { if(port\\_type == DIRECTION){ \\*port1 = \u0026amp;DDRD; \\*port2 = \u0026amp;DDRB; }else if(port\\_type == LEVEL){ \\*port1 = \u0026amp;PORTD; \\*port2 = \u0026amp;PORTB; } } static void actionOnPorts(void (\\*action)(uint8\\_t \\*, uint8\\_t), PORT\\_TYPE port\\_type) { uint8\\_t \\* port1; uint8\\_t \\* port2; selectPorts(\u0026amp;port1, \u0026amp;port2, port\\_type); action(port1, led\\_A|led\\_B|led\\_C|led\\_D|led\\_E|led\\_F); action(port2, led\\_G); } static void pinoutAsOutputs(void) { actionOnPorts(setBits, DIRECTION); } static void pinoutAsInputs(void) { actionOnPorts(clearBits, DIRECTION); } static void pinoutLevelHigh(void) { actionOnPorts(setBits, LEVEL); } static void pinoutLevelLow(void) { actionOnPorts(clearBits, LEVEL); } void display7\\_init(void) { pinoutAsOutputs(); pinoutLevelLow(); } void display7\\_destroy(void) { pinoutAsInputs(); pinoutLevelLow(); } static uint8\\_t decoder7(short number) { const uint8\\_t code7\\[10\\] = { 0x3f,	//0 0b0011 1111 0x06,	//1 0b0000 0110 0x5B,	//2 0b0101 1011 0x4F,	//3 0b0100 1111 0x66,	//4 0b0110 0110 0x6D,	//5 0b0110 1101 0x7D,	//6 0b0111 1101 0x07,	//7 0b0000 0111 0x7F,	//8 0b0111 1111 0x6F	//9 0b0110 1111 }; return code7\\[number\\]; } static getLedsToPorts(uint8\\_t \\* port\\_D, uint8\\_t \\* port\\_B, uint8\\_t pines\\_to\\_set) { \\*port\\_D = pines\\_to\\_set\u0026lt;\u0026lt;2; \\*port\\_B = pines\\_to\\_set \u0026gt;\u0026gt; 6; } static void writeTo7(uint8\\_t pines\\_to\\_set) { uint8\\_t port\\_D; uint8\\_t port\\_B; getLedsToPorts(\u0026amp;port\\_D, \u0026amp;port\\_B, pines\\_to\\_set); pinoutLevelLow(); setBits(\u0026amp;PORTD, port\\_D); setBits(\u0026amp;PORTB, port\\_B); } void display7\\_setNumber(short number) { if(number \u0026gt; 9 || number \u0026lt; 0){ return ; } uint8\\_t pines7 = decoder7(number); writeTo7(pines7); } 105 líneas de trabajo esfuerzo e ilusiones, por supuesto es mejorable, pero la única forma de mejorar es haciendo muchos programas, de eso no se puede escapar.\nTodo el trabajo fue basado en un especificación bien definida, pero rara vez tenemos tal especificación, la mayoría de las veces no sabemos que rumbo debe tomar el diseño, en la siguiente entrada cambiaremos la especificación, en esta ocasión el pines no estarán definidos, es decir el usuario del módulo deberá especificarlos antes de usar setNumber.\n"}),a.add({id:7,href:'/docs/perifericos/gpio/perifericos-atmega328p-puertos-de-entrada-salida-de-proposito-general-gpio-vi-display-siete-segmentos/',title:"Display Siete Segmentos V.",section:"GPIO",content:"Continuamos refactorizando el código para evitar repeticiones y ganar legibilidad, retomando.\n//display7.c #include\u0026quot;display7.h\u0026quot; #include\u0026lt;avr/io.h\u0026gt; #define led\\_A (1\u0026lt;\u0026lt;PD2) #define led\\_B (1\u0026lt;\u0026lt;PD3) #define led\\_C (1\u0026lt;\u0026lt;PD4) #define led\\_D (1\u0026lt;\u0026lt;PD5) #define led\\_E (1\u0026lt;\u0026lt;PD6) #define led\\_F (1\u0026lt;\u0026lt;PD7) #define led\\_G (1\u0026lt;\u0026lt;PB2) static void pinoutAsOutputs(void) { //pinout como salidas DDRB |= led\\_G; DDRD |= led\\_A|led\\_B|led\\_C| led\\_D|led\\_E|led\\_F; } static void pinoutLevelLow(void) { //pinout nivel bajo PORTB \u0026amp;= ~led\\_G; PORTD \u0026amp;= ~(led\\_A|led\\_B|led\\_C| led\\_D|led\\_E|led\\_F); } static void pinoutAsInputs(void) { //pinout como entradas DDRB \u0026amp;= ~led\\_G; DDRD \u0026amp;= ~(led\\_A|led\\_B|led\\_C| led\\_D|led\\_E|led\\_F); } void display7\\_init(void) { pinoutAsOutputs(); pinoutLevelLow(); } void display7\\_destroy(void) { pinoutAsInputs(); pinoutLevelLow(); } void display7\\_setNumber(short number) { if(number == 0){ PORTB \u0026amp;= ~led\\_G; //LED G apagado PORTD |= led\\_A|led\\_B|led\\_C| led\\_D|led\\_E|led\\_F; }else if(number == 1){ PORTB \u0026amp;= ~led\\_G; PORTD \u0026amp;= ~(led\\_A| led\\_D|led\\_E|led\\_F); PORTD |= led\\_B|led\\_C;//LED B y C encendido } //... hasta number == 9 } A ojo de buen cubero, me da la impresión que las tres funciones auxiliares se parecen mucho, en lo único que difieren es en el registro y en establecer o limpiar, por supuesto vamos a tratar de reducir esta repetición. Propongo el siguiente par de funciones auxiliares.\nstatic void setBits(uint8_t *regi, uint8_t bits) { *regi |= bits; } static void clearBits(uint8_t *regi, uint8_t bits) { *regi \u0026amp;= ~bits; } toman como parámetro un apuntador hacia el registro y le asignan el valor del segundo parámetro, fácil o como decimos en español mexicano izi, esta refactorización nos ayuda en dos cosas legibilidad y claridad en la intensión del proceso\n//display7.c #include\u0026quot;display7.h\u0026quot; #include\u0026lt;avr/io.h\u0026gt; #include\u0026lt;stdint.h\u0026gt; #define led\\_A (1\u0026lt;\u0026lt;PD2) #define led\\_B (1\u0026lt;\u0026lt;PD3) #define led\\_C (1\u0026lt;\u0026lt;PD4) #define led\\_D (1\u0026lt;\u0026lt;PD5) #define led\\_E (1\u0026lt;\u0026lt;PD6) #define led\\_F (1\u0026lt;\u0026lt;PD7) #define led\\_G (1\u0026lt;\u0026lt;PB2) static void setBits(uint8\\_t \\*regi, uint8\\_t bits) { \\*regi |= bits; } static void clearBits(uint8\\_t \\*regi, uint8\\_t bits) { \\*regi \u0026amp;= ~bits; } static void pinoutAsOutputs(void) { setBits(\u0026amp;DDRD, led\\_A|led\\_B|led\\_C|led\\_D|led\\_E|led\\_F); setBits(\u0026amp;DDRB, led\\_G); } static void pinoutLevelLow(void) { clearBits(PORTD, led\\_A|led\\_B|led\\_C|led\\_D|led\\_E|led\\_F); clearBits(PORTB, led\\_G); } static void pinoutAsInputs(void) { clearBits(DDRD, led\\_A|led\\_B|led\\_C|led\\_D|led\\_E|led\\_F); clearBits(DDRB, led\\_G); } void display7\\_init(void) { pinoutAsOutputs(); pinoutLevelLow(); } void display7\\_destroy(void) { pinoutAsInputs(); pinoutLevelLow(); } void display7\\_setNumber(short number) { if(number == 0){ setBits(\u0026amp;PORTD, led\\_A|led\\_B|led\\_C|led\\_D|led\\_E|led\\_F); clearBits(\u0026amp;PORTB, led\\_G); }else if(number == 1){ setBits(\u0026amp;PORTD, led\\_B|led\\_C); clearBits(\u0026amp;PORTD, led\\_A|led\\_D|led\\_E|led\\_F); clearBits(\u0026amp;PORTB, led\\_G); } //... hasta number == 9 } vemos que aunque ganamos claridad, no eliminamos la repetición pero ahora se ve fácilmente, las llamadas a las funciones clearBits y setBits, son prácticamente iguales, se propone una refactorización basada en un apuntador de funciones\ntypedef enum {DIRECTION, LEVEL}PORT\\_TYPE; static void actionOnPort(void (\\*action)(uint8\\_t \\*, uint8\\_t), PORT\\_TYPE port\\_type) { if(port\\_type == DIRECTION){ action(\u0026amp;DDRD, led\\_A|led\\_B|led\\_C|led\\_D|led\\_E|led\\_F); action(\u0026amp;DDRB, led\\_G); }else if(port\\_type == LEVEL){ action(\u0026amp;PORTD, led\\_A|led\\_B|led\\_C|led\\_D|led\\_E|led\\_F); action(\u0026amp;PORTB, led\\_G); } } de esta forma el código refactorizado queda\n//display7.c #include\u0026quot;display7.h\u0026quot; #include\u0026lt;avr/io.h\u0026gt; #include\u0026lt;stdint.h\u0026gt; #define led\\_A (1\u0026lt;\u0026lt;PD2) #define led\\_B (1\u0026lt;\u0026lt;PD3) #define led\\_C (1\u0026lt;\u0026lt;PD4) #define led\\_D (1\u0026lt;\u0026lt;PD5) #define led\\_E (1\u0026lt;\u0026lt;PD6) #define led\\_F (1\u0026lt;\u0026lt;PD7) #define led\\_G (1\u0026lt;\u0026lt;PB2) static void setBits(uint8\\_t \\*regi, uint8\\_t bits) { \\*regi |= bits; } static void clearBits(uint8\\_t \\*regi, uint8\\_t bits) { \\*regi \u0026amp;= ~bits; } typedef enum {DIRECTION, LEVEL}PORT\\_TYPE; static void actionOnPorts(void (\\*action)(uint8\\_t \\*, uint8\\_t), PORT\\_TYPE port\\_type) { if(port\\_type == DIRECTION){ action(\u0026amp;DDRD, led\\_A|led\\_B|led\\_C|led\\_D|led\\_E|led\\_F); action(\u0026amp;DDRB, led\\_G); }else if(port\\_type == LEVEL){ action(\u0026amp;PORTD, led\\_A|led\\_B|led\\_C|led\\_D|led\\_E|led\\_F); action(\u0026amp;PORTB, led\\_G); } } static void pinoutAsOutputs(void) { actionOnPorts(setBits, DIRECTION); } static void pinoutAsInputs(void) { actionOnPorts(clearBits, DIRECTION); } static void pinoutLevelLow(void) { actionOnPorts(clearBits, LEVEL); } void display7\\_init(void) { pinoutAsOutputs(); pinoutLevelLow(); } void display7\\_destroy(void) { pinoutAsInputs(); pinoutLevelLow(); } void display7\\_setNumber(short number) { if(number == 0){ setBits(\u0026amp;PORTD, led\\_A|led\\_B|led\\_C|led\\_D|led\\_E|led\\_F); clearBits(\u0026amp;PORTB, led\\_G); }else if(number == 1){ setBits(\u0026amp;PORTD, led\\_B|led\\_C); clearBits(\u0026amp;PORTD, led\\_A|led\\_D|led\\_E|led\\_F); clearBits(\u0026amp;PORTB, led\\_G); } //... hasta number == 9 } claramente eliminamos la repetición, sin embargo no la totalidad, ahora tenemos repetición dentro de la función actionOnPorts, debemos eliminarla, la refactorización anterior también nos muestra algo que puede parecer redundante, en lugar de\nvoid display7_init(void) { pinoutAsOutputs(); pinoutLevelLow(); } podemos exponer directamente la función actionOnPorts de la siguiente forma\nvoid display7_init(void) { actionOnPorts(setBits, DIRECTION); actionOnPorts(clearBits, LEVEL); } y eliminar las funciones pinoutAsOutputs y pinoutLevelLow, sin embargo pienso que la función actionOnPorts no muestra claramente la intensión de la función init, personalmente prefiero no eliminar las funciones ya establecidas en init. Las llamadas a las funciones actions son identicas salvo por los puertos, se propone una función que determine los puertos adecuados\ntypedef enum {DIRECTION, LEVEL}PORT\\_TYPE; static void selectPorts(uint8\\_t \\*\\* port1, uint8\\_t \\*\\* port2, PORT\\_TYPE port\\_type) { if(port\\_type == DIRECTION){ \\*port1 = \u0026amp;DDRD; \\*port2 = \u0026amp;DDRB; }else if(port\\_type == LEVEL){ \\*port1 = \u0026amp;PORTD; \\*port2 = \u0026amp;PORTB; } } de esta forma hemos eliminado las repeticiones\n//display7.c #include\u0026quot;display7.h\u0026quot; #include\u0026lt;avr/io.h\u0026gt; #include\u0026lt;stdint.h\u0026gt; #define led\\_A (1\u0026lt;\u0026lt;PD2) #define led\\_B (1\u0026lt;\u0026lt;PD3) #define led\\_C (1\u0026lt;\u0026lt;PD4) #define led\\_D (1\u0026lt;\u0026lt;PD5) #define led\\_E (1\u0026lt;\u0026lt;PD6) #define led\\_F (1\u0026lt;\u0026lt;PD7) #define led\\_G (1\u0026lt;\u0026lt;PB2) static void setBits(uint8\\_t \\*regi, uint8\\_t bits) { \\*regi |= bits; } static void clearBits(uint8\\_t \\*regi, uint8\\_t bits) { \\*regi \u0026amp;= ~bits; } typedef enum {DIRECTION, LEVEL}PORT\\_TYPE; static void selectPorts(uint8\\_t \\*\\* port1, uint8\\_t \\*\\* port2, PORT\\_TYPE port\\_type) { if(port\\_type == DIRECTION){ \\*port1 = \u0026amp;DDRD; \\*port2 = \u0026amp;DDRB; }else if(port\\_type == LEVEL){ \\*port1 = \u0026amp;PORTD; \\*port2 = \u0026amp;PORTB; } } static void actionOnPorts(void (\\*action)(uint8\\_t \\*, uint8\\_t), PORT\\_TYPE port\\_type) { uint8\\_t \\* port1; uint8\\_t \\* port2; selectPorts(\u0026amp;port1, \u0026amp;port2, port\\_type); action(port1, led\\_A|led\\_B|led\\_C|led\\_D|led\\_E|led\\_F); action(port2, led\\_G); } static void pinoutAsOutputs(void) { actionOnPorts(setBits, DIRECTION); } static void pinoutAsInputs(void) { actionOnPorts(clearBits, DIRECTION); } static void pinoutLevelLow(void) { actionOnPorts(clearBits, LEVEL); } void display7\\_init(void) { pinoutAsOutputs(); pinoutLevelLow(); } void display7\\_destroy(void) { pinoutAsInputs(); pinoutLevelLow(); } void display7\\_setNumber(short number) { if(number == 0){ setBits(\u0026amp;PORTD, led\\_A|led\\_B|led\\_C|led\\_D|led\\_E|led\\_F); clearBits(\u0026amp;PORTB, led\\_G); }else if(number == 1){ setBits(\u0026amp;PORTD, led\\_B|led\\_C); clearBits(\u0026amp;PORTD, led\\_A|led\\_D|led\\_E|led\\_F); clearBits(\u0026amp;PORTB, led\\_G); } //... hasta number == 9 } nos toca mejorar de alguna manera la función display7_setNumber, podemos seguir llenando los casos, pero ya comienza a verse un desorden importante, otra aproximación para establecer los números puede ser, apagar todos y encender los necesarios o encender todos y apagar los necesarios, por ejemplo el cero, encendemos todos y apagamos G, en el caso de el uno, apagamos todos y posteriormente encendemos B y C,\nstatic void pinoutLevelHigh(void) { actionOnPorts(setBits, LEVEL); } void display7\\_setNumber(short number) { if(number == 0){ pinoutLevelHigh(); clearBits(\u0026amp;PORTB, led\\_G); }else if(number == 1){ pinoutLevelLow(); setBits(\u0026amp;PORTD, led\\_B|led\\_C); }else if(number == 2){ pinoutLevelHigh(); clearBits(\u0026amp;PORTD, led\\_F|led\\_C); }else if(number == 3){ pinoutLevelHigh(); clearBits(\u0026amp;PORTD, led\\_F|led\\_E); }else if(number == 4){ pinoutLevelHigh(); clearBits(\u0026amp;PORTD, led\\_A|led\\_D|led\\_E); }else if(number == 5){ pinoutLevelHigh(); clearBits(\u0026amp;PORTD, led\\_B|led\\_E); }else if(number == 6){ pinoutLevelHigh(); clearBits(\u0026amp;PORTD, led\\_B); }else if(number == 7){ pinoutLevelLow(); setBits(\u0026amp;PORTD, led\\_A|led\\_B|led\\_C); }else if(number == 8){ pinoutLevelHigh(); }else if(number == 9){ pinoutLevelHigh(); clearBits(\u0026amp;PORTD, led\\_E); } } Compilando el programa y verificando su funcionamiento me doy cuenta de que el led G, no funciona, nuestras refactorizaciones nos han ayudado a minimizar la posibilidad de error, restringiendo el acceso a los puertos a un par de funciones, sin embargo el error no es probable que se encuentre ahí, pues el resto de leds usan dichas funciones y tiene un comportamiento correcto, el error debe estar en un lugar aislado, efectivamente en la directiva #define led_G (1\u0026laquo;PB2) se encuentra el error, pues el pin correcto es PB0.\nDefinitivamente la función setNumber es mejorable, hay repetición de las funciones pinout y no me parece adecuado exponer el puerto PORTD en este nivel. Antes de arreglarlo, modifiquemos nuestro proyecto ino para realizar la cuenta.\n//proyecto.ino #define F\\_CPU 16000000UL #include\u0026lt;util/delay.h\u0026gt; #include\u0026quot;display7.h\u0026quot; int main(void) { display7\\_init(); while(1){ for(int i = 0; i\u0026lt;10; i++){ display7\\_setNumber(i); \\_delay\\_ms(1000); } } } Compilamos y subimos,\nEn la siguiente entrada mejoraremos la función setNumber.\n"}),a.add({id:8,href:'/docs/avr/programando-avr-en-c-apuntadores-punteros-pointers-ii-apuntadores-dobles/',title:"Programando Avr en C.- Apuntadores, punteros, pointers III. Apuntadores Dobles.",section:"Programación Avr en C.",content:"Los apuntadores suenan bastante complejos, nuestro cerebro amplifica su complejidad, pero al igual que cualquier otra variable su funcionamiento es simple,\ntipo ** nombre_apuntador; a que me refiero con apuntador doble, a un apuntador que guarda direcciones de otros apuntadores de su mismo tipo,\nchar caracter1 = 'a'; char caracter2 = 'b'; char \\* letra = \u0026amp;caracter1; char \\*\\* apuntador\\_doble = \u0026amp;letra; \\*apuntador\\_doble = \u0026amp;caracter2; //ahora letra apunta a la dirección de caracter2, //\\*letra es 'b' el propósito evidente de los apuntadores dobles, es cambiar el valor a donde apuntan apuntadores simples,\nint \\* pointer1=NULL; int \\* pointer2=NULL; void updatePointers(int \\*\\* a, int \\*\\* b) { \\*a = direction\\_1; \\*b = direction\\_2; } //ahora los apuntadores apuntan a las //direcciones en direction\\_n Esta aplicación es muy sencilla, la usaremos con frecuencia.\n"}),a.add({id:9,href:'/docs/avr/programando-avr-en-c-apuntadores-punteros-pointers-ii-apuntadores-a-funciones/',title:"Programando Avr en C.- Apuntadores, punteros, pointers II. Apuntadores a funciones.",section:"Programación Avr en C.",content:"Como ya he dicho un apuntador es una variable que apunta a direcciones de memoria, también hemos mencionado que los apuntadores deben ser especificados sobre el tipo, cuando las funciones se compilan se les asigna una dirección en memoria, ¿existirán apuntadores a funciones?, la respuesta es afirmativa, la sintaxis es un poco rara,\ntipo (*nombre_apuntador)(argumento1, argumento2, ..., argumento_n); al igual que los apuntadores comunes, los apuntadores a funciones deben ser especificados con el tipo de dato que regresan, entre parentesis se coloca el operador * seguido del nombre del apuntador, finalmente se especifican los parámetros)\nint (\\*operacion)(int a, int b); int suma(int a, int b) { return a + b; } int resta(int a, int b) { return a - b; } int a = 5; int b = 10; if(condicion) operacion = suma; else operacion = resta; int c = operacion(a , b); /\\* Sí condición es verdadera c contendrá 15 de \\* lo contrario c contendrá -5 \\*/ gracias a los apuntadores a funciones, también es posible pasar funciones como argumentos de otras funciones,\nint operadorBinario(int (\\*operation)(int a, int b), int c, int d) { return operation(c,d); } int resultado = operadorBinario(suma, 5, 10); //resultado es igual a 15 resultado = operadorBinario(resta, 5, 10); //resultado = -5; Esta característica nos ayudara a mejorar la calidad del código.\n"}),a.add({id:10,href:'/docs/perifericos/gpio/perifericos-atmega328p-puertos-de-entrada-salida-de-proposito-general-gpio-v-display-siete-segmentos/',title:"Display Siete Segmentos IV.",section:"GPIO",content:"Nuestro trabajo consiste en implementar las funciones del módulo contamos con un par de funciones, una para iniciar y otra para cerrar el módulo y una tercera para establecer el número, la interfaz es muy sencilla y para nuestro propósito es más que suficiente.\nLa mayor parte del trabajo recae en la tercer función y la dejamos para el final. Es muy común que los módulos contengan dos funciones, init y close o create y destroy, el trabajo de estas dos funciones es llevar al módulo a un estado conocido y liberar los recursos respectivamente. Para el módulo display7 ambas funciones son simples, en la función destroy, los recursos que se pueden liberar son los puertos y los pines, sin embargo en este caso es de poca utilidad, pues aunque liberemos los recursos nadie puede usarlos, esto no quiere decir que la función destroy siempre sera tan simple, en módulos más complejos tiene una importancia fundamental sobre todo la utilizar memoria dinámica.\nLa función init tiene la misión de establecer las condiciones adecuadas para que el resto del módulo pueda hacer su trabajo, modificara lo registros de los puertos para establecerlos como salidas y con nivel bajo, el código ya lo tenemos de entradas anteriores, así que lo movemos a la función display7_init().\n//display7.c #include\u0026quot;display7.h\u0026quot; #include\u0026lt;avr/io.h\u0026gt; void display7\\_init(void) { //pinout como salidas DDRB |= (1\u0026lt;\u0026lt;PB0); DDRD |= (1\u0026lt;\u0026lt;PD2)|(1\u0026lt;\u0026lt;PD3)|(1\u0026lt;\u0026lt;PD4)| (1\u0026lt;\u0026lt;PD5)|(1\u0026lt;\u0026lt;PD6)|(1\u0026lt;\u0026lt;PD7); //pinout nivel bajo PORTB \u0026amp;= ~(1\u0026lt;\u0026lt;PB0); PORTD \u0026amp;= ~((1\u0026lt;\u0026lt;PD2)|(1\u0026lt;\u0026lt;PD3)|(1\u0026lt;\u0026lt;PD4)| (1\u0026lt;\u0026lt;PD5)|(1\u0026lt;\u0026lt;PD6)|(1\u0026lt;\u0026lt;PD7)); } void display7\\_destroy(void) { } void display7\\_setNumber(short number) { } se incluye avr/io.h para acceder a los registros, en el futuro modificaremos la función init a una versión mejorada, por ahora lo dejamos así. La función destroy regresa los puertos y pines a su estado original,\n//display7.c #include\u0026quot;display7.h\u0026quot; #include\u0026lt;avr/io.h\u0026gt; void display7\\_init(void) { //pinout como salidas DDRB |= (1\u0026lt;\u0026lt;PB0); DDRD |= (1\u0026lt;\u0026lt;PD2)|(1\u0026lt;\u0026lt;PD3)|(1\u0026lt;\u0026lt;PD4)| (1\u0026lt;\u0026lt;PD5)|(1\u0026lt;\u0026lt;PD6)|(1\u0026lt;\u0026lt;PD7); //pinout nivel bajo PORTB \u0026amp;= ~(1\u0026lt;\u0026lt;PB0); PORTD \u0026amp;= ~((1\u0026lt;\u0026lt;PD2)|(1\u0026lt;\u0026lt;PD3)|(1\u0026lt;\u0026lt;PD4)| (1\u0026lt;\u0026lt;PD5)|(1\u0026lt;\u0026lt;PD6)|(1\u0026lt;\u0026lt;PD7)); } void display7\\_destroy(void) { //pinout como entradas DDRB \u0026amp;= ~(1\u0026lt;\u0026lt;PB0); DDRD \u0026amp;= ~((1\u0026lt;\u0026lt;PD2)|(1\u0026lt;\u0026lt;PD3)|(1\u0026lt;\u0026lt;PD4)| (1\u0026lt;\u0026lt;PD5)|(1\u0026lt;\u0026lt;PD6)|(1\u0026lt;\u0026lt;PD7)); //pinout nivel bajo PORTB \u0026amp;= ~(1\u0026lt;\u0026lt;PB0); PORTD \u0026amp;= ~((1\u0026lt;\u0026lt;PD2)|(1\u0026lt;\u0026lt;PD3)|(1\u0026lt;\u0026lt;PD4)| (1\u0026lt;\u0026lt;PD5)|(1\u0026lt;\u0026lt;PD6)|(1\u0026lt;\u0026lt;PD7)); } void display7\\_setNumber(short number) { } Hay modificaciones necesarias para el código anterior, lo comentare al final. La tarea de la función setNumber, es modificar un número decimal entre 0 y 9 de tal forma que se vea reflejado en el display, la siguiente es la implementación más sencilla de la cual haré algunos comentarios.\nvoid display7\\_setNumber(short number) { if(number == 0){ PORTB \u0026amp;= ~(1\u0026lt;\u0026lt;PB0); //LED G apagado PORTD |= (1\u0026lt;\u0026lt;PD2)|(1\u0026lt;\u0026lt;PD3)|(1\u0026lt;\u0026lt;PD4)| (1\u0026lt;\u0026lt;PD5)|(1\u0026lt;\u0026lt;PD6)|(1\u0026lt;\u0026lt;PD7); }else if(number == 1){ PORTB \u0026amp;= ~(1\u0026lt;\u0026lt;PB0); PORTD \u0026amp;= ~((1\u0026lt;\u0026lt;PD2)| (1\u0026lt;\u0026lt;PD5)|(1\u0026lt;\u0026lt;PD6)|(1\u0026lt;\u0026lt;PD7)); PORTD |= (1\u0026lt;\u0026lt;PD3)|(1\u0026lt;\u0026lt;PD4);//LED B y C encendido } //... hasta number == 9 } Un dogma muy importante en el mundo de la programación especifica que, la repetición de código es la mayor fuente de errores, con forme vamos agregando casos a la función setNumber vamos aumentando las posibilidades de equivocarnos, vale la pena suspender el desarrollo en aras de refactorizar lo que ya tenemos. Refactorizar es un gran tema que podría entenderse como pulir el código, como primer paso vamos a reescribir esos horribles operandos OR, sabemos que PB0 corresponde al led G por el esquemático, es más eficiente que el propio código exprese a donde pertenece,\n#define led_A (1\u0026lt;\u0026lt;PD2) #define led_B (1\u0026lt;\u0026lt;PD3) #define led_C (1\u0026lt;\u0026lt;PD4) #define led_D (1\u0026lt;\u0026lt;PD5) #define led_E (1\u0026lt;\u0026lt;PD6) #define led_F (1\u0026lt;\u0026lt;PD7) #define led_G (1\u0026lt;\u0026lt;PB0) de esta forma el código luce más expresivo\n//display7.c #include\u0026quot;display7.h\u0026quot; #include\u0026lt;avr/io.h\u0026gt; #define led\\_A (1\u0026lt;\u0026lt;PD2) #define led\\_B (1\u0026lt;\u0026lt;PD3) #define led\\_C (1\u0026lt;\u0026lt;PD4) #define led\\_D (1\u0026lt;\u0026lt;PD5) #define led\\_E (1\u0026lt;\u0026lt;PD6) #define led\\_F (1\u0026lt;\u0026lt;PD7) #define led\\_G (1\u0026lt;\u0026lt;PB2) void display7\\_init(void) { //pinout como salidas DDRB |= led\\_G; DDRD |= led\\_A|led\\_B|led\\_C| led\\_D|led\\_E|led\\_F; //pinout nivel bajo PORTB \u0026amp;= ~led\\_G; PORTD \u0026amp;= ~(led\\_A|led\\_B|led\\_C| led\\_D|led\\_E|led\\_F); } void display7\\_destroy(void) { //pinout como entradas DDRB \u0026amp;= ~led\\_G; DDRD \u0026amp;= ~(led\\_A|led\\_B|led\\_C| led\\_D|led\\_E|led\\_F); //pinout nivel bajo PORTB \u0026amp;= ~led\\_G; PORTD \u0026amp;= ~(led\\_A|led\\_B|led\\_C| led\\_D|led\\_E|led\\_F); } void display7\\_setNumber(short number) { if(number == 0){ PORTB \u0026amp;= ~led\\_G; //LED G apagado PORTD |= led\\_A|led\\_B|led\\_C| led\\_D|led\\_E|led\\_F; }else if(number == 1){ PORTB \u0026amp;= ~led\\_G; PORTD \u0026amp;= ~(led\\_A| led\\_D|led\\_E|led\\_F); PORTD |= led\\_B|led\\_C;//LED B y C encendido } //... hasta number == 9 } sin embargo se ve algo críptico y no muestra por si solo las intenciones de cada función. Haremos uso de funciones auxiliares, para ayudarnos a reducir el código repetido y ser más expresivo. De inmediato identificamos que la función init esta compuesta de dos partes, establecer los pines como salidas y establecer los niveles en bajo, podemos refactorizar utilizando dos funciones auxiliares de la forma\nvoid display7_init(void) { pinoutAsOutputs(); pinoutLowLevel(); } de esta forma es sencillo ver la intensión de la función init, para hacer valido el código colocamos ambas implementaciones antes de la función init\nstatic void pinoutAsOutputs(void) { //pinout como salidas DDRB |= led_G; DDRD |= led_A|led_B|led_C| led_D|led_E|led_F; } static void pinoutLowLevel(void) { //pinout nivel bajo PORTB \u0026amp;= ~led_G; PORTD \u0026amp;= ~(led_A|led_B|led_C| led_D|led_E|led_F); } void display7_init(void) { pinoutAsOutputs(); pinoutLowLevel(); } La palabra static(cuidado static tiene otros usos en otros contextos) sirve para indicar que las funciones únicamente pueden ser llamadas desde el mismo archivo, en este caso display7.c, en el futuro haré una entrada especifica sobre el alcance(scope).\nLogramos un poco de legibilidad, pero también importante es que evitamos la repetición de código, ¿en donde?, hay que mirar la función destroy, que puede ser refactorizada como\nvoid display7_destroy(void) { pinoutAsInputs(); pinoutLowLevel(); } pinoutLowLevel ya la implementamos, solo queda implementar pinoutAsInputs,\nstatic void pinoutAsOutputs(void) { //pinout como salidas DDRB |= led_G; DDRD |= led_A|led_B|led_C| led_D|led_E|led_F; } static pinoutAsInputs(void) { //pinout como entradas DDRB \u0026amp;= ~led_G; DDRD \u0026amp;= ~(led_A|led_B|led_C| led_D|led_E|led_F); } static void pinoutLowLevel(void) { //pinout nivel bajo PORTB \u0026amp;= ~led_G; PORTD \u0026amp;= ~(led_A|led_B|led_C| led_D|led_E|led_F); } void display7_init(void) { pinoutAsOutputs(); pinoutLowLevel(); } void display7_destroy(void) { pinoutAsInputs(); pinoutLowLevel(); } aun le falta al código, pero ya comienza a verse la forma. Más refactorización en la siguiente entrada.\n"}),a.add({id:11,href:'/docs/avr/programando-avr-en-c-apuntadores-punteros-pointers/',title:"Programando Avr en C.- Apuntadores, punteros, pointers I.",section:"Programación Avr en C.",content:"Los apuntadores (pienso que esta es la traducción más acertada), también conocidos como punteros o pointers en ingles, es un tipo de dato característico de lenguajes de bajo nivel y algunos de nivel medio, C por supuesto cuenta con tal tipo de dato.\nUn apuntador es una variable cuyo tipo de dato almacena direcciones de memoria, tan simple como eso. Aunque una dirección de memoria puede ser interpretada como un entero, es mejor pensar que una dirección de memoria es un tipo de dato diferente, un tipo de dato de tipo apuntador.\nLos apuntadores son temidos y exaltados, por buenas razones, el problema es que los apuntadores sirven para gran cantidad de aplicaciones y da la impresión de que debes conocerlas todas, por supuesto no es así, se puede usar apuntadores de forma efectiva sin tener todo el bagaje técnico alrededor, e ir aprendiendo gradualmente los pormenores. El secreto esta en auto limitarse y ser disciplinado.\nla sintaxis para declarar un apuntador es la siguiente\ntipo_a_donde_apunta * nombre_apuntador; un apuntador que apunta a una variable de tipo entero es diferente a un apuntador que apunta a una variable de tipo carácter,\nchar a; int b; int * apuntador1; // solo puede apuntar hacia b, apuntar hacia a implica un error Operador addressOff \u0026amp; #  Para almacenar la dirección de una variable primero debemos obtener su dirección, para ello contamos con el operador \u0026amp;,\nint b = 0; int * apuntador = \u0026amp;b; //apuntador ahora contiene la dirección de memoria de b Operador de indirección * #  ¿Para que se usa un apuntador?, como mencione las aplicaciones son amplias, pero la base es la misma, se trata de acceder al contenido guardado en una dirección de memoria de manera indirecta. Una vez establecido un apuntador, usamos el operador de indirección para acceder al contenido a donde apunta.\nint b = 0; int * apuntador = \u0026amp;b; *apuntador = 10; //ahora b contiene el valor 10 y no 0. Una de las aplicaciones más importantes es el paso de parámetros a funciones, cuya intensión sea modificar tales parámetros, por ejemplo\nint a = 5; int b= 3; //Se pasan dos apuntadores intercambiar(\u0026amp;a, \u0026amp;b); //pasar \u0026amp;a, es equivalente a crear un apuntador //int *apuntador = \u0026amp;a y escribir intercambiar(apuntador, \u0026amp;b); //ahora a = 3 y b = 5; void intercambiar(int * v1, int * v2) { int tmp = *v1;//tmp = valor guardado en la //dirección a donde apunta v1 *v1 = *v2; *v2 = tmp; } Usaremos ampliamente la forma de la función intercambiar, por ahora es suficiente con este conocimiento sobre apuntadores, por supuesto más adelante veremos otras aplicaciones.\n"}),a.add({id:12,href:'/posts/contacto/',title:"Contacto",section:"Posts",content:"Hablemos 👋. No dudes en ponerte en contacto con nosotros mediante la información de contacto a continuación, o envíanos un mensaje mediante el formulario.\nPonte en contacto con nosotros #  Calle Ejemplo, 10\nCiudad, 10100\nEspaña\ncorreoelectronico@ejemplo.com\n(+34) 399 555 234\nEnvíanos un mensaje #  "}),a.add({id:13,href:'/posts/gpio-atmega328p/',title:"GPIO atmega328p.",section:"Posts",content:"_Si, se nos acabo la duela y pintamos la tierra, ¿qué trucazo no? #  Moe Szyslak_\n Sigue mi blog #  Recibe nuevo contenido directamente en tu bandeja de entrada.\n[jetpack_subscription_form subscribe_placeholder=\u0026ldquo;Dirección de correo electrónico\u0026rdquo; show_subscribers_total=\u0026ldquo;false\u0026rdquo; button_on_newline=\u0026ldquo;true\u0026rdquo; submit_button_text=\u0026ldquo;Suscribir\u0026rdquo; custom_background_emailfield_color=\u0026ldquo;undefined\u0026rdquo; custom_background_button_color=\u0026ldquo;undefined\u0026rdquo; custom_text_button_color=\u0026ldquo;undefined\u0026rdquo; custom_font_size=\u0026ldquo;16\u0026rdquo; custom_border_radius=\u0026ldquo;0\u0026rdquo; custom_border_weight=\u0026ldquo;1\u0026rdquo; custom_border_color=\u0026ldquo;undefined\u0026rdquo; custom_padding=\u0026ldquo;15\u0026rdquo; custom_spacing=\u0026ldquo;10\u0026rdquo; submit_button_classes=\u0026ldquo;has-text-color has-background-color has-background has-primary-background-color\u0026rdquo; email_field_classes=\u0026quot;\u0026quot; show_only_email_and_button=\u0026ldquo;true\u0026rdquo; ]\n"}),a.add({id:14,href:'/docs/perifericos/gpio/perifericos-atmega328p-puertos-de-entrada-salida-de-proposito-general-gpio-iv-display-siete-segmentos/',title:"Display Siete Segmentos III.",section:"GPIO",content:"No se si ya lo había mencionado pero odio el entorno de desarrollo de arduino, en esta ocasión por la forma tan pobre de manejar ficheros. Continuando la entrada anterior, vamos a mover nuestro módulo en un par de archivos, creamos dos ficheros cuyo nombre deje en claro que hay escrito en él, un buen nombre es display7,\n$touch display7.c $touch display7.h ahora en nuestro entorno de desarrollo incluimos los dos ficheros, para ello vamos al menú Programa-\u0026gt;Añadir fichero y añadimos ambos ficheros, ambos aparecerán en nuestro entorno de desarrollo y podrán ser editados desde el mismo, movemos el módulo a los nuevos ficheros, los prototipos van en él .h y las definiciones al .c, de esta manera tenemos los tres ficheros siguientes\n//proyecto.ino #include\u0026lt;avr/io.h\u0026gt; int main(void) { DDRB |= (1\u0026lt;\u0026lt;PB0); DDRD |= (1\u0026lt;\u0026lt;PD2)|(1\u0026lt;\u0026lt;PD3)|(1\u0026lt;\u0026lt;PD4)| (1\u0026lt;\u0026lt;PD5)|(1\u0026lt;\u0026lt;PD6)|(1\u0026lt;\u0026lt;PD7); PORTB |= (1\u0026lt;\u0026lt;PB0); PORTD |= (1\u0026lt;\u0026lt;PD2)|(1\u0026lt;\u0026lt;PD4)|(1\u0026lt;\u0026lt;PD5)|(1\u0026lt;\u0026lt;PD7); return 0; } //display7.h void display7_init(void); void display7_setNumber(short number); void display7_destroy(void);\n//display7.c void display7\\_init(void) { } void display7\\_setNumber(short number) { } void display7\\_destroy(void) { } ``` nuevamente compilamos el programa y no nos dará ningún error, salvo que no hace nada. Para poder acceder a la interfaz del módulo, es necesario incluirla en nuestro fichero principal, basta con agregar la directiva #include\u0026quot;display7.h\u0026quot; antes de la función main, de esta forma el módulo puede ser desarrollado de forma independiente y paralela al programa principal, modifiquemos nuestro .ino para usar la interfaz ``` #include\u0026lt;avr/io.h\u0026gt; #include\u0026quot;display7.h\u0026quot; int main(void) { display7\\_init(); while(1){ display7\\_setNumber(0); \\_delay\\_ms(1000); display7\\_setNumber(1); \\_delay\\_ms(1000); } } ``` pienso que el código se ve definitivamente más limpio y muestra claramente que se está haciendo, sin embargo si tratamos de compilar nos dará un error, similar a este ``` undefined reference to `display7_init()' ``` en pocas palabras el compilador(en realidad el linker) no encuentra las definiciones del módulo, las definiciones están en el fichero .c, como mencionamos en entradas anteriores, el entorno arduino en realidad compila ficheros c++, pero como somos tercos y queremos programar en c debemos indicarle al compilador que nuestro ficheros no son c++, esto es muy sencillo, basta con añadir ``` extern \u0026quot;C\u0026quot; { ``` en el fichero de la interfaz y agregar después del ultimo prototipo un ``` } ``` el archivo .h queda ``` extern \u0026quot;C\u0026quot; { void display7\\_init(void); void display7\\_setNumber(short number); void display7\\_destroy(void); } ``` Compilamos y esta vez no obtendremos ningún error. De esta forma el compilador hará lo adecuado para poder usar el módulo, esta solución sirve para nuestros propósitos, sin embargo en el futuro, desarrollaremos nuestros programas con un compilador de \u0026quot;c\u0026quot;, el compilador no entenderá la línea extern \u0026quot;C\u0026quot; y nos dará un error, ¿cómo hacemos que el módulo funcione con el compilador de c y también con el de c++?, nuevamente la solución es sencilla, cuando usamos un compilador de c++, este pasa una definición, explicitamente ``` #define __cplusplus ``` esto no sucede cuando compilamos con un compilador de c, aprovechando esta definición podemos usar la directiva ``` #ifdef ALGO //si ALGO fue definido, coloca estas lineas #endif ``` modificamos el fichero .h y obtenemos ``` //display7.h #ifdef \\_\\_cplusplus extern \u0026quot;C\u0026quot; { #endif void display7\\_init(void); void display7\\_setNumber(short number); void display7\\_destroy(void); #ifdef \\_\\_cplusplus } #endif ``` este fichero está casi listo, funciona con ambos compiladores, sin embargo tiene un gran problema, ¿qué pasa si por error incluimos más de 1 vez nuestras interfaz?, la respuesta es que nos indicara un error de doble definición, nuevamente nos apoyamos en la directiva #define, de la forma ``` #ifndef MODULO #define MODULO //Aquí las definiciones #endif ``` claramente significa, si no esta definido, define y coloca la interfaz, de lo contrario si ya esta definido no hagas nada, nuestra implementación queda así ``` //display7.h #ifndef DISPLAY7\\_H #define DISPLAY7\\_H #ifdef \\_\\_cplusplus extern \u0026quot;C\u0026quot; { #endif void display7\\_init(void); void display7\\_setNumber(short number); void display7\\_destroy(void); #ifdef \\_\\_cplusplus } #endif #endif//DISPLAY7\\_H ``` el fichero principal queda así ``` //proyecto.ino #include\u0026lt;avr/io.h\u0026gt; //Necesario para \\_delay\\_ms(), frecuencia de nuestro arduino #define F\\_CPU 16000000UL #include\u0026lt;util/delay.h\u0026gt; //Nos permite usar delay\\_ms() #include\u0026quot;display7.h\u0026quot; int main(void) { display7\\_init(); while(1){ display7\\_setNumber(0); \\_delay\\_ms(1000); display7\\_setNumber(1); \\_delay\\_ms(1000); } } ``` anteriormente olvide las lineas 4 y 5, son necesarias para usar la función \\_delay\\_ms. Las definiciones están en el fichero .c, debemos agregar la interfaz a este fichero también con la directiva #include ``` //display7.c #include\u0026quot;display7.h\u0026quot; void display7\\_init(void) { } void display7\\_setNumber(short number) { } void display7\\_destroy(void) { } ``` En un entorno de desarrollo decente el fichero .c nos hubiera dado problemas pues no esta permitido compilar una implementación sin indicar a que interfaz pertenece, sin embargo el entorno de arduino nos auto corrige el error, esto es otra cosa por lo que no me gusta arduino, me oculta mis errores. Nuestro código ahora luce más modular en un diagrama luce así ![](https://eleckia.files.wordpress.com/2020/05/7segmod.png?w=366) Diseño en módulo Como se ve en la imagen ahora proyecto.ino (función main) depende de la interfaz, mientras que display7.c implementa el modulo, dicho de otra forma, proyecto.ino no sabe que hay en display7.c, el solo conoce lo que hay en display7.h, de esta manera podemos reutilizar el módulo en otros módulos, sin miedo a romper el código fuera de este y muy importante sin tener que reescribir código extra. Establecido lo anterior, ahora si nos toca implementar el módulo, por supuesto en la siguiente entrada."}),a.add({id:15,href:'/docs/perifericos/gpio/perifericos-atmega328p-puertos-de-entrada-salida-de-proposito-general-gpio-iii-display-siete-segmentos/',title:"Display Siete Segmentos II.",section:"GPIO",content:"Nuestro anterior programa sirve para dos cosas, para nada y para la basura, no hay ninguna diferencia con respecto a conectar los pines del display directamente a Vcc, requerimos funcionalidad, que el microcontrolador haga lo adecuado para mostrar el número que nosotros indiquemos y que nosotros hagamos el mínimo trabajo para indicarlo, algo similar a\nsetNumber(3); //Muestra el número 3 en el display de esta forma podemos realizar una secuencia de números\nint main(void) { while(1){ setNumber(0); delay setNumber(1); delay . . . setNumber(9); delay } } el display mostrara los números del 0 al 9 en orden ascendente, nuestro objetivo entonces es definir la función setNumber.\nAunque en este problema sencillo podemos programar la solución de forma monolítica(un solo fragmento de código), es de utilidad desarrollarlo en forma modular, como en la siguiente figura\ndisplay 7 segmentos como módulo\npensar en forma modular tiene grandes ventajas y conforme crece el proyecto se vuelve la única forma sostenible de escribir código, la primer gran ventaja es la posibilidad de reutilizar código, seria absurdo escribir un controlador de 7 segmentos en cada proyecto nuevo, la segunda ventaja es la capacidad de extender el código ya escrito, la tercer gran ventaja es que el código es más \u0026ldquo;mantenible\u0026rdquo;, entre muchas otras que se irán comentando.\nPara nuestro propósito un módulo es un ente de software que está aislado, autocontenido y es altamente cohesivo, dicho de otra forma, la función main no tiene conocimiento de las variables y funciones del módulo, salvo por un conjunto de funciones comúnmente llamadas interfaz. Una bonita interfaz para nuestro modulo puede ser\nvoid display7_init(void); void display7_setNumber(short number); void display7_destroy(void); elegir buenos nombres es una parte fundamental para que nuestro código sea de alta calidad, estoy seguro que al leer las funciones anteriores de inmediato formaste una idea de lo que hacen y a que pertenecen. Sin pensarlo hemos llegado a uno de los grandes dogmas de la programación y de la resolución de problemas en general, dividimos el problema en problemas más pequeños, ni tardos ni perezosos modificamos nuestro programa y agregamos el módulo,\n#include\u0026lt;avr/io.h\u0026gt; void display7\\_init(void); void display7\\_setNumber(short number); void display7\\_destroy(void); int main(void) { DDRB |= (1\u0026lt;\u0026lt;PB0); DDRD |= (1\u0026lt;\u0026lt;PD2)|(1\u0026lt;\u0026lt;PD3)|(1\u0026lt;\u0026lt;PD4)| (1\u0026lt;\u0026lt;PD5)|(1\u0026lt;\u0026lt;PD6)|(1\u0026lt;\u0026lt;PD7); PORTB |= (1\u0026lt;\u0026lt;PB0); PORTD |= (1\u0026lt;\u0026lt;PD2)|(1\u0026lt;\u0026lt;PD4)|(1\u0026lt;\u0026lt;PD5)|(1\u0026lt;\u0026lt;PD7); return 0; } void display7\\_init(void) { } void display7\\_setNumber(short number) { } void display7\\_destroy(void) { } este código compila sin problemas pero no hace el trabajo requerido, al principio agregamos los prototipos del módulo, pero aun no los llamamos en la función main, tampoco hemos implementado dichas funciones. Antes de definir la interfaz, anteriormente indique que la función main no tiene conocimiento de las funciones y variables de nuestro módulo, si escribimos el código en el mismo fichero, el usuario de la función main tendrá a la vista todas las funciones y variables y probablemente tenga la tentación de usarlas, una buena idea para evitar que esto suceda es utilizar un par de archivos extra exclusivos para nuestro módulo, esto lo veremos en la siguiente entrada.\n"}),a.add({id:16,href:'/docs/avr/programando-avr-en-c-el-flujo-del-programa-if-else-if-else/',title:"Programando Avr en C.- El flujo del programa, if, else, if else.",section:"Programación Avr en C.",content:"Definimos el flujo del programa como, la ruta que toma la ejecución del mismo, imaginemos que tenemos una lista de tareas que debemos ejecutar, digamos, tarea 1, tarea 2, tarea 3, \u0026hellip;, tarea n, ya vimos que podemos abstraer tareas como funciones, entonces simplemente podemos agregar cada una de las funciones en orden para ejecutarlas,\nint main(void) { tarea1(); tarea2(); tarea3(); tarean(); return 0; } pero que pasa si queremos ejecutar alguna de estas tareas solo si se cumple una condición, digamos, solo si se pulsa un botón determinado, o solo si el resultado de una operación satisface algún requerimiento.\nPara ello contamos con la palabra if, si se cumple una condición, el código dentro de sus llaves se ejecutara, de lo contrario el programa continuara después de la llave de cierre,\nint main(void) { tarea1(); if(condicion){ //si condición es verdadera tarea2(); //se ejecutaran ésta dos tareas tarea3(); } tarea4(); //Aquí continua tarean(); return 0; } también es posible agregar la palabra else, para controlar el flujo cuando la condición es falsa\nint main(void) { tarea1(); if(condicion){ //si condición es verdadera tarea2(); //se ejecutara ésta tarea }else{ tarea3(); //si condición es falsa, ejecuta ésta tarea } tarea4(); tarean(); return 0; } agregar más sentencias nos permite un control aun más preciso.\nint main(void) { tarea1(); if(condicion == 0){ //si condición es igual a 0 tarea2(); //se ejecutara ésta tarea }else if(condicion == 1){ tarea3(); //si condición igual a 1, ejecuta ésta tarea }else{ tarea4(); //si no se cumple ninguna de las anteriores } tarean(); return 0; } es importante señalar que la ejecución es en orden descendente, si tenemos varios if else y en más de uno se cumple la condición, solo se ejecutara el primero que la cumpla en orden descendente.\nint main(void) { tarea1(); if(true){ tarea2(); //se ejecutara ésta tarea }else if(true){ tarea3(); //No se ejecuta }else{ tarea4(); //No se ejecuta } tarean(); //una vez ejecutada tarea2, el programa continua aquí return 0; } "}),a.add({id:17,href:'/docs/avr/programando-avr-en-c-constantes/',title:"Programando Avr en C.- Constantes",section:"Programación Avr en C.",content:"Las constantes son de gran utilidad en la programación, a diferencia de las variables, las constantes no pueden cambiar su valor.\nLas dos formas más comunes de definir constantes son con la palabra reservada const y con la directiva define.\nLa palabra const #  Agregando la palabra const a la declaración de una variable, esta se convierte en constate, sin embargo también debe asignarle el valor al momento de la declaración;\nuint8_t const NUMERO = 10; //Declaración de una constante NUMERO = 1; //error, no se puede reasignar Sin embargo el uso más cotidiano que tiene la palabra const es en los argumentos de funciones,\nint8_t suma(int8_t const sumando1, int8_t const sumando2); Directiva define #  Entre otras cosas, la directiva define puede ser usada para definir constantes;\n#define NUMERO 10 cuando el programa se compilar, la palabra NUMERO, se reemplaza por el número 10,\n#define PRIMERO 5 int8_t = 5 + PRIMERO; al compilar, sera reemplazado por\nint8_t = 5 + 5; Enum #  Los enum son un tipo de dato que nos facilitá la creación de colecciones de constantes, su sintaxis es\nenum NOMBRE{CONSTANTE1 = 0, CONSTANTE2, CONSTANTE3 = 5, CONSTANTE4}; de esta forma CONSTANTE1 es una variable de tipo enum NOMBRE y contiene el valor de 0, CONSTANTE2 contiene el valor 1 y CONSTANTE3 tiene el valor de 5 y CONSTANTE4 tiene el valor de 6.\nenum numeros{CERO, UNO, DOS}; a = CERO + UNO + DOS; //a contiene el número 3 ¿Por qué usar constantes? #  Hay dos conceptos al utilizar constantes, ser constante y querer ser constante.\nSer constante se refiere a declarar una constante explícitamente por ejemplo el número PI, SQRT2, etc.\nQuerer ser constante, se refiere a evitar que las variables cambien por accidente su valor, por ejemplo las funciones suele recibir parámetros constantes, se busca evitar que los parámetros cambien su valor, esto tomara sentido cuando comentemos los apuntadores en entradas posteriores.\nMuchos lenguajes de programación nuevos, definen a las variables como constantes (inmutable) y es el usuario quien explícitamente declara una variable como variable (mutable), la razón principal como se menciona es reducir la posibilidad de añadir errores de programación.\n"}),a.add({id:18,href:'/docs/avr/programando-avr-en-c-tipo-de-dato-booleano-operadores-booleanos-y-de-comparacion/',title:"Programando Avr en C.- Tipo de dato Booleano, operadores booleanos y de comparación.",section:"Programación Avr en C.",content:"Tipo de dato Booleano #  Otro tipo de datos básico es el tipo booleano, este tipo de dato puede contener unicamente dos valores, verdadero(true) o Falso(false), para tener acceso a este tipo de dato debemos incluir la biblioteca stdbool.h, la sintaxis es:\n#include\u0026lt;stdbool.h\u0026gt; //Para declarar una variable bool un\\_nombre; //Para definir un valor un\\_nombre = true; un\\_nombre = false; Es común asumir en C que cualquier valor diferente de cero o NULL es verdadero, sin embargo pienso que es mejor utilizar explícitamente los valores true o false para denotar valores booleanos, por razones de legibilidad.\nOperadores booleanos #  Como el nombre sugiere, los operadores booleanos operan sobre tipos de dato booleanos. El operador and(\u0026amp;\u0026amp;) probablemente es el más utilizado,\na \u0026amp;\u0026amp; b el resultado de la operación previa dará verdadero solo si ambos, a y b son verdaderos, resulta falso de lo contrario. La regla es\nfalse and false //es igual a false true and false //es igual a false false and true //es igual a false true and true //es igual a true El operador or(||)\na || b el resultado de la operación previa dará verdadero si a o b, o ambos son verdaderos, resulta falso de lo contrario. La regla or es\nfalse or false //es igual a false true or false //es igual a true false or true //es igual a true true or true //es igual a true El operador de negación (!)\n!a resulta verdadero si a es falso, resulta falso si a es verdadero.\n!false //es igual a true !true //es igual a false Operadores de comparación #  Los operadores de comparación, comparan dos expresiones y evalúan el resultado como falso o verdadero, por ejemplo el operador de igualdad (==)\na = 10; //entero b = 10; //entero c = (a == b); //boleano verdadero d = ((a+1) == b); //¿11 es igual a 10? falso la variable c contendrá verdadero, mientras que d sera falso pues 11 no es igual a 10.\notros operadores de comparación se resumen a continuación\n==\nIgual que\n!=\nDiferente de\n\u0026lt;\nmenor que\n\u0026gt;\nmayor que\n\u0026lt;=\nmenor o igual que\n\u0026gt;=\nmayor o igual que\n"}),a.add({id:19,href:'/docs/avr/programando-avr-en-c-funciones/',title:"Programando Avr en C.- Funciones",section:"Programación Avr en C.",content:"Las funciones son características fundamentales de cualquier lenguaje de programación, inclusive existe un \u0026ldquo;estilo\u0026rdquo; de programación llamado programación funcional, veamos brevemente como funcionan las funciones en C. Una función tiene la siguiente sintaxis en C,\ntipo_de_retorno nombre_de_funcion(tipo_dato argumento_n) { ... hacer_tareas ... return un_objeto_del_tipo_de_retorno; } las funciones pueden ser usadas como una forma de realizar tareas de manera reiterada, pueden recibir \u0026ldquo;n\u0026rdquo; cantidad de argumentos y retornar un valor, un ejemplo sencillo, definimos la función suma,\nint8_t suma(int8_t sumando1, int8_t sumando2) { int8_t resultado = sumando1 + sumando2; return resultado; } esta función simplemente suma los dos argumentos pasados en ella, para usarla se usa la sintaxis:\nint8_t numero = suma(3,2); al ejecutarse, la variable numero contendrá el valor de 5, las funciones pueden retornar cualquier tipo de dato, incluso alguno definido por nosotros como veremos en el futuro.\nAhora que sabemos definir funciones sencillas, escribamos un programa sencillo donde la usemos.\n#include\u0026lt;avr/io.h\u0026gt; //No se usará #include\u0026lt;stdint.h\u0026gt; //Para int8\\_t int main(void) { int8\\_t numero = suma(2,3); return 0; } int8\\_t suma(int8\\_t sumando1, int8\\_t sumando2) { int8\\_t resultado = sumando1 + sumando2; return resultado; } Ahora compilamos y nos dará un error o probablemente no, si compilamos este programa con un compilador de C y sin el software de Arduino, nos mostrar un error donde señala que la función no fue declarada,\nprogram.c: In function ‘int main()’: program.c:5:25: error: ‘suma’ was not declared in this scope int8_t numero = suma(2,3); por definición lo más recomendable es declarar cualquier objeto antes de usarlo, en nuestro código la función suma se declara y define al final del fichero, podríamos reescribir la función suma antes de la función main, esto esta bien para programas pequeños, sin embargo en programas grandes se vuelve una forma difícil de mantener, una forma más adecuada es usar un prototipo, un prototipo es una forma de declarar una función sin definirla, la sintaxis es similar a la definición de una función pero sin llaves y sin cuerpo,\ntipo_de_retorno nombre_de_funcion(tipo_dato argumento_n); en el caso de nuestra función suma su prototipo es\nint8_t suma(int8_t sumando1, int8_t sumando2); el prototipo debe tener el mismo nombre el mismo tipo de retorno y los mismos tipos de argumentos. Ahora agregando este prototipo antes de la función main, podemos estar seguros de que no habrá un error de compilación, el compilador se encargara de buscar la definición en el resto del código.\nArduino usa un compilador de C++ y probablemente no nos muestre ningún error, debido a que autogenera los prototipos, personalmente por cuestiones de legibilidad, prefiero definirlos yo mismo.\nEn las siguientes entradas entenderemos las ventajas que se obtiene de esta separación entre prototipo(declaración) y la definición. El código final es el siguiente:\n#include\u0026lt;avr/io.h\u0026gt; //No se usará #include\u0026lt;stdint.h\u0026gt; //Para int8\\_t int8\\_t suma(int8\\_t sumando1, int8\\_t sumando2);//Prototipo int main(void) { int8\\_t numero = suma(2,3);//Llamado a la función return 0; } //Definición de la función int8\\_t suma(int8\\_t sumando1, int8\\_t sumando2) { int8\\_t resultado = sumando1 + sumando2; return resultado; } al ejecutarse el programa el valor final de la variable numero sera 5.\n"}),a.add({id:20,href:'/docs/perifericos/gpio/biblioteca7/',title:"Api Display Siete Segmentos",section:"GPIO",content:"Api para un display de siete segmentos #  Escribamos una biblioteca/api sencilla que nos permita configurar un número en un display de 7 segmentos, el circuito es el siguiente,\nConexión Arduino-Display #  Contamos con un display de cátodo común por lo tanto cada segmento se enciende con un voltaje alto en el pin correspondiente, es decir para encender el segmento \u0026ldquo;A\u0026rdquo; debemos configurar el pin digital D2 en alto. Evitamos la conexión en los pines D0 y D1, debido a que estos están conectados al convertidor serial-usb, y pueden provocar problemas para subir el código a la tarjeta.\nComo primer paso debemos incluir la biblioteca \u0026ldquo;avr/io.h\u0026rdquo;, para tener acceso a los puertos de GPIOx de entrada/salida, cuyos registros asociados son DDRx, PORTx, PINx.\n#include\u0026lt;avr/io.h\u0026gt;Ahora declaramos la función principal, recordemos que la función principal es llamada automáticamente cuando el programa es ejecutado,\nint main(void) { return 0; } Dentro de las llaves del main configuramos los pines adecuados como salidas, para hacerlo requerimos saber a que pines del microcontrolador corresponden los pines del Arduino,\nfuente:(http://www.chicoree.fr/w/Arduino_sur_ATmega328P)\nEn la anterior imagen observamos la correspondencia entre los pines del Arduino y los del microcontrolador, por ejemplo el pin digital D2 es en realidad el pin PD2 del atmega328p, por ejemplo el pin digital D8 es en realidad el pin PB0 del atmega328p. Configuramos el registro DDRB y DDRD como salidas,\nDDRB |= (1\u0026lt;\u0026lt;PB0); DDRD |= (1\u0026lt;\u0026lt;PD2)|(1\u0026lt;\u0026lt;PD3)|(1\u0026lt;\u0026lt;PD4)| (1\u0026lt;\u0026lt;PD5)|(1\u0026lt;\u0026lt;PD6)|(1\u0026lt;\u0026lt;PD7); Ahora solo encendemos los leds, poniendo en alto los pines requeridos, por ejemplo para el número cinco, encendemos los segmentos a,c,d,f,g.\nPara ello escribimos a los puertos PORTB y PORTD los pines indicados\nPORTB |= (1\u0026lt;\u0026lt;PB0); PORTD |= (1\u0026lt;\u0026lt;PD2)|(1\u0026lt;\u0026lt;PD4)|(1\u0026lt;\u0026lt;PD5)|(1\u0026lt;\u0026lt;PD7); El código completo luce como el siguiente,\n#include\u0026lt;avr/io.h\u0026gt; int main(void) { DDRB |= (1\u0026lt;\u0026lt;PB0); DDRD |= (1\u0026lt;\u0026lt;PD2)|(1\u0026lt;\u0026lt;PD3)|(1\u0026lt;\u0026lt;PD4)| (1\u0026lt;\u0026lt;PD5)|(1\u0026lt;\u0026lt;PD6)|(1\u0026lt;\u0026lt;PD7); PORTB |= (1\u0026lt;\u0026lt;PB0); PORTD |= (1\u0026lt;\u0026lt;PD2)|(1\u0026lt;\u0026lt;PD4)|(1\u0026lt;\u0026lt;PD5)|(1\u0026lt;\u0026lt;PD7); return 0; } Compilamos y subimos.\nEl \u0026ldquo;estilo\u0026rdquo; en que hemos escrito nuestro programa es coloquialmente llamado hardcoding, debido a que nosotros especificamos tanto los valores como el flujo, usualmente lo que queremos es que el programa calcule los valores y elija el flujo, imaginemos que ahora requerimos una secuencia de números en serie, comenzado con 1 y terminando en 9 y repetir esta secuencia 1000 veces, seria un poco tedioso cambiar uno por uno los estados de los segmentos, para evitar este trabajo nos apoyaremos en funciones y sentencias de flujo.\nBiblioteca #  Nuestro anterior programa sirve para dos cosas, para nada y para la basura, no hay ninguna diferencia con respecto a conectar los pines del display directamente a Vcc, requerimos funcionalidad, que el microcontrolador haga lo adecuado para mostrar cualquier número indicado, con una interfaz del tipo\ndisplay7_showNumber(3); //Muestra el número 3 en el display de esta forma podemos realizar una secuencia de números\nint main(void) { while(1){ display7_showNumber(0); //delay  display7_showNumber(1); //delay  . . . display7_showNumber(9); //delay  } } El display mostrara los números del 0 al 9 en orden ascendente, nuestro objetivo entonces es definir la función display7_showNumber(short const number).\nAunque en este problema sencillo podemos programar la solución de forma monolítica(un solo fragmento de código), es de utilidad desarrollarlo en forma modular, como en la siguiente figura\nDe tal forma que podemos utilizarla dentro de nuestra aplicación con un simple include, pensar en forma modular tiene grandes ventajas y conforme crece el proyecto se vuelve la única forma sostenible de escribir código, la primer gran ventaja es la posibilidad de reutilizar código, seria absurdo escribir un controlador de 7 segmentos en cada proyecto nuevo, la segunda ventaja es la capacidad de extender el código ya escrito, la tercer gran ventaja es que el código es más \u0026ldquo;mantenible\u0026rdquo;, entre muchas otras que se irán comentando.\nPara nuestro propósito un módulo es un ente de software que está débilmente acoplado, autocontenido y es altamente cohesivo, dicho de otra forma, la función main no tiene conocimiento de las variables y funciones del módulo, salvo por un conjunto de funciones comúnmente llamadas interfaz. Una bonita interfaz para nuestro modulo puede ser\nvoid display7_init(void); void display7_showNumber(short const number); void display7_destroy(void); Elegir buenos nombres es una parte fundamental para que nuestro código sea de alta calidad, estoy seguro que al leer las funciones anteriores de inmediato formaste una idea de lo que hacen y a que pertenecen. Sin pensarlo hemos llegado a uno de los grandes dogmas de la programación y de la resolución de problemas en general,\nDivide el problema en problemas más pequeños\nNi tardos ni perezosos modificamos nuestro programa y agregamos el módulo,\n#include\u0026lt;avr/io.h\u0026gt; void display7_init(void); void display7_showNumber(short number); void display7_destroy(void); int main(void) { DDRB |= (1\u0026lt;\u0026lt;PB0); DDRD |= (1\u0026lt;\u0026lt;PD2)|(1\u0026lt;\u0026lt;PD3)|(1\u0026lt;\u0026lt;PD4)| (1\u0026lt;\u0026lt;PD5)|(1\u0026lt;\u0026lt;PD6)|(1\u0026lt;\u0026lt;PD7); PORTB |= (1\u0026lt;\u0026lt;PB0); PORTD |= (1\u0026lt;\u0026lt;PD2)|(1\u0026lt;\u0026lt;PD4)|(1\u0026lt;\u0026lt;PD5)|(1\u0026lt;\u0026lt;PD7); return 0; } void display7_init(void) { } void display7_showNumber(short number) { } void display7_destroy(void) { } Este código compila sin problemas pero no hace el trabajo requerido, al principio agregamos los prototipos del módulo, pero aun no los llamamos en la función main, tampoco hemos implementado dichas funciones. Antes de definir la interfaz, anteriormente indique que la función main no tiene conocimiento de las funciones y variables de nuestro módulo, si escribimos el código en el mismo fichero, el usuario de la función main tendrá a la vista todas las funciones y variables y probablemente tenga la tentación de usarlas, una buena idea para evitar que esto suceda es utilizar un par de archivos extra exclusivos para nuestro módulo.\nCrear la biblioteca #  No se si ya lo había mencionado pero odio el entorno de desarrollo de Arduino, en esta ocasión por la forma tan pobre de manejar ficheros. Continuando, vamos a mover nuestro módulo en un par de archivos, creamos dos ficheros cuyo nombre deje en claro que hay escrito en él, un buen nombre es display7,\n$touch display7.c $touch display7.h Ahora en nuestro entorno de desarrollo incluimos los dos ficheros, para ello vamos al menú Programa-\u0026gt;Añadir fichero y añadimos ambos ficheros, ambos aparecerán en nuestro entorno de desarrollo y podrán ser editados desde el mismo, movemos desde el fichero principal el módulo hacia los nuevos ficheros, los prototipos van en él .h y las definiciones al .c, de esta manera tenemos los tres ficheros siguientes\n//proyecto.ino #include\u0026lt;avr/io.h\u0026gt;int main(void) { DDRB |= (1\u0026lt;\u0026lt;PB0); DDRD |= (1\u0026lt;\u0026lt;PD2)|(1\u0026lt;\u0026lt;PD3)|(1\u0026lt;\u0026lt;PD4)| (1\u0026lt;\u0026lt;PD5)|(1\u0026lt;\u0026lt;PD6)|(1\u0026lt;\u0026lt;PD7); PORTB |= (1\u0026lt;\u0026lt;PB0); PORTD |= (1\u0026lt;\u0026lt;PD2)|(1\u0026lt;\u0026lt;PD4)|(1\u0026lt;\u0026lt;PD5)|(1\u0026lt;\u0026lt;PD7); return 0; } //display7.h void display7_init(void); void display7_showNumber(short number); void display7_destroy(void); //display7.c void display7_init(void) { } void display7_showNumber(short number) { } void display7_destroy(void) { } Nuevamente compilamos el programa y no nos dará ningún error, salvo el pequeño detalle de que no hace nada. Para poder acceder a la interfaz del módulo, es necesario incluirla en nuestro fichero principal, basta con agregar la directiva #include\u0026quot;display7.h\u0026quot; antes de la función main, de esta forma el módulo puede ser desarrollado de forma independiente y paralela al programa principal, modifiquemos nuestro .ino para usar la interfaz\n#include\u0026lt;utils/delay.h\u0026gt;#include\u0026#34;display7.h\u0026#34; int main(void) { display7_init(); while(1){ display7_showNumber(0); _delay_ms(1000); display7_showNumber(1); _delay_ms(1000); } } Pienso que el código se ve definitivamente más limpio y muestra claramente que se está haciendo, sin embargo si tratamos de compilar nos dará un error, similar a este\nundefined reference to `display7_init()\u0026#39; En pocas palabras el compilador (en realidad el linker) no encuentra las definiciones del módulo, las definiciones están en el fichero .c, como mencionamos en entradas anteriores, el entorno Arduino en realidad compila ficheros C++, pero como somos tercos y queremos programar en c debemos indicarle al compilador que nuestro ficheros no son C++, esto es muy sencillo, basta con añadir\nextern \u0026#34;C\u0026#34; { En el fichero .h donde están los prototipos y cerrar después del ultimo prototipo con un\n} El archivo .h queda\nextern \u0026#34;C\u0026#34; { void display7_init(void); void display7_showNumber(short const number); void display7_destroy(void); } Compilamos y esta vez no obtendremos ningún error. De esta forma el compilador hará lo adecuado para poder usar el módulo, la solución sirve para nuestros propósitos, sin embargo en el futuro, desarrollaremos nuestros programas con un compilador de \u0026ldquo;c\u0026rdquo;, el compilador no entenderá la línea extern \u0026ldquo;C\u0026rdquo; y nos dará un error, ¿cómo hacemos que el módulo funcione con el compilador de C y también con el de c++?, nuevamente la solución es sencilla, cuando usamos un compilador de C++, este pasa una definición, explicitamente\n#define __cplusplus lo anterior no sucede cuando compilamos con un compilador de C, aprovechando esta definición podemos usar la directiva\n#ifdef ALGO  //si ALGO fue definido, coloca estas lineas #endif Modificamos el fichero .h y escribimos\n//display7.h #ifdef __cplusplus extern \u0026#34;C\u0026#34; { #endif  void display7_init(void); void display7_showNumber(short const number); void display7_destroy(void); #ifdef __cplusplus } #endif El fichero está casi listo, funciona con ambos compiladores, sin embargo tiene un gran problema, ¿qué pasa si por error incluimos más de una vez nuestras interfaz?, la respuesta es que nos indicara un error de doble declaración, nuevamente nos apoyamos en la directiva #define, de la forma\n#ifndef MODULO #define MODULO  //Aquí las definiciones  #endif Significa, si no esta definido, define y coloca la interfaz, de lo contrario si ya esta definido no hagas nada, nuestra implementación queda así\n//display7.h #ifndef DISPLAY7_H #define DISPLAY7_H  #ifdef __cplusplus extern \u0026#34;C\u0026#34; { #endif  void display7_init(void); void display7_showNumber(short number); void display7_destroy(void); #ifdef __cplusplus } #endif #endif//DISPLAY7_H El fichero principal queda así\n//proyecto.ino //Necesario para _delay_ms(), frecuencia de nuestro arduino #define F_CPU 16000000UL #include\u0026lt;util/delay.h\u0026gt; //Nos permite usar delay_ms()#include\u0026#34;display7.h\u0026#34; int main(void) { display7_init(); while(1){ display7_showNumber(0); _delay_ms(1000); display7_showNumber(1); _delay_ms(1000); } } Las definiciones están en el fichero .c, debemos agregar la interfaz a este fichero también con la directiva #include\n//display7.c #include\u0026#34;display7.h\u0026#34;void display7_init(void) { } void display7_showNumber(short const number) { } void display7_destroy(void) { } En un entorno de desarrollo decente el fichero .c nos hubiera dado problemas pues no esta permitido compilar una implementación sin indicar a que interfaz pertenece, sin embargo el entorno de Arduino nos auto corrige el error, esto es otra cosa por lo que no me gusta Arduino, me oculta mis errores. Nuestro código ahora luce más modular en un diagrama luce así\nComo se ve en la imagen ahora proyecto.ino (función main) depende de la interfaz, mientras que display7.c la implementa, dicho de otra forma, proyecto.ino no sabe que hay en display7.c, el solo conoce lo que hay en display7.h, de esta manera podemos reutilizar el módulo en otros módulos, sin miedo a romper el código fuera de éste y muy importante sin tener que reescribir código extra.\nEstablecido lo anterior, ahora si nos toca implementar el módulo.\nImplementando la biblioteca #  Nuestro trabajo consiste en implementar las funciones del módulo contamos con un par de funciones, una para iniciar y otra para cerrar el módulo y una tercera para mostrar el número, la interfaz es muy sencilla y para nuestro propósito es más que suficiente. Algo que olvide mencionar y que es importante, la interfaz del módulo evoluciona, pues el desarrollo mismo provee realimentación importante.\nEs muy común que los módulos contengan dos funciones, init y close o create y destroy, el trabajo de estas dos funciones es llevar al módulo a un estado conocido y liberar los recursos respectivamente. Para el módulo display7 ambas funciones son simples.\nEn la función destroy, los recursos que se pueden liberar son los puertos y los pines, sin embargo en este caso es de poca utilidad, pues aunque liberemos los recursos nadie puede usarlos, esto no quiere decir que la función destroy siempre sera tan simple, en módulos más complejos tiene una importancia fundamental sobre todo la utilizar memoria dinámica.\nLa función init tiene la misión de establecer las condiciones adecuadas para que el resto del módulo pueda hacer su trabajo, modificara los registros de los puertos para establecerlos como salidas y con nivel bajo. Por ahora sabemos la correspondencia de los pines, pero ¿qué pasa si los encargados del hardware deciden cambiar alguno o todos los pines?, más adelante veremos este escenario.\nIniciemos tratando de configurar los primeros pines, corresponde PD2 y PD3, como salida y en bajo nivel\n//display7.c #include \u0026#34;display7.h\u0026#34;#include \u0026lt;avr/io.h\u0026gt; void display7_init(void) { short pin = PD2; DDRD |= (1\u0026lt;\u0026lt;pin); PORTD \u0026amp;= ~(1\u0026lt;\u0026lt;pin); pin = PD3; DDRD |= (1\u0026lt;\u0026lt;pin); PORTD \u0026amp;= ~(1\u0026lt;\u0026lt;pin); } void display7_destroy(void) { } void display7_showNumber(short number) { } Excelente funciona para los dos, pero las dos asignaciones son prácticamente idénticas, en la programación la duplicación de ideas debe evitarse pues es una fuente de errores. Se propone crear una función que nos ayude a evitar la repetición.\n//display7.c #include \u0026#34;display7.h\u0026#34;#include \u0026lt;avr/io.h\u0026gt; static void setPinOutputAndLow(short const pin); void display7_init(void) { setPinOutputAndLow(PD2); setPinOutputAndLow(PD3); } static void setPinOutputAndLow(short const pin) { DDRD |= (1\u0026lt;\u0026lt;pin); PORTD \u0026amp;= ~(1\u0026lt;\u0026lt;pin); } void display7_destroy(void) { } void display7_showNumber(short const number) { } Mucho mejor, ¿pero que pasa con el pin que pertenece al puerto B?, lo primero que requerimos es pasar el puerto como argumento de la función setPinOutputAndLow, pues los nemotécnicos Pxn no son más que enteros entre 0 y 7, lo segundo es establecer una relación entre los pines y los puertos, podemos hacer un arreglo bidimensional del tamaño de los pines y en cada entrada asignar pin y puerto,\n//display7.c #include \u0026#34;display7.h\u0026#34;#include \u0026lt;avr/io.h\u0026gt; short pines_display[7] = { 4, 5, 6, 11, 12, 13, 14 }; typedef enum{PORT_B, PORT_C, PORT_D}PORT; short const pines_table[28][2] = { {PC6, PORT_C}, /* pin 1*/ {PD0, PORT_D}, {PD1, PORT_D}, {PD2, PORT_D}, {PD3, PORT_D}, {PD4, PORT_D}, {-1, -1}, {-1, -1}, {PB6, PORT_B}, {PB7, PORT_B}, {PD5, PORT_D}, {PD6, PORT_D}, {PD7, PORT_D}, {PB0, PORT_B}, /*pin 14*/ {PB1, PORT_B}, /*pin 15*/ {PB2, PORT_B}, {PB3, PORT_B}, {PB4, PORT_B}, {PB5, PORT_B}, {-1, -1}, {-1, -1}, {-1, -1}, {PC0, PORT_C}, {PC1, PORT_C}, {PC2, PORT_C}, {PC3, PORT_C}, {PC4, PORT_C}, {PC5, PORT_C}, /*pin 28*/ }; static void setPinOutputAndLow(short const pin, PORT); void display7_init(void) { short pin = pines_table[3][0]; PORT port = pines_table[3][1]; setPinOutputAndLow(pin, port); pin = pines_table[4][0]; port = pines_table[4][1]; setPinOutputAndLow(pin, port); pin = pines_table[13][0]; port = pines_table[13][1]; setPinOutputAndLow(pin, port); } static void setPinOutputAndLow(short const pin, PORT port) { if(port == PORT_D){ DDRD |= (1\u0026lt;\u0026lt;pin); PORTD \u0026amp;= ~(1\u0026lt;\u0026lt;pin); }else if(port == PORT_B){ DDRB |= (1\u0026lt;\u0026lt;pin); PORTB \u0026amp;= ~(1\u0026lt;\u0026lt;pin); } } void display7_destroy(void) { } void display7_showNumber(short const number) { } Requerimos indicar los pines como salida y establecerlos a nivel bajo, solo tenemos una lista del numero de los pines, requerimos una funcionalidad para que nos indique a que puerto y pin corresponden, o mejor aun, desarrollar un nuevo módulo que se encargue de inicializar los pines, intentemos inicializar el primer pin\n//display7.c #include \u0026#34;display7.h\u0026#34;#include \u0026lt;avr/io.h\u0026gt; void display7_init(void) { DDRD |= (1\u0026lt;\u0026lt;pines_display[0]); PORTD |= (1\u0026lt;\u0026lt;pines_display[0]); } void display7_destroy(void) { } void display7_showNumber(short number) { } Hay modificaciones necesarias para el código anterior, lo comentare al final. La tarea de la función showNumber, es modificar un número decimal entre 0 y 9 de tal forma que se vea reflejado en el display, la siguiente es la implementación más sencilla de la cual haré algunos comentarios.\nvoid display7\\_showNumber(short number) { if(number == 0){ PORTB \u0026amp;= ~(1\u0026lt;\u0026lt;PB0); //LED G apagado PORTD |= (1\u0026lt;\u0026lt;PD2)|(1\u0026lt;\u0026lt;PD3)|(1\u0026lt;\u0026lt;PD4)| (1\u0026lt;\u0026lt;PD5)|(1\u0026lt;\u0026lt;PD6)|(1\u0026lt;\u0026lt;PD7); }else if(number == 1){ PORTB \u0026amp;= ~(1\u0026lt;\u0026lt;PB0); PORTD \u0026amp;= ~((1\u0026lt;\u0026lt;PD2)| (1\u0026lt;\u0026lt;PD5)|(1\u0026lt;\u0026lt;PD6)|(1\u0026lt;\u0026lt;PD7)); PORTD |= (1\u0026lt;\u0026lt;PD3)|(1\u0026lt;\u0026lt;PD4);//LED B y C encendido } //... hasta number == 9 } Un dogma muy importante en el mundo de la programación especifica que, la repetición de código es la mayor fuente de errores, con forme vamos agregando casos a la función showNumber vamos aumentando las posibilidades de equivocarnos, vale la pena suspender el desarrollo en aras de refactorizar lo que ya tenemos. Refactorizar es un gran tema que podría entenderse como pulir el código, como primer paso vamos a reescribir esos horribles operandos OR, sabemos que PB0 corresponde al led G por el esquemático, es más eficiente que el propio código exprese a donde pertenece,\n#define led_A (1\u0026lt;\u0026lt;PD2) #define led_B (1\u0026lt;\u0026lt;PD3) #define led_C (1\u0026lt;\u0026lt;PD4) #define led_D (1\u0026lt;\u0026lt;PD5) #define led_E (1\u0026lt;\u0026lt;PD6) #define led_F (1\u0026lt;\u0026lt;PD7) #define led_G (1\u0026lt;\u0026lt;PB0) de esta forma el código luce más expresivo\n//display7.c #include\u0026quot;display7.h\u0026quot; #include\u0026lt;avr/io.h\u0026gt; #define led\\_A (1\u0026lt;\u0026lt;PD2) #define led\\_B (1\u0026lt;\u0026lt;PD3) #define led\\_C (1\u0026lt;\u0026lt;PD4) #define led\\_D (1\u0026lt;\u0026lt;PD5) #define led\\_E (1\u0026lt;\u0026lt;PD6) #define led\\_F (1\u0026lt;\u0026lt;PD7) #define led\\_G (1\u0026lt;\u0026lt;PB2) void display7\\_init(void) { //pinout como salidas DDRB |= led\\_G; DDRD |= led\\_A|led\\_B|led\\_C| led\\_D|led\\_E|led\\_F; //pinout nivel bajo PORTB \u0026amp;= ~led\\_G; PORTD \u0026amp;= ~(led\\_A|led\\_B|led\\_C| led\\_D|led\\_E|led\\_F); } void display7\\_destroy(void) { //pinout como entradas DDRB \u0026amp;= ~led\\_G; DDRD \u0026amp;= ~(led\\_A|led\\_B|led\\_C| led\\_D|led\\_E|led\\_F); //pinout nivel bajo PORTB \u0026amp;= ~led\\_G; PORTD \u0026amp;= ~(led\\_A|led\\_B|led\\_C| led\\_D|led\\_E|led\\_F); } void display7\\_showNumber(short number) { if(number == 0){ PORTB \u0026amp;= ~led\\_G; //LED G apagado PORTD |= led\\_A|led\\_B|led\\_C| led\\_D|led\\_E|led\\_F; }else if(number == 1){ PORTB \u0026amp;= ~led\\_G; PORTD \u0026amp;= ~(led\\_A| led\\_D|led\\_E|led\\_F); PORTD |= led\\_B|led\\_C;//LED B y C encendido } //... hasta number == 9 } sin embargo se ve algo críptico y no muestra por si solo las intenciones de cada función. Haremos uso de funciones auxiliares, para ayudarnos a reducir el código repetido y ser más expresivo. De inmediato identificamos que la función init esta compuesta de dos partes, establecer los pines como salidas y establecer los niveles en bajo, podemos refactorizar utilizando dos funciones auxiliares de la forma\nvoid display7_init(void) { pinoutAsOutputs(); pinoutLowLevel(); } de esta forma es sencillo ver la intensión de la función init, para hacer valido el código colocamos ambas implementaciones antes de la función init\nstatic void pinoutAsOutputs(void) { //pinout como salidas DDRB |= led_G; DDRD |= led_A|led_B|led_C| led_D|led_E|led_F; } static void pinoutLowLevel(void) { //pinout nivel bajo PORTB \u0026amp;= ~led_G; PORTD \u0026amp;= ~(led_A|led_B|led_C| led_D|led_E|led_F); } void display7_init(void) { pinoutAsOutputs(); pinoutLowLevel(); } La palabra static(cuidado static tiene otros usos en otros contextos) sirve para indicar que las funciones únicamente pueden ser llamadas desde el mismo archivo, en este caso display7.c, en el futuro haré una entrada especifica sobre el alcance(scope).\nLogramos un poco de legibilidad, pero también importante es que evitamos la repetición de código, ¿en donde?, hay que mirar la función destroy, que puede ser refactorizada como\nvoid display7_destroy(void) { pinoutAsInputs(); pinoutLowLevel(); } pinoutLowLevel ya la implementamos, solo queda implementar pinoutAsInputs,\nstatic void pinoutAsOutputs(void) { //pinout como salidas DDRB |= led_G; DDRD |= led_A|led_B|led_C| led_D|led_E|led_F; } static pinoutAsInputs(void) { //pinout como entradas DDRB \u0026amp;= ~led_G; DDRD \u0026amp;= ~(led_A|led_B|led_C| led_D|led_E|led_F); } static void pinoutLowLevel(void) { //pinout nivel bajo PORTB \u0026amp;= ~led_G; PORTD \u0026amp;= ~(led_A|led_B|led_C| led_D|led_E|led_F); } void display7_init(void) { pinoutAsOutputs(); pinoutLowLevel(); } void display7_destroy(void) { pinoutAsInputs(); pinoutLowLevel(); } aun le falta al código, pero ya comienza a verse la forma. Más refactorización en la siguiente entrada.\n"}),a.add({id:21,href:'/posts/electronica-basica-display-de-7-segmentos/',title:"Electrónica básica.- Display de 7 segmentos.",section:"Posts",content:"Un display de 7 segmentos es un arreglo de leds distribuidos de una manera determinada, 8 leds en total, el display de 7 segmentos tiene el propósito de mostrar caracteres, usualmente números pero también puede mostrar letras.\nDisplay 7 segmentos\nel circuito equivalente es muy sencillo,\nCátodo común\nesta configuración es llamada cátodo común, puesto que el cátodo de todos los diodos está en corto circuito, es una buena característica pues tenemos un solo pin para todos los cátodos y podemos usar un solo cable para la conexión en lugar de ocho.\nÁnodo común\nLa configuración de ánodo común es similar a la de cátodo común salvo que los ánodos son los que están conectados en corto.\nEl dispositivo cuenta con nueve terminales (aveces diez, dos dedicadas para el común) una para el común y el resto para los ocho leds, para el cátodo común; la terminal común se conecta a tierra y los leds se encienden con voltaje alto, por el contrario para el ánodo común; la terminal común se conecta a Vcc y los leds se encienden con voltaje bajo.\nCada terminal es simplemente un led, por lo tanto para usarlo debemos agregar una resistencia para limitar la corriente, para nuestro atmega328p; resistencias para cada led de 330 $latex \\Omega$ o un poco mayores son suficientes. Cada led sera alimentado por 10[mA], si todos los leds se encienden al mismo tiempo, en total tenemos 80[mA], por lo que nuestro microcontrolador puede manejarlos sin problema, recordemos que la corriente máxima provista por el microcontrolador es de 200[mA] por todos los pines y 40[mA] en cada pin.\n"}),a.add({id:22,href:'/posts/electronica-basica-led-y-su-resistencia/',title:"Electrónica básica.- Led y su resistencia.",section:"Posts",content:"La ley de Ohm es una herramienta fundamental en la electrónica, en esta ocasión vamos a calcular la resistencia adecuada para que un diodo pueda operar de forma segura.\nAntes que nada definamos que es un diodo, sin entrar en detalles, un diodo es un dispositivo que permite el flujo de corriente en una sola dirección, cuenta con dos terminales, el ánodo y el cátodo, la regla es que si se conecta un voltaje alto al ánodo y uno bajo al cátodo, entonces fluye corriente, esta operación del diodo se conoce como polarización directa, si se invierten las conexiones se dice que el diodo esta polarizado en inversa y no fluye corriente. Un circuito simple se muestra en la figura,\nCircuito con Diodo\nAhora reemplazamos el diodo por su circuito equivalente,\nDiodo en Directa\nLa resistencia \u0026ldquo;interna\u0026rdquo; del diodo es muy pequeña por lo que podemos despreciarla, no debemos olvidar que este circuito es un modelo, el modelo funciona bien porque representa el comportamiento del diodo, no significa que dentro del diodo exista una resistencia y una fuente de voltaje, el valor de la fuente de voltaje varia de diodo a diodo, debemos verificar la hoja de datos para ver que voltaje tiene el diodo en cuestión, en algunos casos el voltaje es pequeño comparado con el resto de voltajes y simplemente se desprecia, modelandolo como un simple corto circuito.\nEn el caso de la polarización inversa el circuito es aun más simple\nDiodo en Inversa\nes un circuito abierto y no hay circulación de corriente.\nLed. #  Un led es un diodo que tiene la capacidad de emitir luz, el voltaje del diodo led es mayor que el voltaje de otro tipo de diodos, siendo el rojo el mas pequeño alrededor de 1.8 [V] y el azul el más grande alrededor de 4.8 [V], esto para leds de 5mm, sin embargo esto valores cambian según el tamaño del led, lo mejor es revisar en la hoja de datos del diodo en cuestión.\nUn led generalmente se acompaña de una resistencia conectada en serie, ¿para qué?, la respuesta es simple, para limitar su corriente, entendamos que es un corto circuito.\nPartiendo del circuito anterior, tenemos una fuente en serie con una resistencia, recordemos que la corriente es\n$latex i = \\frac{V}{R}$\nun corto se entiende como una conexión eléctrica de cero resistencia entre dos terminales. De esta forma los puntos A y B en el esquema están en corto, dicho de otra manera no hay resistencia entre ellos, esto implica que la corriente puede fluir totalmente entre estos dos puntos, Las terminales C y D no están en corto pues hay una resistencia entre ellas, ¿que pasaría si quitamos la resistencia?, pues tendríamos a las terminales C y D en corto y las consecuencias serian desastrosas. de la ley de Ohm tenemos $latex i = \\frac{V}{0} = \\infty$, las fuentes no pueden otorgar energía infinita, están diseñada para dar una corriente especifica, si se sobrepasa el limite se dañaran, es por eso que nunca debes juntar las terminales de una fuente.\nRegresando a nuestro diodo led, ¿qué pasaría si no colocamos una resistencia entre el diodo y la fuente?,\nDiodo en corto\ncomo dijimos la resistencia del modelo del diodo es muy pequeña por lo tanto la fuente y el diodo están prácticamente en corto, es decir fluirá una gran cantidad de corriente desde la fuente hacia el diodo, si se tiene suerte el diodo se quemara y se abrirá el circuito, si tienes un mal día tu fuente se dañara también, los diodos están fabricados para trabajar a un cierta corriente, en el caso de los diodos pequeños de 5mm la corriente suele estar alrededor de los 10[mA], en el caso de los diodos led de iluminación es común encontrar corrientes de 300[mA]. Calculemos rápidamente la resistencia de un led de 5mm rojo de 1.8[V] y 10[mA], que se desea conectar a una fuente de 5[V]. El circuito es el siguiente.\nde la ley de Ohm\n$latex V = Ri$\ndividiendo ambos lados entre la corriente\n$latex \\frac{V}{i} = R \\frac{i}{i} = R$\npara la resistencia R\n$latex R = \\frac{V_R}{i}$\ny la aplicamos a la resistencia R, recordemos que la corriente es un flujo, por lo tanto la corriente que pasa por la resistencia es la misma que pasa por el led, sabemos que el voltaje en la terminal positiva de la resistencia es 5V y el voltaje en la terminal negativa de la resistencia es 1.8V (estamos despreciando la resistencia interna del diodo), por lo tanto el voltaje que hay entre las terminales de la resistencia R es\n$latex V_R = (5 - 1.8) [V] = 3.2[V]$\nsabemos que la corriente de operación del led es de 10[mA], por lo tanto la resistencia adecuada debe ser\n$latex R = \\frac{3.2[V]}{10[mA]} = \\frac{3.2[V]}{0.010[A]} = 320 \\Omega$\nla resistencia comercial más cercana es de 330 Ohms, usaremos esa, la corriente disminuirá una cantidad marginal.\n¿Y si quiero añadir un led adicional a la misma fuente?, podemos añadir el led de forma paralela al led ya existen y recalcular la resistencia.\nLeds en paralelo\nEl cálculo es idéntico salvo que ahora la corriente es el doble, pues se requiere satisfacer la corriente de cada diodo $latex i = i_{D1} + i_{D2} = 20[mA]$, la resistencia necesaria es $latex R = 160 \\Omega$, el problema es que la resistencia disipara más potencia, que significa que se calentara más. Un método más recomendado es conectar una segunda rama (con diodo y resistencia incluidos), en paralelo a la fuente,\nDiodos con resistencia en paralelo\nde esta forma las dos resistencias son iguales a 330 Ohms. Podemos conectar tantas ramas en paralelo como deseemos, el limite es la capacidad de corriente de nuestra fuente, hay que recordar que el limite de un pin del atmega328p es de 40[mA].\n"}),a.add({id:23,href:'/posts/bloque-reutilizable-sin-titulo-2/',title:"res",section:"Posts",content:"La ley de Ohm es una herramienta fundamental en la electrónica, en esta ocasión vamos a calcular la resistencia adecuada para que un diodo pueda operar de forma segura.\nAntes que nada definamos que es un diodo, sin entrar en detalles, un diodo es un dispositivo que permite el flujo de corriente en una sola dirección, cuenta con dos terminales, el ánodo y cátodo, la regla es que si se conecta un voltaje alto al ánodo y uno bajo al cátodo, entonces fluye corriente, esta operación del diodo se conoce como polarización directa, si se invierten las conexiones se dice que el diodo esta polarizado en inversa y no fluye corriente. Un circuito simple se muestra en la figura,\nCircuito con Diodo\nAhora reemplazamos el diodo por su circuito equivalente,\nDiodo en Directa\nLa resistencia \u0026ldquo;interna\u0026rdquo; del diodo es muy pequeña por lo que podemos despreciarla, no debemos olvidar que este circuito es un modelo, este modelo funciona bien porque representa el comportamiento del diodo, no significa que dentro del diodo exista una resistencia y una fuente de voltaje, el valor de la fuente de voltaje varia de diodo a diodo, debemos verificar la hoja de datos para ver que voltaje tiene el diodo en cuestión, en algunos casos el voltaje es pequeño comparado con el resto de voltajes y simplemente se desprecia, modelando el diodo como un simple corto circuito.\nEn el caso de la polarización inversa el circuito es aun más simple\nDiodo en Inversa\nes un circuito y no hay circulación de corriente.\nLed. #  Un led es un diodo que tiene la capacidad de emitir luz, el voltaje del diodo led es mayor que el voltaje de otro tipo de diodos, siendo el rojo el mas pequeño alrededor de 1.8 [V] y el azul el más grande alrededor de 4.8 [V], esto para leds de 5mm, sin embargo esto valores cambian según el tamaño del led, lo mejor es revisar en la hoja de datos del diodo en cuestión.\nUn led generalmente se acompaña de una resistencia conectada en serie, ¿para qué?, la respuesta es simple, para limitar su corriente, entendamos que es un corto circuito.\nPartiendo del circuito anterior, tenemos una fuente en serie con una resistencia, recordemos que la corriente es\n$latex i = \\frac{V}{R}$\nun corto se entiende como una conexión eléctrica de cero resistencia entre dos terminales. De esta forma los puntos A y B en el esquema están en corto, dicho de otra manera no hay resistencia entre ellos, esto implica que la corriente puede fluir totalmente entre estos dos puntos, Las terminales C y D no están en corto pues hay una resistencia entre ellas, ¿que pasaría si quitamos la resistencia?, pues tendríamos a las terminales C y D en corto y las consecuencias serian desastrosas. de la ley de Ohm tenemos $latex i = \\frac{V}{0} = \\infty$, las fuentes no pueden otorgar energía infinita, están diseñada para dar una corriente establecida de corriente, si se sobrepasa el limite se dañaran, es por eso que nunca debes juntar las terminales de una fuente.\nRegresando a nuestro diodo led, ¿qué pasaría si no colocamos una resistencia entre el diodo y la fuente?,\nDiodo en corto\ncomo dijimos la resistencia del modelo del diodo es muy pequeña por lo tanto la fuente y el diodo están en corto, es decir fluirá una gran cantidad de corriente desde la fuente hacia el diodo, si se tiene suerte el diodo se quemara y se abrirá el circuito, si tienes un mal día tu fuente se dañara también, los diodos están fabricados para trabajar a un cierta corriente, en el caso de los diodos pequeños de 5mm la corriente suele estar alrededor de los 10[mA], en el caso de los diodos led de iluminación es común encontrar corrientes de 300[mA]. Calculemos rápidamente la resistencia de un led de 5mm rojo de 1.8[V] y 10[mA], que se desea conectar a una fuente de 5[V]. El circuito es el siguiente.\nde la ley de Ohm despejando la resistencia se tiene\n$latex R = \\frac{V_R}{i}$\ny la aplicamos a la resistencia R, recordemos que la corriente es un flujo, por lo tanto la corriente que pasa por la resistencia es la misma que pasa por el led, sabemos que el voltaje en la terminal positiva de la resistencia es 5V y el voltaje en la terminal negativa de la resistencia es 1.8V (estamos despreciando la resistencia interna del diodo), por lo tanto el voltaje que hay entre las terminales de la resistencia R es\n$latex V_R = (5 - 1.8) [V] = 3.2[V]$\nsabemos que la corriente de operación del led es de 10mA, por lo tanto la resistencia adecuada debe ser\n$latex R = \\frac{3.2[V]}{10[mA]} = \\frac{3.2[V]}{0.010[A]} = 320 \\Omega$\nla resistencia comercial más cercana es de 330 Ohms, usaremos esa, la corriente disminuirá una cantidad marginal.\n¿Y si quiero añadir un led adicional a la misma fuente?, podemos añadir el led de forma paralela al led ya existen y recalcular la resistencia.\nLeds en paralelo\nEl cálculo es idéntico salvo que ahora la corriente es el doble, pues se requiere satisfacer la corriente de cada diodo $latex i = i_{D1} + i_{D2} = 20[mA]$, la resistencia necesaria es $latex R = 160 \\Omega$, el problema es que la resistencia disipara más potencia, que significa que se calentara más. Un método más recomendado es conectar una segunda rama con diodo y resistencia incluidos en paralelo a la fuente,\nDiodos con resistencia en paralelo\nde esta forma las dos resistencias son iguales a 330 Ohms. Podemos conectar tantas ramas en paralelo que deseemos, el limite es la capacidad de corriente de nuestra fuente, hay que recordar que el limite de un pin del atmega328p es de 40[mA].\n"}),a.add({id:24,href:'/docs/avr/programando-avr-en-c-variables-y-tipos-caracteres/',title:"Programando Avr en C.- Variables y tipos, caracteres.",section:"Programación Avr en C.",content:"El tipo de variable char, sirve para guardar caracteres, generalmente el tamaño de este tipo es de 8 bits, por ello es común encontrar este tipo de dato en una gran cantidad de programas de 8 bits para almacenar resultados de operaciones con registros, sin embargo es preferible usar uint8_t, para un código consistente. El tipo char lo usaremos únicamente para lo que es, es decir para guardar un carácter, por ejemplo;\nchar letra = 'A'; char numero = '1'; //Ambas variables guardan caracteres, uint8\\_t resultado = numero + numero; //Esto dará resultados erróneos, pues estamos sumando dos //caracteres y nos dos números. Para representar una palabra utilizaremos arreglos de caracteres, un arreglo es un conjunto contiguo de variables, los arreglos serán analizados a detalle en otra entrada.\nEl tipo char puede almacenar los caracteres descritos por el código ASCII, incluidos los de control, por ejemplo el carácter nulo \u0026lsquo;\\0\u0026rsquo;, o el tabulador \u0026lsquo;\\t\u0026rsquo;, el uso de caracteres suele estar limitado a los dispositivos capaces de mostrarlos, como pantallas por ejemplo.\nAlgunas personas utilizan el puerto serial para enviar comandos por medio de caracteres, sin embargo es un método ineficiente, imagina que queremos enviar el número 200 desde un microcontrolador a una PC, podrías usar el puerto serial y enviar un \u0026lsquo;2\u0026rsquo;, \u0026lsquo;0\u0026rsquo; y \u0026lsquo;0\u0026rsquo;, cada uno es un carácter y tiene un tamaño de 8 bits, en total son 3x8 bits, sin embargo el número 200 puede almacenarse sin problemas en solo 8 bits, ahora supongamos que queremos enviar el número 2,000,000,000, enviarlo carácter por carácter requeriría 8x10 bits, 80 bits, cuando perfectamente ese número puede ser almacenado en un entero de 32 bits, cuando comentemos el periférico UART esto tomara sentido.\n"}),a.add({id:25,href:'/docs/avr/programando-avr-en-c-variables-y-tipos-enteros/',title:"Programando Avr en C.- Variables y tipos.- Enteros.",section:"Programación Avr en C.",content:"El lenguaje de programación C, es un lenguaje de tipo; tipado estático, esto quiere decir que nosotros debemos indicar el tipo de dato que guarda una variable. ¿Qué es una variable?, puede decirse que una variable es un espacio en memoria que guarda un valor determinado, y ¿qué es un tipo', en C los tipos de variables básicos (mejor llamados primitivos) son,\n Enteros, almacenan valores enteros, como: 1, 2, -100, 0b11111, 0x32, \u0026hellip; De punto Flotante, cantidades con decimales como: 1.111, 3.141598, -1.4142, \u0026hellip; Caracter. \u0026lsquo;a\u0026rsquo;, \u0026lsquo;y\u0026rsquo;, ' \u0026lsquo;, \u0026lsquo;\\n\u0026rsquo;, \u0026hellip; Boleanos, true, false.  Existen tipos adicionales pero son variantes de las anteriores, como dijimos para declarar una variable debemos especificar su tipo, esto se hace con la siguiente sintaxis,\ntipo nombre\\_de\\_variable; //Una variable entera llamado numero int numero; //Una variable de tipo carácter llamada letra char letra; //Una variable de tipo punto flotante llamada cantidad double cantidad; //Una variable boleana llamada condicion bool condicion; ¿Fácil no?, pero en la vida nada es fácil :D, pero si sencilla, existen modificadores que nos permiten agregar o mejor dicho establecer propiedades a las variables.\nSigned y Unsigned #  Por defecto las variables de tipo entero pueden guardar enteros positivos y negativos, a costa de utilizar un bit para guardar el signo, de manera que si declaramos una variable como unsigned (sin signo), podemos utilizar ese bit para guardar información adicional, pero perdemos la capacidad de almacenar números negativos.\n//Suponiendo que los enteros son binarios de 8 bits int numero1; //Puede guardar valores desde -128 a 127 //Por defecto las variables son de tipo signed signed int numero1; //Puede guardar valores desde -128 a 127 unsigned int numero2; //Puede guardar valores de 0 a 255 Al final la cantidad de información guardada no cambia, tan solo cambiamos la forma en como se interpreta, sin embargo el utilizar unsigned generalmente lleva a un camino lleno de dolor, pues es una fuente de errores aritméticos, así que utilizaremos este modificador en situaciones bien definidas. El resto de tipos de variables limitaremos el uso de unsigned a las variables de tipo entero(int).\nEl tamaño de los enteros, stdint.h #  En el ejemplo anterior asumimos que un entero guarda números de 8 bits, esto es poco probable, realmente a priori no sabemos que tamaño tiene un entero(el número de bits), el tamaño es determinado por el compilador y es dependiente de la arquitectura, muy probablemente un entero en Arduino sea de 16 bits pero en un cortex-m tal vez sera de 32, y una PC sea de 64 y puede variar entre compiladores en la misma plataforma, sería muy riesgoso asumir un tamaño por defecto, afortunadamente existe una biblioteca que nos permite declarar variables con el tamaño que nosotros indiquemos, basta con incluir la biblioteca,\n#include\u0026lt;stdint.h\u0026gt; es importante declarar las variables con un tamaño predeterminado cuando de operaciones con registros se trate, con aras de mejorar la portabilidad de nuestro código. ¿Como declaramos un entero con la anterior biblioteca?,\n#include\u0026lt;stdint.h\u0026gt; // Standard Int int8\\_t numero; //Variable entera de 8 bits //Podemos cambiar el 8 por 16, 32 o 64 siendo esto el //numero de bits uint8\\_t numero; //variable entera de 8 bits unsigned de esta forma nos aseguramos que la variable numero sera una variable entera de 8 bits en cualquier ambiente donde nuestro código se compile y ejecute, a manera de resumen\n8 bits pueden almacenar desde **\\-128 a 127** 16 bits pueden almacenar desde **\\-32768 a 32767** 32 bits pueden almacenar desde **\\-2147483648 a 2147483647** 64 bits pueden almacenar desde −9,223,372,036,854,775,808 a 9,223,372,036,854,775,807 nosotros evitaremos utilizar la declaración común en favor de la declaración provista por la biblioteca stdint.h cuando de manipulación de registros se trate.\n"}),a.add({id:26,href:'/docs/perifericos/gpio/perifericos-atmega328p-puertos-de-entrada-salida-de-proposito-general-gpio/',title:"Periféricos atmega328p.- Puertos de entrada/salida de propósito general (GPIO)",section:"GPIO",content:"Puertos de entrada/salida de propósito general. #  Cando pensamos en programar microcontroladores, lo que queremos es hacer que el mundo se mueva, controlar un motor, un relevador, una lampara, altavoz, etc. Para ello los microcontroladores cuentan con una serie de periféricos. A grandes rasgos un periférico puede definirse como: una interfaz que permite al microcontrolador comunicarse con el exterior, en esta entrada describiremos los puertos de entrada/salida de propósito general; GPIOx.\nSegún la hoja de datos el atmega328p tiene hasta 23 pines programables, cada uno con la posibilidad de ser programado individualmente, Arduino Uno tiene 20 pines disponibles, pues 2 están destinados al reloj y el otro está destinado al pin de reset.\nLos pines están agrupados en puertos, en el atmega328 contamos con tres puertos disponibles, PORTB, PORTC, PORTD, de manera genérica los llamamos PORTx, cada uno de estos puertos cuentan con tres registros asociados, DDRx, PORTx, PINx, donde \u0026ldquo;x\u0026rdquo; es el puerto(B, C, D), estos nueve registros nos permiten configurar y acceder a los valores de cada uno de los pines pertenecientes al microcontrolador.\nLos pines en el microcontrolador tienen un nombre del tipo Pxn, donde x es el puerto y n es él número de pin, el pin PB0 y el pin PD7, son el pin 0 y el pin 7 del puerto B y del puerto D respectivamente.\nConfigurar un Pin como Salida. #  El acceso a los pines individuales no es posible, estamos limitados a a operaciones que involucran 8 bits como mínimo, pues este es el tamaño del bus de datos y de los registros. Por lo tanto si requerimos escribir el estado del pin PB3, necesariamente debemos escribir todo el puerto B, desde PB0 hasta PB7 (el atmega328p no tiene disponibles todos lo pines PBn).\nSuponiendo que requerimos encender un led que esta conectado al pin PB4, podemos hacer una asignación al registro DDRB (Direction Data Register) como la siguiente\nDDRB = (1\u0026lt;\u0026lt;PB4); //En binario es igual a DDRB = 0b00010000; Esto efectivamente coloca al pin 4 como salida, sin embargo coloca al resto de los pines como entrada, para resolver este problema haremos uso del operador binario or. El operador or compara bit a bit y posición por posición con la regla,\n0 or 0 = 0 1 or 0 = 1 0 or 1 = 1 1 or 1 = 1 Por ejemplo, para los números binarios, 100 y 010, el resultado de hacer un or bit a bit es\nbit2 bit1 bit0 1 0 0 or or or 0 1 0 -------------- 1 1 0 Resultado Asumiendo que el registro DDRB contiene el valor 0000 0111, es decir los 3 primeros bits están configurados como salidas, requerimos hacer que el bit correspondiente a PB4 sea 1, sin modificar el resto, para ello usamos la sintaxis,\nDDRB = DDRB | (1\u0026lt;\u0026lt;PB4); El símbolo |, es el operador binario or, significa: or binario entre DDRB y el resultado de la operación (1\u0026lt;\u0026lt;PB4),\nDDRB = DDRB | (1\u0026lt;\u0026lt;PB4); //Es igual a DDRB = 0b00000111 | 0b00010000; //Ahora se hacer or, resulta DDRB = 0b00010111; //DDRB queda con el bit 5 en 1 y el resto sin modificar Configurar un Pin como Entrada. #  Para poder hacer acciones más complejas requerimos que nuestro microcontrolador pueda \u0026ldquo;sentir\u0026rdquo; el mundo, los pines de nuestro microcontrolador pueden configurarse para que se pueda interpretar el estado de un pin, establecido por un elemento externo (como un botón pulsador). Para ello también se utiliza el registro DDRx, pero en esta ocasión el pin a ser configurado se establece como un cero.\nEl operador binario and \u0026amp;, similar al operador or realiza la operación and bit a bit, con la siguiente regla,\n0 and 0 = 0 0 and 1 = 0 1 and 0 = 0 1 and 1 = 1 Por ejemplo en los siguientes números binarios el resultado es,\nbit2 bit1 bit0 1 0 0 and 0 1 0 -------------- 0 0 0 Otro operador (en este caso unario) importante es el complemento a uno ~, cambia el valor de 1 a 0 y de 0 a 1, por ejemplo:\n1010 ~ ----- 0101 Asumiendo que el registro DDRC contiene el número 010 0011, requerimos configurar el pin PC0 como entrada, asignar DDRC = 0 no es aceptable (colocaría todos los pines como entrada), en su lugar usaremos el siguiente código\nDDRC = DDRC \u0026amp; ~(1\u0026lt;\u0026lt;PC0); //Primero se realiza (1\u0026lt;\u0026lt;PC0), resulta DDRC = DDRC \u0026amp; ~0b00000001; //Ahora se aplica el operador complemento, resulta DDRC = DDRC \u0026amp; 0b11111110; //Operador And bit a bit, DDRC = 0b00100011 \u0026amp; 0b11111110; //Resulta DDRC = 0b00100010; De esta forma logramos establecer el pin requerido sin afectar el resto.\nEstablecer el estado cuando el pin es una salida. #  Cuando un pin es configurado como salida, puede entregar/recibir potencia, poquita, pero suficiente para mover al mundo, para ello se requiere establecer el estado del pin, asumiendo que tenemos conectado un led al pin PB4 y que dicho pin esta configurado como salida en el registro DDRB, entonces podemos establecer el estado del pin en el registro PORTB, donde un cero es nivel bajo(0 V) y un uno es nivel alto (5 V).\n//Led encendido PORTB = PORTB | (1\u0026lt;\u0026lt;PB4); //Led apagado PORTB = PORTB \u0026amp; ~(1\u0026lt;\u0026lt;PB4); Por supuesto lo mismo aplica para los otros puertos.\nResistencia de Pull up. #  ¿Qué pasa cuando escribimos los registros PORTx cuando DDRx es configurado como entrada?, la respuesta es que con un uno se conecta una resistencia interna llamada de Pull Up, mientras que con un cero se desconecta, la resistencia de pull up es de gran utilidad cuando se censan entradas, un pin configurado como entra, tiene la característica de ser sensible al ruido electromagnético del ambiente, cuando se activa la resistencia de pull up se produce una corriente que pasa por el pin, disminuyendo la sensibilidad al ruido y obligando una tensión en el pin en nivel alto (5 Volts).\nLeer el estado de un pin. #  Cuando requerimos leer el estado del pin, utilizamos el registro PINx, es un registro de 8 bits, contiene el estado de cada unos de los pines del puerto, Para censar al pin, debemos configurarlo como entrada en el registro DDRx.\nPara leer el estado del pin PC0, asumiendo que PC0 esta conectado a 5V y que PC0 esta configurado como entrada en DDRC (con un cero),\n//suponiendo que declaramos una variable adecuada llamada //entrada entrada = PINC \u0026amp; (1\u0026lt;\u0026lt;PC0); //Es igual a entrada = 0bxxxxxxx1 \u0026amp; 0b00000001; //donde las x pueden ser 0 o 1 //aplicando and bit a bit resulta en entrada = 0b00000001; //entrada es exactamente igual a entrada = 1; //si PC0 estuvera conectado a tierra, //entrada resultaría en entrada = 0bxxxxxxx0 \u0026amp; 0b00000001; //aplicando and bit a bit resulta en entrada =0b00000000; //o entrada = 0; Operadores de asignación. #  Para evitar verbosidad podemos usar operadores de asignación más complejos, por ahora presento dos adicionales, |= y \u0026amp;=, su utilidad es obvia\n//en lugar de PORTx = PORTx | (1\u0026lt;\u0026lt;Pxn); DDRx = DDRx \u0026amp; ~(1\u0026lt;\u0026lt;Pxn); //podemos usar PORTx |= 1\u0026lt;\u0026lt;Pxn; DDRx \u0026amp;= ~(1\u0026lt;\u0026lt;Pxn); //ambas expresiones producen resultados //identicos "}),a.add({id:27,href:'/posts/electronica-basica-voltaje-corriente-resistencia-y-ley-de-ohm/',title:"Electrónica Básica.- Voltaje, Corriente, resistencia y ley de Ohm.",section:"Posts",content:"Cuando la gente de computación escucha las palabras en el titulo de esta entrada, suele entrar en pánico y no es para menos, el análisis de circuitos eléctricos puede llegar a ser muy complejo; sin embargo la electrónica descansa sobre una ley simple, la ley de Ohm,\n$latex V = iR$\nla ley de Ohm relaciona el voltaje con la corriente y la resistencia; pero esto no nos dice nada si no entendemos estos términos, comencemos con el voltaje, también llamado tensión o potencial eléctrico, en la física,\nE_l voltaje se define como la cantidad de trabajo necesaria para mover una carga desde el infinito hasta un punto determinado_.\nAhora que ya sabes y entendiste claramente el voltaje pasemos con lo siguiente (es broma obviamente), la definición no nos sirve pues se aleja demasiado de la parte práctica, una forma más laxa y útil de interpretarlo es;\nEl voltaje es una fuente de energía eléctrica que impulsa a la corriente eléctrica a fluir a través de un circuito eléctrico.\nEsta definición no rigurosa pero nos es de gran utilidad, por la definición y por la ley de Ohm, su unidad de medida es el Volt [V], si el voltaje es muy grande la corriente que puede proveer la fuente es de mayor intensidad, por el contrario si el voltaje es negativo, \u0026ldquo;absorbe\u0026rdquo; corriente eléctrica.\n¿Pero qué es la corriente eléctrica?, pues no es más que un flujo de cargas eléctricas, flujo de electrones a través de un medio, usualmente un conductor, pero puede ser incluso a través del aire formándose un arco eléctrico cuando hay voltaje muy alto, su unidad de medida es el Ampere [A], se le representa con un símbolo \u0026ldquo;i\u0026rdquo; en el esquema a continuación, la dirección de la corriente va de voltaje alto a voltaje bajo; o si solo hay una fuente va de la terminal positiva a tierra (una forma común de referirse al voltaje o potencial 0[V]).\nDirección de la corriente\nUna resistencia es un elemento que se opone a el paso de la corriente, si colocamos en un circuito eléctrico un resistencia de 10 Ohms, la corriente que pasa por ella seria mucho mayor que si colocáramos una resistencia de 1000 Ohms.\nPor ejemplo, tenemos una fuente de 5V, una resistencia de 330 Ohms conectada entre sus terminales, ¿Qué corriente pasa por la resistencia?\nsabemos que $latex V = i R$, dividiendo ambos lados entre la resistencia\n$latex \\frac{V}{R} = \\frac{iR}{R}$\npor lo tanto, la corriente es\n$latex i = \\frac{V}{R}$\n$latex = \\frac{5}{330}=0.015 [A] = 15 [mA]$\n¿Por qué es importante conocer la corriente?, debido a que cada pin de nuestro microcontrolador tiene poca capacidad de entregar o recibir potencia, dicho de otra forma la corriente que sale de cada pin está limitada, para el atmega328p la corriente máxima de cada pin es de 40mA y la corriente entre todos los pines no debe ser superior a 200mA, sobrepasar este limite implica dañar el microcontrolador, para manejar corrientes grandes mayores a 10[mA] utilizaremos componentes externos.\n"}),a.add({id:28,href:'/posts/que-son-los-registros-en-un-microcontrolador/',title:"¿Qué son los registros en un microcontrolador?",section:"Posts",content:"Hemos hablado acerca de los registros en anteriores entradas, vamos a profundizar un poco en el tema.\nPara entender un registro, definamos que es un bit, la palabra tiene varias acepciones, para nuestro propósito un bit es la representación de un valor binario, este puede ser 1 o 0. Entonces un registro es sencillamente un conjunto de bits, en nuestro microcontrolador atmega328p, existen registros de 8bits, en otras arquitecturas como los cortex-m los registros son de 32 bits, algunos como el msp de texas instruments, tienen registros de 16 bits.\n¿Es mejor 32 que 8 bits?, no realmente, la diferencia radica en que un sistema de 32 bits requiere un bus de 32 bits, un bus podría definirse como un conjunto paralelo de cables que comunica los registros con algún otro elemento, en otras palabras un bus de 32 bits comunica mayor información por cada ciclo, a priori esto es bueno, sin embargo las instrucciones que también viajan por este bus, no necesariamente ocupan los 32 bits, esto deriva en programas más grandes para las arquitecturas de 32 bits. Hoy por hoy las arquitecturas de 32 bits son muy populares, siendo incluso más baratas y eficientes que sus contrapartes de 8 bits, la gran ventaja de los 8 bits radica en su facilidad y simpleza.\nSiguiendo con los registros, programar un microcontrolador se resume a modificar los registros, ya comentamos el registro DDRx, donde x es un puerto determinado (haremos una serie especifica sobre puertos), modificar dicho registro nos permite establecer el comportamiento de cada uno de los pines pertenecientes a dicho puerto. A lo largo de las entradas iremos revisando varios de los registros y explicaremos las implicaciones que se tienen al modificarlos. En realidad DDRx es un nemotécnico no un registro, cuando escribimos DDRB, realmente estamos escribiendo algo similar a *(0xfa020121029120), una vez que estudiemos los apuntadores detallaremos que es lo anterior, adelanto que el número entre paréntesis es la dirección del registro).\nEl tema de los registros tiene una gran exposición cuando se programa en ensamblador, el ensamblador es un lenguaje muy estimulante de aprender y el ensamblador de avr es muy limpio y sencillo, quizá en el futuro expliquemos un poco.\n"}),a.add({id:29,href:'/docs/avr/programando-avr-en-c-hola-mundo/',title:"Programando Avr en C.- Hola mundo",section:"Programación Avr en C.",content:"Antes de analizar el código Blink en C, explicaremos la estructura básica de un programa en C, el siguiente código muestra un programa mínimo\n#include\u0026lt;bibliotecas.h\u0026gt; int main(void) { tipo1 variable1; tipo\\_n variable\\_n; while(1){ hacer\\_cosas(var1, var2, varn); } return 0; } Al inicio de este listado tenemos una directiva del preprocesador, las directivas comienzan con un #, en este caso tenemos una directiva include, que le indica al compilador que copie el contenido del fichero bibliotecas.h en nuestro código, esto nos habilita a usar los objetos y funciones que hay dentro de bibliotecas.h, existen diferentes directivas que nos ayudaran a tener un código más limpio, es importante no subestimar al preprocesador, pues nos ayudara a hacer cosas que no pueden hacerse de otra forma.\nPosteriormente tenemos la función main, la función main es un ente importante, cuando el programa se ejecuta, la función main es llamada automáticamente, es decir el código dentro de las llaves se ejecutara linea por línea, lo que esté fuera de dicha función deberá ser llamado explícitamente para poder ejecutarse. Por definición la función main retorna un entero al finalizar y en el caso de microcontroladores no suele recibir argumentos por eso la palabra void(más adelante analizaremos la estructura de las funciones), una vez llamada la función main, se comienzan a ejecutar cada uno de las líneas dentro de ella en orden descendente, en este caso declaramos dos variables de cierto tipo, variable_1 y variable_n.\nPosteriormente hay una parte importante una estructura de flujo while, mantiene en ejecución el código que contiene mientras la condición que esta entre paréntesis se mantenga verdadera, un 1 siempre es verdadero por lo tanto esto se considera un ciclo infinito, es decir el código dentro del while se ejecutara constantemente, cuando llegue a la última línea saltara a la primera dentro sus llaves.\nFinalmente tenemos un retorno, como nuestro programa se queda \u0026ldquo;ciclado\u0026rdquo; dentro del while, nunca alcanzaremos esta línea, sin embargo es conveniente poner esta línea o el compilador nos dará un warning o advertencia.\nYa estamos un poco más familiarizados con la estructura del programa, ahora si analicemos el programa Blink,\n#include\u0026lt;avr/io.h\u0026gt; #include\u0026lt;util/delay.h\u0026gt; int main(void) { DDRB = 1 \u0026lt;\u0026lt; PB5; PORTB = 0; while(1){ PORTB = 1 \u0026lt;\u0026lt; PB5; \\_delay\\_ms(1000); PORTB = 0; \\_delay\\_ms(1000); } return 0; } Al inicio tenemos dos directivas include, la primera io.h, nos permite acceder a los registros de los puertos de nuestro microcontrolador, en este caso el puerto B, haré una entrada especifica para este tema, la segunda delay.h nos permite usar la función _delay_ms, que como deducirás nos permite crear un tiempo muerto.\nIniciamos con la función main y lo primero que tenemos es una asignación, te preguntaras que es DDRB, para entenderlo primero debo explicar que es un registro y lo explicare en una entrada dedicada, por ahora vamos a decir que DDRB es una variable a secas, a esta variable le asignamos el resultado de una operación 1\u0026laquo;PB5, el símbolo \u0026ldquo;\u0026laquo;\u0026rdquo; es un operado binario llamado left shift o corrimiento a la izquierda, indica que el número a la izquierda sera recorrido el número de veces que tiene a la derecha en binario, por ejemplo\n3 en binario es 0b0011 3\u0026lt;\u0026lt;1 es en binario 0b0011\u0026lt;\u0026lt;1 y da como resultado 0b0 0110 en decimal 6 3\u0026lt;\u0026lt;2 es en binario 0b0011\u0026lt;\u0026lt;2 y da como resultado 0b0 1100 en decimal 12 3\u0026lt;\u0026lt;3 es en binario 0b0011\u0026lt;\u0026lt;3 y da como resultado 0b1 1000 en decimal 24 en nuestro caso casi siempre, solo usaremos un 1 a la izquierda del operador, por lo tanto\n1 en binario es 0b1 1\u0026lt;\u0026lt;1 da como resultado 0b10 1\u0026lt;\u0026lt;2 da como resultado 0b100 1\u0026lt;\u0026lt;3 da como resultado 0b1000 1\u0026lt;\u0026lt;7 da como result. 0b10000000 //bit 76543210 //Posición 87654321 realmente no nos interesa el valor en decimal, lo que nos interesa es donde queda posicionado el 1, al final de la operación con 1\u0026laquo;2, el 1 queda posicionado en la tercera de derecha a izquierda, con 1\u0026laquo;7, queda en la octava de derecha a izquierda.\n¿Para que es esto?, DDRB es una \u0026ldquo;variable\u0026rdquo; que le indica al microcontrolador si el pin es de entrada o de salida, si el bit es cero el pin operara como entrada, de lo contrario opera como salida. DDRB contiene 8 bits y cada bit corresponde a un pin de nuestro microcontrolador, al inicio contiene el valor binario 0b0000 0000, cuando revisas la hoja de datos de tu microcontrolador te darás cuenta que los pines están rotulados con las leyendas PA0, PB0, PC0, PA1, etc, estos son los \u0026ldquo;nombres\u0026rdquo; de los pines, A,B,C, es el puerto al que pertenecen, por lo tanto el pin 5 del puerto B es PB5.\nEl pin PB5 esta conectado al led de nuestra tarjeta, hay que decirle a DDRB que ponga el pin 5 como salida, tan fácil como\nDDRB = 1\u0026lt;\u0026lt;PB5; //que es exactamente igual a DDRB = 0b00100000; //bit 76543210 Seguimos adelante y tenemos otra asignación, PORTB es otro registro, de igual forma asumiremos por ahora que es una variable, controla el estado del pin, el estado puede ser 0 para bajo o 1 para alto, en síntesis cuando el pin se configura en alto tendrá 5 volts y cuando se configura en bajo tendrá 0 volts, cuando necesitemos encender el led lo configuramos como alto con\nPORTB = 1\u0026lt;\u0026lt;PB5; //que es exactamente igual a PORTB = 0b00100000; ¿y si queremos ponerlo en bajo?, por ahora solo esto,\nPORTB = 0; //que es idéntico a PORTB = 0b00000000; esto tiene el pequeño inconveniente de poner el resto de pines en bajo y es muy probable que nuestro colega que este usándolos se enoje con nosotros, más adelante encontraremos una mejor manera.\nSiguiendo con el programa, entramos al ciclo infinito en donde la parte interesante es la función _delay_ms(), la función se explica por si misma, cuando se llama toma el control de la ejecución del programa y espera la cantidad de tiempo indicada en milisegundos, en este caso 1000 que equivale a un segundo.\nEl programa se queda en este bucle encendiendo y apagando el led cada dos segundos. La última línea no se ejecuta pues el ciclo no se interrumpe.\n"}),a.add({id:30,href:'/docs/workstation/arduino-basico-iii/',title:"Arduino Básico III",section:"Estación de trabajo.",content:"El siguiente paso obvio es analizar el programa Blink, sin embargo aquí no usaremos las bibliotecas de Arduino, usaremos código c para dispositivos AVR, entonces ¿para que tanto problema instalando la maquina virtual y Arduino?, simplemente porque utilizaremos la infraestructura ya hecha para nuestro propósito, abrimos el ejemplo Blink y reemplazamos el código por:\n#include\u0026lt;avr/io.h\u0026gt; #include\u0026lt;util/delay.h\u0026gt; int main(void) { DDRB = 1 \u0026lt;\u0026lt; PB5; PORTB = 0; while(1){ PORTB = 1 \u0026lt;\u0026lt; PB5; \\_delay\\_ms(1000); PORTB = 0; \\_delay\\_ms(1000); } return 0; } compilamos y subimos el código, el comportamiento es exactamente el mismo, pero el código es totalmente C y no C++, también evitamos el uso de las bibliotecas de Arduino en favor de las avr. Esto se nota de inmediato en el tamaño del programa, mientras que nuestro código usa 108 Bytes, el código de Arduino usa 924 Bytes, esto realmente no es determinante, en un proyecto complejo y grande usar una biblioteca u otra no tendrá gran impacto en el tamaño final. En realidad las Arduino usan como base las bibliotecas avr. Este pequeño hola mundo, da para comentar muchas cosas, no te preocupes por no entender el código, iremos desglosándolo en las siguientes entradas, también mostrare como liberarnos del IDE y por si fuera poco como liberarnos de la tarjeta.\n¿Por qué no usar unicamente Arduino para todo?, la verdad es que la única razón verdadera y valida es que no me gusta, otras razones menos validas son:\n Te limita a un puñado de microcontroladores.- Dentro de la familia de los microcontroladores avr apenas unos cuantos son utilizados para las tarjetas Arduino, existen ports a otras arquitecturas y micros, pero suelen ser limitadas, quizá lo que requieres realizar sea un programa muy sencillo, quizá no necesites toda la potencia que te ofrece un atmega328p, tal vez lo que necesites sea un attiny13(hiper barato y pequeño), por el contrario tal vez requieres algo muy rápido y potente como un amr cortex m7, o un risc V, no siempre tenemos a disponibilidad las bibliotecas de Arduino, pienso que es importante saber hacer tus propias bibliotecas y adaptarlas a un hardware cambiante. Te obliga a usar C++, aunque es posible enlazar bibliotecas de C++ en C, es un proceso un poco traumático, el problema de C++ es que es difícil de leer, el ejemplo clásico es el siguiente  struct unaEstructura primero = nuevoNumero(); struct unaEstructura segundo = nuevoNumero(); // C a = primero.num + segundo.num; //En C esto tiene un significado obvio // C++ a = primero + segundo; //A priori no sabemos que esta pasando aquí pudiera parecer una trivialidad, pero de igual forma sucede con varias otras situaciones, realmente es una cuestión de simple gusto, C++ es un lenguaje muy potente, si te sientes cómodo con él úsalo y explótalo al máximo.\n El entorno en general es precario. No se puede tener todo, si es fácil tiene que haber un costo, el costo es que no tenemos herramientas de debugging, el editor es horrible, no se adapta muy bien a los proyectos colaborativos, no hay control de versiones.  Sin embargo hay muchas cosas buenas que no se encuentran en ningún otro ambiente, por lo tanto debemos equilibrar nuestras preferencias en aras de obtener el mejor rendimiento y calidad.\n"}),a.add({id:31,href:'/posts/bloque-reutilizable-sin-titulo/',title:"save",section:"Posts",content:"El siguiente paso obvio es analizar el programa Blink, sin embargo aquí no usaremos las bibliotecas de Arduino, usaremos código c para dispositivos AVR, entonces ¿para que tanto problema instalando la maquina virtual y Arduino?, simplemente porque utilizaremos la infraestructura ya hecha para nuestro propósito, abrimos el ejemplo Blink y reemplazamos el código por:\n#include\u0026lt;avr/io.h\u0026gt; #include\u0026lt;util/delay.h\u0026gt; int main(void) { DDRB = 1 \u0026lt;\u0026lt; PB5; PORTB = 0; while(1){ PORTB |= 1 \u0026lt;\u0026lt; PB5; \\_delay\\_ms(1000); PORTB \u0026amp;= ~(1\u0026lt;\u0026lt;PB5); \\_delay\\_ms(1000); } } compilamos y subimos el código, el comportamiento es exactamente el mismo, pero el código es totalmente C y no C++, también evitamos el uso de las bibliotecas de Arduino en favor de las avr. Esto se nota de inmediato en el tamaño del programa, mientras que nuestro código usa 108 Bytes, el código de Arduino usa 924 Bytes, esto realmente no es determinante, en un proyecto complejo y grande usar una biblioteca u otra no tendrá gran impacto en el tamaño final. En realidad las Arduino usa como base las bibliotecas avr. Este pequeño hola mundo, da para comentar muchas cosas, no te preocupes por no entender el código iremos desglosándolo en las siguientes entradas, también mostrare como liberarnos del IDE y por si fuera poco como liberarnos de la tarjeta.\n¿Por qué no usar unicamente Arduino para todo?, la verdad es que la única razón verdadera y valida es que no me gusta, otras razones menos validas son:\n Te limita a un puñado de microcontroladores.- Dentro de la familia de los microcontroladores avr apenas unos cuantos son utilizados para las tarjetas Arduino, existen ports a otras arquitecturas y micros, pero suelen ser limitadas, quizá lo que requieres realizar sea un programa muy sencillo, quizá no necesites toda la potencia que te ofrece un atmega328p, tal vez lo que necesites sea un attiny13(hiper barato y pequeño), por el contrario tal vez requieres algo muy rápido y potente como un amr cortex m7, o un risc V, no siempre tenemos a disponibilidad las bibliotecas de Arduino, pienso que es importante saber hacer tus propias bibliotecas y adaptarlas a un hardware cambiante. Te obliga a usar C++, aunque es posible enlazar bibliotecas de C++ en C, es un proceso un poco traumático, el problema de C++ es que es muy difícil de leer, el ejemplo clásico es el siguiente  struct unaEstructura primero = nuevoNumero(); struct unaEstructura segundo = nuevoNumero(); // C a = primero.num + segundo.num; //En C esto tiene un significado obvio // C++ a = primero + segundo; //A priori no sabemos que esta pasando aquí pudiera parecer una trivialidad, pero de igual forma sucede con varias otras situaciones, realmente es una cuestión de simple gusto, C++ es un lenguaje muy potente, si te sientes cómodo con él úsalo y explótalo al máximo.\n El entorno en general es precario. No se puede tener todo, si es fácil tiene que haber un costo, el costo es que no tenemos herramientas de debugging, el editor es horrible, no se adapta muy bien a los proyectos colaborativos, no hay control de versiones.  Sin embargo hay muchas cosas buenas que no se encuentran en ningún otro ambiente, por lo tanto debemos equilibrar nuestras preferencias en aras de obtener el mejor rendimiento y calidad.\n"}),a.add({id:32,href:'/docs/workstation/arduino-basico-ii-hola-mundo/',title:"Arduino Básico II.- Hola Mundo",section:"Estación de trabajo.",content:"Prometo que ahora si comenzamos. :D\nConectamos nuestro Arduino a nuestra PC por medio del cable USB, si estas utilizando Virtual Box, es necesario que le des permiso al \u0026ldquo;invitado\u0026rdquo; para que use el puerto USB, esto se hace en el menú de Virtual Box, devices-\u0026gt;USB-\u0026gt; dispositivo correspondiente a Arduino(probablemente FTDI). Para verificar que nuestro Arduino esta conectado y lo reconoce el sistema, abrimos una terminal y tecleamos\n[eleckia@tuxin-lp ~]$ dmesg si el dispositivo esta conectado obtendremos una salida similar a esta\n[26227.988155] usb 2-1: new full-speed USB device number 3 using ohci-pci [26228.164271] usb 2-1: New USB device found, idVendor=2341, idProduct=0043, bcdDevice= 0.01 [26228.164279] usb 2-1: New USB device strings: Mfr=1, Product=2, SerialNumber=220 [26228.164284] usb 2-1: Manufacturer: Arduino (www.arduino.cc) [26228.164287] usb 2-1: SerialNumber: 7553334343635121A191 [26228.282966] cdc_acm 2-1:1.0: ttyACM0: USB ACM device [26228.287986] usbcore: registered new interface driver cdc_acm [26228.287989] cdc_acm: USB Abstract Control Model driver for USB modems and ISDN adapters Esto implica que nuestro Arduino esta conectado y la PC lo reconoce como un dispositivo ACM, ahora abrimos el IDE de Arduino, la primera vez que lo abrimos nos aparecerá algo como esto. (Si no aparece la salida anterior, probablemente no seleccionaste el dispositivo correcto en virtual box, prueba con otro.)\n   hacemos click en herramientas-\u0026gt;Puerto y seleccionamos el puerto al que este conectado el Arduino, probablemente solo haya uno disponible, en mi caso /dev/ttyACM0, en el caso de que no apareciera ningún puerto disponible, lo más probable es que te falte agregar tu usuario a los grupos lock y dialout simplemente,\n[eleckia@tuxin-lp ~]$ sudo gpasswd -a $USER lock [eleckia@tuxin-lp ~]$ sudo gpasswd -a $USER dialout debes salir de la sesión o en su defecto reiniciar tu sistema.\nContinuamos, el \u0026ldquo;Hola Mundo\u0026rdquo; es un programa tradicional en el mundo de la programación, consiste en mostrar la frase \u0026ldquo;Hola mundo\u0026rdquo; en la pantalla, traducida a los sistemas embebidos consiste en hacer parpadear un led. El entorno de desarrollo trae el código ya escrito, vamos a Archivo-\u0026gt;Ejemplos-\u0026gt;Basic-\u0026gt;Blink nos abrirá una ventana con el siguiente código\n// the setup function runs once when you press reset or power the board void setup() { // initialize digital pin LED\\_BUILTIN as an output. pinMode(LED\\_BUILTIN, OUTPUT); } // the loop function runs over and over again forever void loop() { digitalWrite(LED\\_BUILTIN, HIGH); // turn the LED on (HIGH is the voltage level) delay(1000); // wait for a second digitalWrite(LED\\_BUILTIN, LOW); // turn the LED off by making the voltage LOW delay(1000); // wait for a second } Sin modificar nada, vamos a subir este programa a la tarjeta, tan solo hacemos click en el icono de la palomita para compilar y después en el icono de la flecha para subir, o con las teclas ctrl+R y ctrl+U respectivamente. Si todo esta correcto veremos que el led de nuestro Arduino comienza a parpadear cada segundo aproximadamente.\n"}),a.add({id:33,href:'/docs/workstation/arduino-basico-i/',title:"Arduino Básico I.",section:"Estación de trabajo.",content:"Comenzamos formalmente nuestro estudio, como se menciono anteriormente, Arduino se compone tanto de software como de hardware, miremos un poco el hardware.\nEl Arduino Uno (placa de desarrollo), cuenta con un puerto usb, por el que se alimenta la placa; enviamos y recibimos datos, este puerto esta conectado a un circuito integrado que no es más que un convertidor serial-usb, al mismo tiempo este convertidor se conecta a unos pines específicos del microcontrolador. Lo importante a destacar es que esta conexión ya esta hecha y es perfectamente funcional, sino fuera así tendríamos que diseñar un circuito para poder conectar el microcontrolador con la PC, esta es sin duda la gran característica que dio paso al éxito, una plataforma lista para usarse sin necesidad de componentes adicionales.\nEl convertidor serial varia dependiendo de la versión de tu tarjeta, pero su comportamiento es similar en todas las versiones, por ahora nos enfocamos en conocer el microcontrolador,\nEl atmega328p es un microcontrolador RISC de 8 bits, no entraremos en detalles de la arquitectura pero si en sus características, quizá el parámetro más importante es la capacidad de memoria con la que cuenta, la asombrosa cantidad de 32KB de flash o memoria de programa y 2KB de ram, teniendo en cuenta que en este momento contamos con PCs regularmente de 8GB de ram y mayores de 1TB de almacenamiento, la memoria del atmega328p parecería poco, sin embargo se pueden hacer muchas cosas con ella y cuando digo muchas es muchas, adicionalmente cuenta con 1KB de memoria eeprom, en la cual podemos guardar datos y evitar que se pierdan cuando se corta la alimentación.\nOtro parámetro importante es la frecuencia a la que trabaja, siendo hasta 20MHz el máximo posible, internamente cuenta con un oscilador que puede ser configurado hasta 8MHz, si queremos frecuencias mayores podemos conseguirlas conectado un oscilador externo, usualmente un reloj de cuarzo, la regla es que a mayor frecuencia mayor capacidad de procesamiento, pero mayor gasto de energía. En el caso del Arduino(tarjeta), tiene un reloj de 16MHz ya conectado, por lo que el entorno esta desarrollado con este reloj en mente.\nCuenta con 23 pines programables en la versión DIP y hasta 32 en la versión de montaje superficial.\nlos periféricos con los que cuenta\n Tiimer con output compare ADC USART SPI I2C Y varias fuentes de interrupciones  describiré con mucho detalle los periféricos en posteriores entradas.\nAunque suene trillado, este es el corazón de Arduino. Mi objetivo es exponer al microcontrolador per se más que al ambiente Arduino en general.\nAdicionalmente la tarjeta cuenta con un par de hileras de pines donde podemos conectar componentes externos, un jack de alimentación por el cual podemos conectar hasta 9V, recomiendo no conectar USB y jack al mismo tiempo, finalmente un LED conectado al pin 13.\n"}),a.add({id:34,href:'/docs/workstation/estacion-de-trabajo-iv/',title:"Estación de trabajo IV",section:"Estación de trabajo.",content:"Finalizamos esta serie de post iniciales con una lista de materiales recomendada, en ebay existen una gran variedad de paquetes donde se incluyen Arduinos, resistencias, capacitores, transistores y algunos sensores, basta con ir a ebay o mercadolibre y buscar kit Arduino, adquirir uno de ellos es un buen comienzo, personalmente recomiendo,\nhttps://www.ebay.com/itm/UNO-R3-Updated-version-of-the-RFID-Starter-Kit-LCD-learn-Suite-1602-for-Arduino/201644819283?hash=item2ef2f7c353:g:UroAAOSwIgNXrjMk\nigualmente puedes adquirir kits de resistencias, capacitores y leds, además de jumpers, cables y un par de atmega328p DIP adicionales.\nCon esto podemos comenzar nuestro estudio, más adelante requeriremos más componentes, pero se mencionarán con forme se requieran.\n"}),a.add({id:35,href:'/docs/workstation/estacion-de-trabajo-iii/',title:"Estación de trabajo III",section:"Estación de trabajo.",content:"Ya casi estamos listos, damos click en Actividades y abrimos una terminal, la terminal puede ser intimidante, pero creeme una vez te acostumbres a ella la amaras.\nEn los sistemas linux tenemos diferentes tipos de usuarios cada uno de ellos con diferentes privilegios, el usuario con más privilegios es el usuario root, puede hacer y deshacer el sistema, nuestro usuario por defecto tiene pocos privilegios para evitar que el usuario pueda romper el sistema por accidente. Al abrir la terminal tendremos algo similar a esto\n[eleckia@tuxin-lp ~]$ donde eleckia es el nombre de usuario que se eligió, y tuxin-lp es el nombre que se le dio a la pc, delante del signo $, podemos escribir.\nDNF es el manejador de paquetes de Fedora, es una herramienta que nos permite actualizar, instalar y remover los programas y/o bibliotecas instaladas en nuestro sistema, para utilizarlo simplemente tecleamos\n[eleckia@tuxin-lp ~]$ dnf nos desplegara una enorme lista de las opciones disponibles para este comando, el que nos interesa por ahora es update, esta opción nos actualiza todos los paquetes a la última versión disponible, tecleamos\n[eleckia@tuxin-lp ~]$ dnf update Error: Este comando debe ejecutarse como usuario root. el error nos indica que requerimos privilegios altos, la forma de escapar de la tiranía el usuario root, es anteponer la palabra sudo, es decir\n[eleckia@tuxin-lp ~]$ sudo dnf update nos pedirá introducir la contraseña que creamos al iniciar Fedora por primera vez, la introducimos y nos desplegará la lista de actualizaciones disponibles, nos pedirá confirmación a lo que responderemos s. La primera vez que actualicemos, habrá muchas actualizaciones, por lo que se tardara un poco, al terminar de actualizar, reiniciaremos el sistema y abriremos nuevamente una terminal, una vez hecho esto instalaremos Arduino por fin. Para instalarlo tan fácil como escribir lo siguiente:\n[eleckia@tuxin-lp ~]$ sudo dnf install arduino terminada la descarga e instalación, ya tenemos disponible el software Arduino, hacemos click en actividades y lo ejecutamos, nos indicara que debemos agregar nuestro usuario a los grupos dialout y lock, le decimos que si e introducimos la contraseña del sistema, tenemos finalmente todo listo para comenzar a programar, tan solo nos falta conectar nuestro Arduino a un puerto usb.\nAnteriormente mencione que trabajaremos con Arduino uno, sin embargo debo confesar que cualquier Arduino de 8 bits es valido, de hecho ni siquiera es necesario instalar Fedora, puedes instalar Arduino en casi cualquier sistema operativo, la razón de instalar Fedora es que nos ofrece todas las herramientas de manera simple e inmediata, al estar dentro de una máquina virtual no debemos preocuparnos de dañar el sistema accidentalmente, yo haré todo desde Fedora, por que es mi sistema instalado, pero sientete libre de utilizar lo que más te acomode, eso si, si tienes algún problema con tu sistema no podre ayudarte puesto que yo no lo uso (windows). Lo mismo va para la tarjeta Arduino que utilices, funciona cualquiera, pero los registros de cada microcontrolador varian mucho, sobre todo de una arquitectura a otra, los microcontroladores de 8 bits no tiene nada que ver con los micros de 32 o 16 bits.\nNo es de mi interés centrarme en Arduino, pero es la opción de aprendizaje más adecuada y sería tonto no empezar con ella.\nLos lugares más comunes para adquirir la tarjeta es ebay, amazon y mercadolibre, es tu elección, también requerimos algunos dispositivos como leds, resistencias, transistores, capacitores, etc, en el siguiente post daremos algunos detalles adicionales.\n"}),a.add({id:36,href:'/docs/workstation/estacion-de-trabajo-ii/',title:"Estación de trabajo II",section:"Estación de trabajo.",content:"En este post instalaremos Fedora en la maquina virtual.\nAbrimos VirtualBox y seleccionamos la maquina virtual Fedora que creamos anteriormente, ahora damos click en Configuración, se nos abrirá una nueva ventana, seleccionamos Almacenamiento y en controlador IDE, seleccionamos Vació, a la derecha de unidad óptica damos click en el icono de un disco azul y seleccionamos el .iso de Fedora que descargamos anteriormente, finalmente damos click en aceptar.\nSi tienes anfitrión linux, ahí mismo en configuración seleccionamos Pantalla y cambiamos Controlador Gráfico a VBoxVGA y aumenta la memoria de video a por lo menos 64MB.\nNuevamente en Configuración, ahora seleccionamos Sistema y en la pestaña Procesador, seleccionamos el número de procesadores que tenemos, damos click en aceptar.\nNuestra maquina virtual, esta lista para arrancar y ya tiene el \u0026ldquo;disco\u0026rdquo; de instalación insertado, procedemos a iniciarla con el icono Iniciar.\nArrancamos y la primer pantalla de selección nos da tres opciones, seleccionamos la primera, Start Fedora, cuidado por defecto esta seleccionada la segunda opción.\nEsperamos a que el sistema inicie y tenemos una versión live de Fedora funcionando,\nGnome en Fedora\nEsta versión de Fedora es totalmente funcional, podemos jugar con ella, revisar los programas y menus, cambiar la resolución, etc, sabedores de que los cambios que hagamos no se guardaran, cuando estemos listos damos click en Install to Hard Drive. Se abrirá el asistente de instalación Anaconda (puede que tarde unos minutos), aquí elegimos el idioma y la región y damos click en continuar,\nAnaconda\nseleccionamos nuestra distribución de teclado(probablemente español latinoamericano) y la zona horaria, click en Destino de la Instalación, sin modificar nada damos click en Hecho en la esquina superior izquierda y comenzamos la instalación.\nComenzar Instalación\nEsperamos unos minutos a que termine la instalación y damos click en salir.\nFinalizado\nApagamos la maquina virtual y removemos la imagen .iso de Fedora.\nIniciamos nuevamente la maquina virtual esta vez iniciara Fedora instalado, todo lo que hagamos ahora si se guardara, nos dará la bienvenida un asistente de configuración donde nos pedirá algunos datos, de ellos lo importante es el usuario y la contraseña, los cuales debemos recordar o en su defecto anotar. Una vez ingresados nuestro sistema estará listo para poder instalar Arduino.\nFedora\nContinuaremos con la instalación de Arduino en el siguiente post.\n"}),a.add({id:37,href:'/docs/workstation/estacion-de-trabajo-i/',title:"Estación de trabajo I",section:"Estación de trabajo.",content:"No es obligatorio instalar Fedora, pero todos los ejemplos se harán desde este sistema operativo, eres libre de adaptar lo que aquí se mencione a tus circunstancias.\nPara poder trabajar a gusto es necesario disponer de un conjunto de herramientas adecuado, dejando de lado el tipo de computadora con la que se cuenta, lo importante es el sistema operativo, como se menciono en el post anterior utilizaremos software libre, por lo que nuestro sistema operativo sera linux, concretamente Fedora, esta distribución cuenta con los paquetes necesarios para nuestros propósitos, así que si utilizas algo diferente comienza borrado tu disco duro e instala Fedora (esto es broma obviamente).\nLa manera más sencilla de comenzar en este mundo (y la que seguiremos aquí) es con linux + arduino, hablemos rápida y brevemente de ellos.\nLinux es una pieza de software que funciona como interfaz entre el hardware de una computadora (memoria, procesador, periféricos, etc), en pocas palabras y de manera muy general, linux se encarga de administrar el hardware de una PC, por otro lado existe software (GNU) que se comunica con linux para formar un sistema operativo, de ahí surgen los sistemas GNU/Linux, a grandes rasgos el software GNU se encarga de administrar el sistema, enviándole instrucciones a Linux (comúnmente llamado kernel o núcleo) y este último las ejecuta en el hardware. Para el que este interesado en entender un poco más sobre el origen y filosofía de GNU/linux y el software libre, les recomiendo ver el documental \u0026ldquo;Código linux\u0026rdquo;, disponible en youtube en español. Compañías aprovechan este conjunto de software para crear distribuciones, en nuestro caso trabajaremos con la distribución Fedora, patrocinada por Red Hat, disponible para su descarga gratuitamente.\nArduino es una plataforma de desarrollo, contiene tanto software como hardware, sera común referirnos de manera indistinta al software o hardware con la palabra Arduino, con respecto al hardware hay muchas versiones, siendo el \u0026ldquo;Arduino uno\u0026rdquo; el más común y el que utilizaremos, este Arduino cuenta con un microcontrolador atmega328p, es un microcontrolador de la empresa Microchip, anteriormente le pertenecía a Atmel, pero fue comprada por la anterior mencionada, el microcontrolador es de 8 bits y contiene numerosos periféricos. Arduino es software libre pero también hardware libre, esto implica que los clones funcionen de manera idéntica a el hardware original, aunque si puedes comprarlo original siempre es bueno apoyar a los creadores. En la parte de software Arduino cuenta con su propio entorno de desarrollo (aunque a mi me parece horrible) y cuenta con miles de bibliotecas listas para ser usadas en nuestros proyectos.\nLo que requerimos:\n-Instalar Fedora\n-Adquirir un Arduino\n-Instalar Arduino dentro de Fedora\nComencemos instalando Fedora, como mencionamos Fedora es un sistema operativo, por lo tanto requerimos instalarlo en nuestra PC, podemos instalar junto a nuestro sistema operativo actual, podemos reemplazar nuestro sistema operativo actual por Fedora o si ya utilizamos Fedora como sistema operativo principal no hay necesidad de reinstalarlo, la última opción es instalarlo en una maquina virtual, si eres usuario windows probablemente esta opción es la más adecuada para ti.\nUna maquina virtual es un entorno que permite ejecutar un sistema operativo adicional sobre uno ya en ejecución, el sistema adicional se conoce como \u0026ldquo;huesped\u0026rdquo;(guess) y el que ya esta en ejecución se le denomina \u0026ldquo;anfitrión\u0026rdquo;(host), de esta manera podemos instalar Fedora sin la necesidad de modificar nuestro sistema operativo actual.\nProcedemos a instalar la maquina virtual, para ello visitamos el enlace https://www.virtualbox.org/\ny descargamos la versión más reciente para nuestro sistema operativo anfitrion(probablemente windows), no entrare en detalles sobre como instalar virtual box puesto que cada sistema es diferente, pero confió en que sabes como instalar programas en tu sistema, para instalarlo en windows doble click sobre el ejecutable descargado, si eres usuario linux seguramente viene en los repositorios oficiales de tu distribución.\nAhora descargaremos Fedora, accedemos al enlace\nhttps://getfedora.org/es/\nexisten varias ediciones, elegimos Workstation y la descargamos, la descarga es una imagen .iso de alrededor de 2GB, una vez descargado procedemos a instalar.\nAbrimos Virtualbox y seleccionamos \u0026ldquo;nueva\u0026rdquo;\nSe abrirá una nueva ventana escribimos \u0026ldquo;Fedora\u0026rdquo; en nombre, carpeta la dejamos por defecto, seleccionamos, tipo \u0026ldquo;Linux\u0026rdquo; y Versión \u0026ldquo;Fedora (64-bit)\u0026rdquo;, click en siguiente.\nAhora nos pide configurar la memoria, aqui aparece un control de deslizamiento, selecciona por lo menos 2GB y da click en siguiente.\nAhora nos pide configurar un nuevo disco duro, seleccionamos \u0026ldquo;Crear un disco virtual Ahora\u0026rdquo; y damos click en siguiente.\nTipo de archivo de disco duro, VDI, siguiente.\nAlmacenamiento en unidad de disco duro física, Reservado dinámicamente, siguiente.\nUbicación del archivo y tamaño, dejamos la ubicación por defecto y seleccionamos un tamaño de 20GB, siguiente.\nHemos finalizado la creación de la maquina virtual, procedemos a instalar Fedora en el siguiente post.\n"}),a.add({id:38,href:'/posts/about/',title:"About",section:"Posts",content:"This is an example of a page. Unlike posts, which are displayed on your blog’s front page in the order they’re published, pages are better suited for more timeless content that you want to be easily accessible, like your About or Contact information. Click the Edit link to make changes to this page or add another page.\n"})})()