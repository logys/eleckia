'use strict';(function(){const b={cache:!0};b.doc={id:'id',field:['title','content'],store:['title','href','section']};const a=FlexSearch.create('balance',b);window.bookSearchIndex=a,a.add({id:0,href:'/docs/workstation/',title:"Estaci贸n de trabajo.",section:"Docs",content:"Hay que trabajar, hay que aprender, hay que comer, hay que descansar y tambi茅n hay que jugar, esas son las bases del entrenamiento del maestro Roshi para tener una buena condici贸n. #  Kame Senin.\n"}),a.add({id:1,href:'/docs/avr/',title:"Programaci贸n Avr en C.",section:"Docs",content:"Una l铆nea de othello sobre un bebedor, ahora un hombre sensible; por el alcohol se convierte en bestia, eso lo explica todo. #  Barney G贸mez.\nEn esta secci贸n introduzco algunos conceptos de C que considero necesarios para programar.\n"}),a.add({id:2,href:'/docs/avr/programando-avr-en-c-arreglos/',title:"Programando Avr en C. Arreglos.",section:"Programaci贸n Avr en C.",content:"Los arreglos o arrays son elementos que permiten hacer colecciones de datos del tipo indicado, su uso es amplio en pr谩cticamente todos los lenguajes de programaci贸n, en C los arreglos se declaran con la siguiente sintaxis,\ntipo_dato nombre_array[TAMAO]; Por ejemplo para declarar un arreglo de 5 enteros llamado horas:\nint horas[5]; Para declarar un arreglo de 3 boleanos llamado respuestas:\n#include\u0026lt;stdbool.h\u0026gt; bool respuestas[3]; Los arreglos pueden ser de cualquier tipo de dato. El n煤mero entre corchetes (par茅ntesis cuadrados) indica la cantidad de elementos que puede almacenar, en el caso del arreglo horas, este puede almacenar hasta 5 enteros, la forma de asignar los valores es la siguiente:\nint horas[5] = {1, 2, 1, 2, 3}; //o tambi茅n int horas[5]; horas[0] = 1; horas[1] = 2; horas[2] = 1; horas[3] = 2; horas[4] = 3; Ambas asignaciones resultaran en los mismos enteros para el arreglo, n贸tese que cuando asignamos los valores, la primera posici贸n es cero y no uno, esto implica que la 煤ltima posici贸n sea cuatro y no cinco, si asign谩ramos horas[5] = 4; obtendr铆amos un error en tiempo de ejecuci贸n, este error es muy diferente de el error en tiempo de compilaci贸n, de hecho el programa compilara sin error, pero si se intenta ejecutar dentro del microcontrolador la ejecuci贸n sera err谩tica, probablemente el programa se reinicie al tratar de ejecutar la instrucci贸n o tal vez se detenga en ese instante, o tal vez no pase nada, depende de la forma en que se organiza la memoria en el micro, por lo tanto hay que tener cuidado en no rebasar el indice, el m谩ximo es igual a el tama帽o menos uno.\nArreglos y apuntadores. #  Los arreglos y apuntadores tienen una relaci贸n importante, el nombre de un arreglo es un apuntador que apunta a la direcci贸n del primer elemento o elemento cero,\nint numeros[2] = {1, 4}; int a = *numeros + numeros[1]; //a contendra el valor de 5 A pesar de esta equivalencia, prefiero utilizar los corchetes cuando de arreglos se trata, esto me evita la sobrecargar de conceptos en la cabeza y me permite diferenciar claramente el prop贸sito de un arreglo y el de un apuntador, con el arreglo quiero manejar una colecci贸n de datos, mientras que con los apuntadores quiero manejar el acceso a objetos individuales.\n"}),a.add({id:3,href:'/posts/principio-de-responsabilidad-unica-srp/',title:"Principio de responsabilidad 煤nica (SRP)",section:"Posts",content:"En el desarrollo 谩gil, el principio de responsabilidad 煤nica es uno de los cinco principios fundamentales, el principio define lo siguiente:\nUn m贸dulo debe tener un solo motivo para cambiar.\nY eso es todo, 驴f谩cil no?, yo tambi茅n lo creo, 驴qu茅 es lo que creo?, no lo entiendo. Vamos por partes, las palabras son obvias, pero la frase es un poco ambigua, el meollo del asunto es claramente un solo motivo para cambiar, podemos apoyarnos en el nombre del principio, responsabilidad 煤nica, mmm parece ser que ambas frases se refieren a lo mismo, 驴a qu茅 mismo?, mmm, lo que esta claro es que un m贸dulo solo debe tener una sola responsabilidad, por ejemplo suponiendo que requerimos un sistema que controle el movimiento de un robot m贸vil, el robot puede ir hacia adelante, atr谩s y rotar las ruedas de direcci贸n, una forma de visualizarlo es la siguiente,\nSeparaci贸n obvia.\nSe sugiere una separaci贸n de responsabilidades, en lugar de que el m贸dulo robot_posici贸n administre el avance, retroceso y giro, separamos las responsabilidades y las asignamos a nuevos m贸dulos, esta separaci贸n es lo primero que se me vino a la mente, 驴pero esta separaci贸n es la m谩s adecuada?, las repuesta no es evidente ni definitiva, es aqu铆 donde recurrimos a la definici贸n un solo motivo para cambiar, los m贸dulos traslaci贸n y rotaci贸n cumplen con el principio srp, solo si al requerir una nueva caracter铆stica, solo uno de los dos m贸dulos necesita modificarse.\nSuponiendo que los requerimientos cambian y que se requiere que la velocidad a la que se mueve el robot hacia adelante y atr谩s sea controlable, es evidente que el m贸dulo traslaci贸n sera el 煤nico que cambie, por lo tanto la separaci贸n que se realizo es adecuada y cumple con el principio srp.\nAhora suponiendo que la especificaci贸n cambia, se desea que el robot tenga movimiento continuo, es decir que el robot avance hacia adelante o atr谩s mientras est谩 rotando. Ahora nuestros m贸dulos no cumplen con el principio, pues ambos deben ser modificados para alcanzar los nuevos requerimientos, este ser谩 un buen momento para replantear nuestra anterior separaci贸n en m贸dulos, una refactorizaci贸n nos da el siguiente modelo,\nDe esta manera velocidad solo se encarga de mover los motores avance y de retroceso, tren_de_giro se encarga de girar un motor de direcci贸n o el ajuste necesario dependiendo de la forma del robot.\nCon esto quiero decir que los m贸dulos deben agruparse de tal forma que las razones por las que cambian est茅n juntas, con esto logramos que al agregar nuevos cambios, solo debamos modificar el m铆nimo de m贸dulos.\n驴Y cuales son esas razones de cambio?, la respuesta es el cliente, el usuario, si el cliente del m贸dulo hace una nueva especificaci贸n que implique un cambio y para lograr la implementaci贸n se requieren modificar m谩s de un m贸dulo se debe replantear la forma y el tama帽o de los m贸dulos.\nRepito, el objetivo del SRP es proveer una forma de \u0026ldquo;modularizar\u0026rdquo; el programa en base a peticiones de cambios, aunque exista la tentaci贸n de agrupar m贸dulos por forma, color, sabor, etc, que pudieran parecer m谩s naturales, agrupar por motivos de cambios, nos dar谩 como resultado un software altamente 谩gil en el sentido de nuevas caracter铆sticas.\nEn el ejemplo anterior, 驴que sentido tendr铆a mezclar el c贸digo de control de posici贸n con el c贸digo de control visi贸n del robot?, si nosotros requerimos modificar el contraste o el brillo de la imagen, 驴ser铆a necesario modificar la velocidad del robot?, las respuesta obvia es que no, sin embargo piensa que las c谩maras aveces son muy lentas, quiz谩 requerimos tomar una imagen cuando el robot se acerque a un objeto, entonces si la c谩mara es lenta necesariamente requerimos bajar la velocidad, ni modo, es triste, pero debemos refactorizar los m贸dulos en har谩s de lograr el objetivo.\nEl SRP es el principio m谩s sencillo de describir, pero el m谩s dif铆cil de asimilar, requiere pr谩ctica, esfuerzo, experiencia y mucha meditaci贸n.\n"}),a.add({id:4,href:'/posts/solid/',title:"SOLID",section:"Posts",content:"_Soy malo y eso es bueno, yo jam谩s ser茅 bueno y eso no es malo, no hay nadie que quiera ser adem谩s de mi. #  - Ralph el demoledor._\nSOLID #  Dentro del mundo de la programaci贸n existen los famosos paradigmas de programaci贸n, entre ellos: la programaci贸n funcional, la programaci贸n orientada a eventos, la programaci贸n estructurada, la programaci贸n orientada a objetos y otros m谩s. En esta fecha 2020, la programaci贸n orientada a objetos sin duda domina la forma en que se escribe el software en general, vale la pena aprender este paradigma pues no ser谩 raro encontrarnos con programas basados en 茅l.\nEl 茅xito de la programaci贸n orientada a objetos, se basa en la abstracci贸n de objetos, 驴qu茅 es la abstracci贸n de objetos?, personalmente la defino como una combinaci贸n entre imaginar, separar y simplificar, es decir tomamos un objeto real por ejemplo un motor, identificamos lo que nos interesa por ejemplo la velocidad y la direcci贸n de giro y descartamos el resto de detalles, el tipo de motor, la potencia, la tensi贸n de entrada, el par, marca, color, peso, etc, este motor que 煤nicamente gira a la velocidad y direcci贸n indicada, es una abstracci贸n de un motor real, esto que parece tan trivial tiene la cualidad de simplificar la forma en que se resuelven los problema, pues los humanos estamos adaptados a pensar en objetos abstractos.\nDentro de la programaci贸n orientada a objetos han surgido diferentes corrientes de desarrollo, en los 煤ltimos a帽os el desarrollo 谩gil gano una popularidad importante. En las catacumbas de un lugar de cuyo nombre no quiero acordarme, se reuni贸 un grupo de programadores con gran experiencia en el desarrollo de software, conspirando en contra de la t茅cnicas tradicionales escribieron el manifiesto 谩gil,\nhttps://agilemanifesto.org/iso/es/manifesto.html\nuna vez popularizado el desarrollo 谩gil comenzaron a desarrollarse numerosas metodolog铆as de trabajo, entre ellas: scrum, kaban, xp, tdd, etc, como mencione las personas funcionamos en base a abstracciones por lo que las metodolog铆as 谩giles pueden salir del mundo de la programaci贸n e implementarse en otros rubros de la humanidad.\nPersonalmente yo no me sent铆 seguro con mi c贸digo hasta que aprend铆 TDD (Test Driven Development), Desarrollo Guiado por Pruebas.\nAqu铆 tratare de describir los cinco principios fundamentales del desarrollo 谩gil, acu帽ados por Robert C. Martin, Agile Software Development, Principles, Patterns, and Practices. Es un excelente referencia para cualquiera que pretenda aprender a programar.\nSOLID es un acr贸nimo formador por los cinco principios del desarrollo 谩gil.\nS Single responsibility principle (Principio de responsabilidad 煤nica)\nO Open/closed principle (Principio Abierto/Cerrado)\nL Liskov substitution principle (Principio de sustituci贸n de Liskov)\nI Interface segregation principle (Principio de segregaci贸n de la interfaz)\nD Dependency inversion principle (Principio de inversi贸n de dependencia)\nSi cumplimos con estos principios dentro de nuestro c贸digo, entonces podemos decir que nuestro c贸digo es 谩gil\n Sigue mi blog #  Recibe nuevo contenido directamente en tu bandeja de entrada.\n[jetpack_subscription_form subscribe_placeholder=\u0026ldquo;Introduce tu direcci贸n de correo electr贸nico\u0026rdquo; show_subscribers_total=\u0026ldquo;false\u0026rdquo; button_on_newline=\u0026ldquo;false\u0026rdquo; submit_button_text=\u0026ldquo;Registrarse\u0026rdquo; custom_background_emailfield_color=\u0026ldquo;undefined\u0026rdquo; custom_background_button_color=\u0026ldquo;undefined\u0026rdquo; custom_text_button_color=\u0026ldquo;undefined\u0026rdquo; custom_font_size=\u0026ldquo;16\u0026rdquo; custom_border_radius=\u0026ldquo;0\u0026rdquo; custom_border_weight=\u0026ldquo;1\u0026rdquo; custom_border_color=\u0026ldquo;undefined\u0026rdquo; custom_padding=\u0026ldquo;15\u0026rdquo; custom_spacing=\u0026ldquo;10\u0026rdquo; submit_button_classes=\u0026quot;\u0026quot; email_field_classes=\u0026quot;\u0026quot; show_only_email_and_button=\u0026ldquo;true\u0026rdquo; ]\n"}),a.add({id:5,href:'/posts/electronica/',title:"Electr贸nica",section:"Posts",content:"Ah, 驴pero que oigo?, una intromisi贸n, debe ser #  Lisa Simpson, la respuesta a una pregunta que\nnunca hizo nadie.\n-Ned Flanders\n Sigue mi blog #  Recibe nuevo contenido directamente en tu bandeja de entrada.\n[jetpack_subscription_form show_only_email_and_button=\u0026ldquo;true\u0026rdquo; custom_background_button_color=\u0026ldquo;undefined\u0026rdquo; custom_text_button_color=\u0026ldquo;undefined\u0026rdquo; submit_button_text=\u0026ldquo;Suscribir\u0026rdquo; submit_button_classes=\u0026ldquo;undefined\u0026rdquo; show_subscribers_total=\u0026ldquo;false\u0026rdquo; ]\n"}),a.add({id:6,href:'/docs/perifericos/gpio/perifericos-atmega328p-puertos-de-entrada-salida-de-proposito-general-gpio-vii-display-siete-segmentos/',title:"Display Siete Segmentos VI.",section:"GPIO",content:"La funci贸n setNumber puede ser mejorada, antes de ello quiero hacer una modificaci贸n de dise帽o, el m贸dulo display7 hace varias cosas, configura los puertos, convierte de decimal a la colecci贸n adecuada de pines de salida y finalmente escribe las salidas a los puertos, este 煤ltimo par de acciones en nuestra implementaci贸n se realizan en la misma funci贸n setNumber, se recomienda que las funciones sean responsables de una sola acci贸n bien definida.\nTomando en cuenta lo anterior sugiero lo siguiente,\nvoid display7\\_setNumber(short number) { uint8\\_t pines7 = decoder7(number); writeTo7(pines7); } de esta manera separamos las dos acciones y la funci贸n setNumber 煤nicamente se encarga de controlar el flujo. Nos concentramos en implementar la funci贸n decoder7, recibe un n煤mero decimal y lo convierte en un c贸digo (codificaci贸n) 7 segmentos. Cuando pasamos el n煤mero 5 por ejemplo, decoder7 retorna el valor binario 0b0110 1101 que en decimal corresponde a 109, la correspondencia es la siguiente\n GFE DCBA 0b0110 1101 //Cada bit corresponde a un led //para el n煤mero cero GFE DCBA 0b0010 1111 //Cada bit corresponde a un led la implementaci贸n es de la forma\nstatic uint8\\_t decoder7(short number) { if(number == 0) return 0b0111111; else if(number == 5) return 0b01101101; } la notaci贸n 0b, es una notaci贸n no est谩ndar, prefiero utilizar una notaci贸n hexadecimal,\nstatic uint8\\_t decoder7(short number) { if(number == 0) //0b0011 1111 return 0x3f; else if(number == 1) //0b0000 0110 return 0x06; else if(number == 2) //0b0101 1011 return 0x5A; else if(number == 3) //0b0100 1111 return 0x4F; else if(number == 4) //0b0110 0110 return 0x66; else if(number == 5) //0b0110 1101 return 0x6D; else if(number == 6) //0b0111 1101 return 0x7D; else if(number == 7) //0b0000 0111 return 0x07; else if(number == 8) //0b0111 1111 return 0x7F; else if(number == 9) //0b0110 1111 return 0x6F; } La soluci贸n est谩 bien, pero es horriblemente grande, efectivamente requerimos un nuevo look, la refactorizaci贸n es muy simple, guardamos todos los valores en un arreglo y retornamos el valor al cual apunta el indice,\nstatic uint8\\_t decoder7(short number) { const uint8\\_t code7\\[10\\] = { 0x3f,	//0 0b0011 1111 0x06,	//1 0b0000 0110 0x5B,	//2 0b0101 1011 0x4F,	//3 0b0100 1111 0x66,	//4 0b0110 0110 0x6D,	//5 0b0110 1101 0x7D,	//6 0b0111 1101 0x07,	//7 0b0000 0111 0x7F,	//8 0b0111 1111 0x6F	//9 0b0110 1111 }; return code7\\[number\\]; } mucho mejor. Ahora implementaremos writeTo7, debemos tomar los pines retornados por decoder7 y escribirlos en los puertos PORTD y PORTB, sabemos que\ndecorder7 retorna 8 bits de la forma 0b0GFE DCBA y nuestros puertos, aceptan 8 bits de la forma PORTD 0bFEDC BA00 PORTB 0b0000 000G la soluci贸n consiste en corrimientos, se propone\nstatic void writeTo7(uint8\\_t pines\\_to\\_set) { uint8\\_t port\\_D; port\\_D = pines\\_to\\_set\u0026lt;\u0026lt;2; uint8\\_t port\\_B; port\\_B = pines\\_to\\_set \u0026gt;\u0026gt; 6; pinoutLevelLow(); setBits(\u0026amp;PORTD, port\\_D); setBits(\u0026amp;PORTB, port\\_B); } refactorizamos las primeras 4 lineas en una sola funci贸n, esto para evitar tener m谩s de una acci贸n dentro de la funci贸n write7\nstatic getLedsToPorts(uint8\\_t \\* port\\_D, uint8\\_t \\* port\\_B, uint8\\_t pines\\_to\\_set) { \\*port\\_D = pines\\_to\\_set\u0026lt;\u0026lt;2; \\*port\\_B = pines\\_to\\_set \u0026gt;\u0026gt; 6; } static void writeTo7(uint8\\_t pines\\_to\\_set) { uint8\\_t port\\_D; uint8\\_t port\\_B; getLedsToPorts(\u0026amp;port\\_D, \u0026amp;port\\_B, pines\\_to\\_set); pinoutLevelLow(); setBits(\u0026amp;PORTD, port\\_D); setBits(\u0026amp;PORTB, port\\_B); } nuestro programa esta casi listo, como 煤ltima modificaci贸n debemos agregar un guardia a la funci贸n setNumber, 驴que pasa si convertimos el n煤mero 10 o el n煤mero negativo -1?, setNumber(10), el comportamiento no esta definido por nosotros, para evitar comportamientos no definidos agregamos una condici贸n que nos maneje dichos casos\nvoid display7\\_setNumber(short number) { if(number \u0026gt; 9 || number \u0026lt; 0){ return ; } uint8\\_t pines7 = decoder7(number); writeTo7(pines7); } en mi caso, tan solo le indico que quiero ignorar tales casos. Hemos terminado nuestra implementaci贸n, el programa funciona perfectamente bien, cumple con las expectativas (las especificaciones), podemos modificar la funci贸n main y cambiar el orden de los n煤meros decimales sin el m谩s m铆nimo miedo de pensar que el m贸dulo se romper谩, literalmente aislamos al display de el programa principal.\nPero, 驴es necesario todo este trabajo para un simple display de 7 segmentos?, pues eso depende de tu proyecto y un juicio de valores personal, menciono lo que logramos\n Aislamos el m贸dulo. El m贸dulo se puede utilizar en otros m贸dulos. Los usuarios del m贸dulo tan solo utilizaran 3 funciones. Minimizamos la posibilidad de errores.  Todo esto en 292 bytes, que corresponden a menos del 1% del espacio disponible. Pienso que no esta nada mal, anexo la implementaci贸n completa\n//display7.c #include\u0026quot;display7.h\u0026quot; #include\u0026lt;avr/io.h\u0026gt; #include\u0026lt;stdint.h\u0026gt; #define led\\_A (1\u0026lt;\u0026lt;PD2) #define led\\_B (1\u0026lt;\u0026lt;PD3) #define led\\_C (1\u0026lt;\u0026lt;PD4) #define led\\_D (1\u0026lt;\u0026lt;PD5) #define led\\_E (1\u0026lt;\u0026lt;PD6) #define led\\_F (1\u0026lt;\u0026lt;PD7) #define led\\_G (1\u0026lt;\u0026lt;PB0) static void setBits(uint8\\_t \\*regi, uint8\\_t bits) { \\*regi |= bits; } static void clearBits(uint8\\_t \\*regi, uint8\\_t bits) { \\*regi \u0026amp;= ~bits; } typedef enum {DIRECTION, LEVEL}PORT\\_TYPE; static void selectPorts(uint8\\_t \\*\\* port1, uint8\\_t \\*\\* port2, PORT\\_TYPE port\\_type) { if(port\\_type == DIRECTION){ \\*port1 = \u0026amp;DDRD; \\*port2 = \u0026amp;DDRB; }else if(port\\_type == LEVEL){ \\*port1 = \u0026amp;PORTD; \\*port2 = \u0026amp;PORTB; } } static void actionOnPorts(void (\\*action)(uint8\\_t \\*, uint8\\_t), PORT\\_TYPE port\\_type) { uint8\\_t \\* port1; uint8\\_t \\* port2; selectPorts(\u0026amp;port1, \u0026amp;port2, port\\_type); action(port1, led\\_A|led\\_B|led\\_C|led\\_D|led\\_E|led\\_F); action(port2, led\\_G); } static void pinoutAsOutputs(void) { actionOnPorts(setBits, DIRECTION); } static void pinoutAsInputs(void) { actionOnPorts(clearBits, DIRECTION); } static void pinoutLevelHigh(void) { actionOnPorts(setBits, LEVEL); } static void pinoutLevelLow(void) { actionOnPorts(clearBits, LEVEL); } void display7\\_init(void) { pinoutAsOutputs(); pinoutLevelLow(); } void display7\\_destroy(void) { pinoutAsInputs(); pinoutLevelLow(); } static uint8\\_t decoder7(short number) { const uint8\\_t code7\\[10\\] = { 0x3f,	//0 0b0011 1111 0x06,	//1 0b0000 0110 0x5B,	//2 0b0101 1011 0x4F,	//3 0b0100 1111 0x66,	//4 0b0110 0110 0x6D,	//5 0b0110 1101 0x7D,	//6 0b0111 1101 0x07,	//7 0b0000 0111 0x7F,	//8 0b0111 1111 0x6F	//9 0b0110 1111 }; return code7\\[number\\]; } static getLedsToPorts(uint8\\_t \\* port\\_D, uint8\\_t \\* port\\_B, uint8\\_t pines\\_to\\_set) { \\*port\\_D = pines\\_to\\_set\u0026lt;\u0026lt;2; \\*port\\_B = pines\\_to\\_set \u0026gt;\u0026gt; 6; } static void writeTo7(uint8\\_t pines\\_to\\_set) { uint8\\_t port\\_D; uint8\\_t port\\_B; getLedsToPorts(\u0026amp;port\\_D, \u0026amp;port\\_B, pines\\_to\\_set); pinoutLevelLow(); setBits(\u0026amp;PORTD, port\\_D); setBits(\u0026amp;PORTB, port\\_B); } void display7\\_setNumber(short number) { if(number \u0026gt; 9 || number \u0026lt; 0){ return ; } uint8\\_t pines7 = decoder7(number); writeTo7(pines7); } 105 l铆neas de trabajo esfuerzo e ilusiones, por supuesto es mejorable, pero la 煤nica forma de mejorar es haciendo muchos programas, de eso no se puede escapar.\nTodo el trabajo fue basado en un especificaci贸n bien definida, pero rara vez tenemos tal especificaci贸n, la mayor铆a de las veces no sabemos que rumbo debe tomar el dise帽o, en la siguiente entrada cambiaremos la especificaci贸n, en esta ocasi贸n el pines no estar谩n definidos, es decir el usuario del m贸dulo deber谩 especificarlos antes de usar setNumber.\n"}),a.add({id:7,href:'/docs/perifericos/gpio/perifericos-atmega328p-puertos-de-entrada-salida-de-proposito-general-gpio-vi-display-siete-segmentos/',title:"Display Siete Segmentos V.",section:"GPIO",content:"Continuamos refactorizando el c贸digo para evitar repeticiones y ganar legibilidad, retomando.\n//display7.c #include\u0026quot;display7.h\u0026quot; #include\u0026lt;avr/io.h\u0026gt; #define led\\_A (1\u0026lt;\u0026lt;PD2) #define led\\_B (1\u0026lt;\u0026lt;PD3) #define led\\_C (1\u0026lt;\u0026lt;PD4) #define led\\_D (1\u0026lt;\u0026lt;PD5) #define led\\_E (1\u0026lt;\u0026lt;PD6) #define led\\_F (1\u0026lt;\u0026lt;PD7) #define led\\_G (1\u0026lt;\u0026lt;PB2) static void pinoutAsOutputs(void) { //pinout como salidas DDRB |= led\\_G; DDRD |= led\\_A|led\\_B|led\\_C| led\\_D|led\\_E|led\\_F; } static void pinoutLevelLow(void) { //pinout nivel bajo PORTB \u0026amp;= ~led\\_G; PORTD \u0026amp;= ~(led\\_A|led\\_B|led\\_C| led\\_D|led\\_E|led\\_F); } static void pinoutAsInputs(void) { //pinout como entradas DDRB \u0026amp;= ~led\\_G; DDRD \u0026amp;= ~(led\\_A|led\\_B|led\\_C| led\\_D|led\\_E|led\\_F); } void display7\\_init(void) { pinoutAsOutputs(); pinoutLevelLow(); } void display7\\_destroy(void) { pinoutAsInputs(); pinoutLevelLow(); } void display7\\_setNumber(short number) { if(number == 0){ PORTB \u0026amp;= ~led\\_G; //LED G apagado PORTD |= led\\_A|led\\_B|led\\_C| led\\_D|led\\_E|led\\_F; }else if(number == 1){ PORTB \u0026amp;= ~led\\_G; PORTD \u0026amp;= ~(led\\_A| led\\_D|led\\_E|led\\_F); PORTD |= led\\_B|led\\_C;//LED B y C encendido } //... hasta number == 9 } A ojo de buen cubero, me da la impresi贸n que las tres funciones auxiliares se parecen mucho, en lo 煤nico que difieren es en el registro y en establecer o limpiar, por supuesto vamos a tratar de reducir esta repetici贸n. Propongo el siguiente par de funciones auxiliares.\nstatic void setBits(uint8_t *regi, uint8_t bits) { *regi |= bits; } static void clearBits(uint8_t *regi, uint8_t bits) { *regi \u0026amp;= ~bits; } toman como par谩metro un apuntador hacia el registro y le asignan el valor del segundo par谩metro, f谩cil o como decimos en espa帽ol mexicano izi, esta refactorizaci贸n nos ayuda en dos cosas legibilidad y claridad en la intensi贸n del proceso\n//display7.c #include\u0026quot;display7.h\u0026quot; #include\u0026lt;avr/io.h\u0026gt; #include\u0026lt;stdint.h\u0026gt; #define led\\_A (1\u0026lt;\u0026lt;PD2) #define led\\_B (1\u0026lt;\u0026lt;PD3) #define led\\_C (1\u0026lt;\u0026lt;PD4) #define led\\_D (1\u0026lt;\u0026lt;PD5) #define led\\_E (1\u0026lt;\u0026lt;PD6) #define led\\_F (1\u0026lt;\u0026lt;PD7) #define led\\_G (1\u0026lt;\u0026lt;PB2) static void setBits(uint8\\_t \\*regi, uint8\\_t bits) { \\*regi |= bits; } static void clearBits(uint8\\_t \\*regi, uint8\\_t bits) { \\*regi \u0026amp;= ~bits; } static void pinoutAsOutputs(void) { setBits(\u0026amp;DDRD, led\\_A|led\\_B|led\\_C|led\\_D|led\\_E|led\\_F); setBits(\u0026amp;DDRB, led\\_G); } static void pinoutLevelLow(void) { clearBits(PORTD, led\\_A|led\\_B|led\\_C|led\\_D|led\\_E|led\\_F); clearBits(PORTB, led\\_G); } static void pinoutAsInputs(void) { clearBits(DDRD, led\\_A|led\\_B|led\\_C|led\\_D|led\\_E|led\\_F); clearBits(DDRB, led\\_G); } void display7\\_init(void) { pinoutAsOutputs(); pinoutLevelLow(); } void display7\\_destroy(void) { pinoutAsInputs(); pinoutLevelLow(); } void display7\\_setNumber(short number) { if(number == 0){ setBits(\u0026amp;PORTD, led\\_A|led\\_B|led\\_C|led\\_D|led\\_E|led\\_F); clearBits(\u0026amp;PORTB, led\\_G); }else if(number == 1){ setBits(\u0026amp;PORTD, led\\_B|led\\_C); clearBits(\u0026amp;PORTD, led\\_A|led\\_D|led\\_E|led\\_F); clearBits(\u0026amp;PORTB, led\\_G); } //... hasta number == 9 } vemos que aunque ganamos claridad, no eliminamos la repetici贸n pero ahora se ve f谩cilmente, las llamadas a las funciones clearBits y setBits, son pr谩cticamente iguales, se propone una refactorizaci贸n basada en un apuntador de funciones\ntypedef enum {DIRECTION, LEVEL}PORT\\_TYPE; static void actionOnPort(void (\\*action)(uint8\\_t \\*, uint8\\_t), PORT\\_TYPE port\\_type) { if(port\\_type == DIRECTION){ action(\u0026amp;DDRD, led\\_A|led\\_B|led\\_C|led\\_D|led\\_E|led\\_F); action(\u0026amp;DDRB, led\\_G); }else if(port\\_type == LEVEL){ action(\u0026amp;PORTD, led\\_A|led\\_B|led\\_C|led\\_D|led\\_E|led\\_F); action(\u0026amp;PORTB, led\\_G); } } de esta forma el c贸digo refactorizado queda\n//display7.c #include\u0026quot;display7.h\u0026quot; #include\u0026lt;avr/io.h\u0026gt; #include\u0026lt;stdint.h\u0026gt; #define led\\_A (1\u0026lt;\u0026lt;PD2) #define led\\_B (1\u0026lt;\u0026lt;PD3) #define led\\_C (1\u0026lt;\u0026lt;PD4) #define led\\_D (1\u0026lt;\u0026lt;PD5) #define led\\_E (1\u0026lt;\u0026lt;PD6) #define led\\_F (1\u0026lt;\u0026lt;PD7) #define led\\_G (1\u0026lt;\u0026lt;PB2) static void setBits(uint8\\_t \\*regi, uint8\\_t bits) { \\*regi |= bits; } static void clearBits(uint8\\_t \\*regi, uint8\\_t bits) { \\*regi \u0026amp;= ~bits; } typedef enum {DIRECTION, LEVEL}PORT\\_TYPE; static void actionOnPorts(void (\\*action)(uint8\\_t \\*, uint8\\_t), PORT\\_TYPE port\\_type) { if(port\\_type == DIRECTION){ action(\u0026amp;DDRD, led\\_A|led\\_B|led\\_C|led\\_D|led\\_E|led\\_F); action(\u0026amp;DDRB, led\\_G); }else if(port\\_type == LEVEL){ action(\u0026amp;PORTD, led\\_A|led\\_B|led\\_C|led\\_D|led\\_E|led\\_F); action(\u0026amp;PORTB, led\\_G); } } static void pinoutAsOutputs(void) { actionOnPorts(setBits, DIRECTION); } static void pinoutAsInputs(void) { actionOnPorts(clearBits, DIRECTION); } static void pinoutLevelLow(void) { actionOnPorts(clearBits, LEVEL); } void display7\\_init(void) { pinoutAsOutputs(); pinoutLevelLow(); } void display7\\_destroy(void) { pinoutAsInputs(); pinoutLevelLow(); } void display7\\_setNumber(short number) { if(number == 0){ setBits(\u0026amp;PORTD, led\\_A|led\\_B|led\\_C|led\\_D|led\\_E|led\\_F); clearBits(\u0026amp;PORTB, led\\_G); }else if(number == 1){ setBits(\u0026amp;PORTD, led\\_B|led\\_C); clearBits(\u0026amp;PORTD, led\\_A|led\\_D|led\\_E|led\\_F); clearBits(\u0026amp;PORTB, led\\_G); } //... hasta number == 9 } claramente eliminamos la repetici贸n, sin embargo no la totalidad, ahora tenemos repetici贸n dentro de la funci贸n actionOnPorts, debemos eliminarla, la refactorizaci贸n anterior tambi茅n nos muestra algo que puede parecer redundante, en lugar de\nvoid display7_init(void) { pinoutAsOutputs(); pinoutLevelLow(); } podemos exponer directamente la funci贸n actionOnPorts de la siguiente forma\nvoid display7_init(void) { actionOnPorts(setBits, DIRECTION); actionOnPorts(clearBits, LEVEL); } y eliminar las funciones pinoutAsOutputs y pinoutLevelLow, sin embargo pienso que la funci贸n actionOnPorts no muestra claramente la intensi贸n de la funci贸n init, personalmente prefiero no eliminar las funciones ya establecidas en init. Las llamadas a las funciones actions son identicas salvo por los puertos, se propone una funci贸n que determine los puertos adecuados\ntypedef enum {DIRECTION, LEVEL}PORT\\_TYPE; static void selectPorts(uint8\\_t \\*\\* port1, uint8\\_t \\*\\* port2, PORT\\_TYPE port\\_type) { if(port\\_type == DIRECTION){ \\*port1 = \u0026amp;DDRD; \\*port2 = \u0026amp;DDRB; }else if(port\\_type == LEVEL){ \\*port1 = \u0026amp;PORTD; \\*port2 = \u0026amp;PORTB; } } de esta forma hemos eliminado las repeticiones\n//display7.c #include\u0026quot;display7.h\u0026quot; #include\u0026lt;avr/io.h\u0026gt; #include\u0026lt;stdint.h\u0026gt; #define led\\_A (1\u0026lt;\u0026lt;PD2) #define led\\_B (1\u0026lt;\u0026lt;PD3) #define led\\_C (1\u0026lt;\u0026lt;PD4) #define led\\_D (1\u0026lt;\u0026lt;PD5) #define led\\_E (1\u0026lt;\u0026lt;PD6) #define led\\_F (1\u0026lt;\u0026lt;PD7) #define led\\_G (1\u0026lt;\u0026lt;PB2) static void setBits(uint8\\_t \\*regi, uint8\\_t bits) { \\*regi |= bits; } static void clearBits(uint8\\_t \\*regi, uint8\\_t bits) { \\*regi \u0026amp;= ~bits; } typedef enum {DIRECTION, LEVEL}PORT\\_TYPE; static void selectPorts(uint8\\_t \\*\\* port1, uint8\\_t \\*\\* port2, PORT\\_TYPE port\\_type) { if(port\\_type == DIRECTION){ \\*port1 = \u0026amp;DDRD; \\*port2 = \u0026amp;DDRB; }else if(port\\_type == LEVEL){ \\*port1 = \u0026amp;PORTD; \\*port2 = \u0026amp;PORTB; } } static void actionOnPorts(void (\\*action)(uint8\\_t \\*, uint8\\_t), PORT\\_TYPE port\\_type) { uint8\\_t \\* port1; uint8\\_t \\* port2; selectPorts(\u0026amp;port1, \u0026amp;port2, port\\_type); action(port1, led\\_A|led\\_B|led\\_C|led\\_D|led\\_E|led\\_F); action(port2, led\\_G); } static void pinoutAsOutputs(void) { actionOnPorts(setBits, DIRECTION); } static void pinoutAsInputs(void) { actionOnPorts(clearBits, DIRECTION); } static void pinoutLevelLow(void) { actionOnPorts(clearBits, LEVEL); } void display7\\_init(void) { pinoutAsOutputs(); pinoutLevelLow(); } void display7\\_destroy(void) { pinoutAsInputs(); pinoutLevelLow(); } void display7\\_setNumber(short number) { if(number == 0){ setBits(\u0026amp;PORTD, led\\_A|led\\_B|led\\_C|led\\_D|led\\_E|led\\_F); clearBits(\u0026amp;PORTB, led\\_G); }else if(number == 1){ setBits(\u0026amp;PORTD, led\\_B|led\\_C); clearBits(\u0026amp;PORTD, led\\_A|led\\_D|led\\_E|led\\_F); clearBits(\u0026amp;PORTB, led\\_G); } //... hasta number == 9 } nos toca mejorar de alguna manera la funci贸n display7_setNumber, podemos seguir llenando los casos, pero ya comienza a verse un desorden importante, otra aproximaci贸n para establecer los n煤meros puede ser, apagar todos y encender los necesarios o encender todos y apagar los necesarios, por ejemplo el cero, encendemos todos y apagamos G, en el caso de el uno, apagamos todos y posteriormente encendemos B y C,\nstatic void pinoutLevelHigh(void) { actionOnPorts(setBits, LEVEL); } void display7\\_setNumber(short number) { if(number == 0){ pinoutLevelHigh(); clearBits(\u0026amp;PORTB, led\\_G); }else if(number == 1){ pinoutLevelLow(); setBits(\u0026amp;PORTD, led\\_B|led\\_C); }else if(number == 2){ pinoutLevelHigh(); clearBits(\u0026amp;PORTD, led\\_F|led\\_C); }else if(number == 3){ pinoutLevelHigh(); clearBits(\u0026amp;PORTD, led\\_F|led\\_E); }else if(number == 4){ pinoutLevelHigh(); clearBits(\u0026amp;PORTD, led\\_A|led\\_D|led\\_E); }else if(number == 5){ pinoutLevelHigh(); clearBits(\u0026amp;PORTD, led\\_B|led\\_E); }else if(number == 6){ pinoutLevelHigh(); clearBits(\u0026amp;PORTD, led\\_B); }else if(number == 7){ pinoutLevelLow(); setBits(\u0026amp;PORTD, led\\_A|led\\_B|led\\_C); }else if(number == 8){ pinoutLevelHigh(); }else if(number == 9){ pinoutLevelHigh(); clearBits(\u0026amp;PORTD, led\\_E); } } Compilando el programa y verificando su funcionamiento me doy cuenta de que el led G, no funciona, nuestras refactorizaciones nos han ayudado a minimizar la posibilidad de error, restringiendo el acceso a los puertos a un par de funciones, sin embargo el error no es probable que se encuentre ah铆, pues el resto de leds usan dichas funciones y tiene un comportamiento correcto, el error debe estar en un lugar aislado, efectivamente en la directiva #define led_G (1\u0026laquo;PB2) se encuentra el error, pues el pin correcto es PB0.\nDefinitivamente la funci贸n setNumber es mejorable, hay repetici贸n de las funciones pinout y no me parece adecuado exponer el puerto PORTD en este nivel. Antes de arreglarlo, modifiquemos nuestro proyecto ino para realizar la cuenta.\n//proyecto.ino #define F\\_CPU 16000000UL #include\u0026lt;util/delay.h\u0026gt; #include\u0026quot;display7.h\u0026quot; int main(void) { display7\\_init(); while(1){ for(int i = 0; i\u0026lt;10; i++){ display7\\_setNumber(i); \\_delay\\_ms(1000); } } } Compilamos y subimos,\nEn la siguiente entrada mejoraremos la funci贸n setNumber.\n"}),a.add({id:8,href:'/docs/avr/programando-avr-en-c-apuntadores-punteros-pointers-ii-apuntadores-dobles/',title:"Programando Avr en C.- Apuntadores, punteros, pointers III. Apuntadores Dobles.",section:"Programaci贸n Avr en C.",content:"Los apuntadores suenan bastante complejos, nuestro cerebro amplifica su complejidad, pero al igual que cualquier otra variable su funcionamiento es simple,\ntipo ** nombre_apuntador; a que me refiero con apuntador doble, a un apuntador que guarda direcciones de otros apuntadores de su mismo tipo,\nchar caracter1 = 'a'; char caracter2 = 'b'; char \\* letra = \u0026amp;caracter1; char \\*\\* apuntador\\_doble = \u0026amp;letra; \\*apuntador\\_doble = \u0026amp;caracter2; //ahora letra apunta a la direcci贸n de caracter2, //\\*letra es 'b' el prop贸sito evidente de los apuntadores dobles, es cambiar el valor a donde apuntan apuntadores simples,\nint \\* pointer1=NULL; int \\* pointer2=NULL; void updatePointers(int \\*\\* a, int \\*\\* b) { \\*a = direction\\_1; \\*b = direction\\_2; } //ahora los apuntadores apuntan a las //direcciones en direction\\_n Esta aplicaci贸n es muy sencilla, la usaremos con frecuencia.\n"}),a.add({id:9,href:'/docs/avr/programando-avr-en-c-apuntadores-punteros-pointers-ii-apuntadores-a-funciones/',title:"Programando Avr en C.- Apuntadores, punteros, pointers II. Apuntadores a funciones.",section:"Programaci贸n Avr en C.",content:"Como ya he dicho un apuntador es una variable que apunta a direcciones de memoria, tambi茅n hemos mencionado que los apuntadores deben ser especificados sobre el tipo, cuando las funciones se compilan se les asigna una direcci贸n en memoria, 驴existir谩n apuntadores a funciones?, la respuesta es afirmativa, la sintaxis es un poco rara,\ntipo (*nombre_apuntador)(argumento1, argumento2, ..., argumento_n); al igual que los apuntadores comunes, los apuntadores a funciones deben ser especificados con el tipo de dato que regresan, entre parentesis se coloca el operador * seguido del nombre del apuntador, finalmente se especifican los par谩metros)\nint (\\*operacion)(int a, int b); int suma(int a, int b) { return a + b; } int resta(int a, int b) { return a - b; } int a = 5; int b = 10; if(condicion) operacion = suma; else operacion = resta; int c = operacion(a , b); /\\* S铆 condici贸n es verdadera c contendr谩 15 de \\* lo contrario c contendr谩 -5 \\*/ gracias a los apuntadores a funciones, tambi茅n es posible pasar funciones como argumentos de otras funciones,\nint operadorBinario(int (\\*operation)(int a, int b), int c, int d) { return operation(c,d); } int resultado = operadorBinario(suma, 5, 10); //resultado es igual a 15 resultado = operadorBinario(resta, 5, 10); //resultado = -5; Esta caracter铆stica nos ayudara a mejorar la calidad del c贸digo.\n"}),a.add({id:10,href:'/docs/perifericos/gpio/perifericos-atmega328p-puertos-de-entrada-salida-de-proposito-general-gpio-v-display-siete-segmentos/',title:"Display Siete Segmentos IV.",section:"GPIO",content:"Nuestro trabajo consiste en implementar las funciones del m贸dulo contamos con un par de funciones, una para iniciar y otra para cerrar el m贸dulo y una tercera para establecer el n煤mero, la interfaz es muy sencilla y para nuestro prop贸sito es m谩s que suficiente.\nLa mayor parte del trabajo recae en la tercer funci贸n y la dejamos para el final. Es muy com煤n que los m贸dulos contengan dos funciones, init y close o create y destroy, el trabajo de estas dos funciones es llevar al m贸dulo a un estado conocido y liberar los recursos respectivamente. Para el m贸dulo display7 ambas funciones son simples, en la funci贸n destroy, los recursos que se pueden liberar son los puertos y los pines, sin embargo en este caso es de poca utilidad, pues aunque liberemos los recursos nadie puede usarlos, esto no quiere decir que la funci贸n destroy siempre sera tan simple, en m贸dulos m谩s complejos tiene una importancia fundamental sobre todo la utilizar memoria din谩mica.\nLa funci贸n init tiene la misi贸n de establecer las condiciones adecuadas para que el resto del m贸dulo pueda hacer su trabajo, modificara lo registros de los puertos para establecerlos como salidas y con nivel bajo, el c贸digo ya lo tenemos de entradas anteriores, as铆 que lo movemos a la funci贸n display7_init().\n//display7.c #include\u0026quot;display7.h\u0026quot; #include\u0026lt;avr/io.h\u0026gt; void display7\\_init(void) { //pinout como salidas DDRB |= (1\u0026lt;\u0026lt;PB0); DDRD |= (1\u0026lt;\u0026lt;PD2)|(1\u0026lt;\u0026lt;PD3)|(1\u0026lt;\u0026lt;PD4)| (1\u0026lt;\u0026lt;PD5)|(1\u0026lt;\u0026lt;PD6)|(1\u0026lt;\u0026lt;PD7); //pinout nivel bajo PORTB \u0026amp;= ~(1\u0026lt;\u0026lt;PB0); PORTD \u0026amp;= ~((1\u0026lt;\u0026lt;PD2)|(1\u0026lt;\u0026lt;PD3)|(1\u0026lt;\u0026lt;PD4)| (1\u0026lt;\u0026lt;PD5)|(1\u0026lt;\u0026lt;PD6)|(1\u0026lt;\u0026lt;PD7)); } void display7\\_destroy(void) { } void display7\\_setNumber(short number) { } se incluye avr/io.h para acceder a los registros, en el futuro modificaremos la funci贸n init a una versi贸n mejorada, por ahora lo dejamos as铆. La funci贸n destroy regresa los puertos y pines a su estado original,\n//display7.c #include\u0026quot;display7.h\u0026quot; #include\u0026lt;avr/io.h\u0026gt; void display7\\_init(void) { //pinout como salidas DDRB |= (1\u0026lt;\u0026lt;PB0); DDRD |= (1\u0026lt;\u0026lt;PD2)|(1\u0026lt;\u0026lt;PD3)|(1\u0026lt;\u0026lt;PD4)| (1\u0026lt;\u0026lt;PD5)|(1\u0026lt;\u0026lt;PD6)|(1\u0026lt;\u0026lt;PD7); //pinout nivel bajo PORTB \u0026amp;= ~(1\u0026lt;\u0026lt;PB0); PORTD \u0026amp;= ~((1\u0026lt;\u0026lt;PD2)|(1\u0026lt;\u0026lt;PD3)|(1\u0026lt;\u0026lt;PD4)| (1\u0026lt;\u0026lt;PD5)|(1\u0026lt;\u0026lt;PD6)|(1\u0026lt;\u0026lt;PD7)); } void display7\\_destroy(void) { //pinout como entradas DDRB \u0026amp;= ~(1\u0026lt;\u0026lt;PB0); DDRD \u0026amp;= ~((1\u0026lt;\u0026lt;PD2)|(1\u0026lt;\u0026lt;PD3)|(1\u0026lt;\u0026lt;PD4)| (1\u0026lt;\u0026lt;PD5)|(1\u0026lt;\u0026lt;PD6)|(1\u0026lt;\u0026lt;PD7)); //pinout nivel bajo PORTB \u0026amp;= ~(1\u0026lt;\u0026lt;PB0); PORTD \u0026amp;= ~((1\u0026lt;\u0026lt;PD2)|(1\u0026lt;\u0026lt;PD3)|(1\u0026lt;\u0026lt;PD4)| (1\u0026lt;\u0026lt;PD5)|(1\u0026lt;\u0026lt;PD6)|(1\u0026lt;\u0026lt;PD7)); } void display7\\_setNumber(short number) { } Hay modificaciones necesarias para el c贸digo anterior, lo comentare al final. La tarea de la funci贸n setNumber, es modificar un n煤mero decimal entre 0 y 9 de tal forma que se vea reflejado en el display, la siguiente es la implementaci贸n m谩s sencilla de la cual har茅 algunos comentarios.\nvoid display7\\_setNumber(short number) { if(number == 0){ PORTB \u0026amp;= ~(1\u0026lt;\u0026lt;PB0); //LED G apagado PORTD |= (1\u0026lt;\u0026lt;PD2)|(1\u0026lt;\u0026lt;PD3)|(1\u0026lt;\u0026lt;PD4)| (1\u0026lt;\u0026lt;PD5)|(1\u0026lt;\u0026lt;PD6)|(1\u0026lt;\u0026lt;PD7); }else if(number == 1){ PORTB \u0026amp;= ~(1\u0026lt;\u0026lt;PB0); PORTD \u0026amp;= ~((1\u0026lt;\u0026lt;PD2)| (1\u0026lt;\u0026lt;PD5)|(1\u0026lt;\u0026lt;PD6)|(1\u0026lt;\u0026lt;PD7)); PORTD |= (1\u0026lt;\u0026lt;PD3)|(1\u0026lt;\u0026lt;PD4);//LED B y C encendido } //... hasta number == 9 } Un dogma muy importante en el mundo de la programaci贸n especifica que, la repetici贸n de c贸digo es la mayor fuente de errores, con forme vamos agregando casos a la funci贸n setNumber vamos aumentando las posibilidades de equivocarnos, vale la pena suspender el desarrollo en aras de refactorizar lo que ya tenemos. Refactorizar es un gran tema que podr铆a entenderse como pulir el c贸digo, como primer paso vamos a reescribir esos horribles operandos OR, sabemos que PB0 corresponde al led G por el esquem谩tico, es m谩s eficiente que el propio c贸digo exprese a donde pertenece,\n#define led_A (1\u0026lt;\u0026lt;PD2) #define led_B (1\u0026lt;\u0026lt;PD3) #define led_C (1\u0026lt;\u0026lt;PD4) #define led_D (1\u0026lt;\u0026lt;PD5) #define led_E (1\u0026lt;\u0026lt;PD6) #define led_F (1\u0026lt;\u0026lt;PD7) #define led_G (1\u0026lt;\u0026lt;PB0) de esta forma el c贸digo luce m谩s expresivo\n//display7.c #include\u0026quot;display7.h\u0026quot; #include\u0026lt;avr/io.h\u0026gt; #define led\\_A (1\u0026lt;\u0026lt;PD2) #define led\\_B (1\u0026lt;\u0026lt;PD3) #define led\\_C (1\u0026lt;\u0026lt;PD4) #define led\\_D (1\u0026lt;\u0026lt;PD5) #define led\\_E (1\u0026lt;\u0026lt;PD6) #define led\\_F (1\u0026lt;\u0026lt;PD7) #define led\\_G (1\u0026lt;\u0026lt;PB2) void display7\\_init(void) { //pinout como salidas DDRB |= led\\_G; DDRD |= led\\_A|led\\_B|led\\_C| led\\_D|led\\_E|led\\_F; //pinout nivel bajo PORTB \u0026amp;= ~led\\_G; PORTD \u0026amp;= ~(led\\_A|led\\_B|led\\_C| led\\_D|led\\_E|led\\_F); } void display7\\_destroy(void) { //pinout como entradas DDRB \u0026amp;= ~led\\_G; DDRD \u0026amp;= ~(led\\_A|led\\_B|led\\_C| led\\_D|led\\_E|led\\_F); //pinout nivel bajo PORTB \u0026amp;= ~led\\_G; PORTD \u0026amp;= ~(led\\_A|led\\_B|led\\_C| led\\_D|led\\_E|led\\_F); } void display7\\_setNumber(short number) { if(number == 0){ PORTB \u0026amp;= ~led\\_G; //LED G apagado PORTD |= led\\_A|led\\_B|led\\_C| led\\_D|led\\_E|led\\_F; }else if(number == 1){ PORTB \u0026amp;= ~led\\_G; PORTD \u0026amp;= ~(led\\_A| led\\_D|led\\_E|led\\_F); PORTD |= led\\_B|led\\_C;//LED B y C encendido } //... hasta number == 9 } sin embargo se ve algo cr铆ptico y no muestra por si solo las intenciones de cada funci贸n. Haremos uso de funciones auxiliares, para ayudarnos a reducir el c贸digo repetido y ser m谩s expresivo. De inmediato identificamos que la funci贸n init esta compuesta de dos partes, establecer los pines como salidas y establecer los niveles en bajo, podemos refactorizar utilizando dos funciones auxiliares de la forma\nvoid display7_init(void) { pinoutAsOutputs(); pinoutLowLevel(); } de esta forma es sencillo ver la intensi贸n de la funci贸n init, para hacer valido el c贸digo colocamos ambas implementaciones antes de la funci贸n init\nstatic void pinoutAsOutputs(void) { //pinout como salidas DDRB |= led_G; DDRD |= led_A|led_B|led_C| led_D|led_E|led_F; } static void pinoutLowLevel(void) { //pinout nivel bajo PORTB \u0026amp;= ~led_G; PORTD \u0026amp;= ~(led_A|led_B|led_C| led_D|led_E|led_F); } void display7_init(void) { pinoutAsOutputs(); pinoutLowLevel(); } La palabra static(cuidado static tiene otros usos en otros contextos) sirve para indicar que las funciones 煤nicamente pueden ser llamadas desde el mismo archivo, en este caso display7.c, en el futuro har茅 una entrada especifica sobre el alcance(scope).\nLogramos un poco de legibilidad, pero tambi茅n importante es que evitamos la repetici贸n de c贸digo, 驴en donde?, hay que mirar la funci贸n destroy, que puede ser refactorizada como\nvoid display7_destroy(void) { pinoutAsInputs(); pinoutLowLevel(); } pinoutLowLevel ya la implementamos, solo queda implementar pinoutAsInputs,\nstatic void pinoutAsOutputs(void) { //pinout como salidas DDRB |= led_G; DDRD |= led_A|led_B|led_C| led_D|led_E|led_F; } static pinoutAsInputs(void) { //pinout como entradas DDRB \u0026amp;= ~led_G; DDRD \u0026amp;= ~(led_A|led_B|led_C| led_D|led_E|led_F); } static void pinoutLowLevel(void) { //pinout nivel bajo PORTB \u0026amp;= ~led_G; PORTD \u0026amp;= ~(led_A|led_B|led_C| led_D|led_E|led_F); } void display7_init(void) { pinoutAsOutputs(); pinoutLowLevel(); } void display7_destroy(void) { pinoutAsInputs(); pinoutLowLevel(); } aun le falta al c贸digo, pero ya comienza a verse la forma. M谩s refactorizaci贸n en la siguiente entrada.\n"}),a.add({id:11,href:'/docs/avr/programando-avr-en-c-apuntadores-punteros-pointers/',title:"Programando Avr en C.- Apuntadores, punteros, pointers I.",section:"Programaci贸n Avr en C.",content:"Los apuntadores (pienso que esta es la traducci贸n m谩s acertada), tambi茅n conocidos como punteros o pointers en ingles, es un tipo de dato caracter铆stico de lenguajes de bajo nivel y algunos de nivel medio, C por supuesto cuenta con tal tipo de dato.\nUn apuntador es una variable cuyo tipo de dato almacena direcciones de memoria, tan simple como eso. Aunque una direcci贸n de memoria puede ser interpretada como un entero, es mejor pensar que una direcci贸n de memoria es un tipo de dato diferente, un tipo de dato de tipo apuntador.\nLos apuntadores son temidos y exaltados, por buenas razones, el problema es que los apuntadores sirven para gran cantidad de aplicaciones y da la impresi贸n de que debes conocerlas todas, por supuesto no es as铆, se puede usar apuntadores de forma efectiva sin tener todo el bagaje t茅cnico alrededor, e ir aprendiendo gradualmente los pormenores. El secreto esta en auto limitarse y ser disciplinado.\nla sintaxis para declarar un apuntador es la siguiente\ntipo_a_donde_apunta * nombre_apuntador; un apuntador que apunta a una variable de tipo entero es diferente a un apuntador que apunta a una variable de tipo car谩cter,\nchar a; int b; int * apuntador1; // solo puede apuntar hacia b, apuntar hacia a implica un error Operador addressOff \u0026amp; #  Para almacenar la direcci贸n de una variable primero debemos obtener su direcci贸n, para ello contamos con el operador \u0026amp;,\nint b = 0; int * apuntador = \u0026amp;b; //apuntador ahora contiene la direcci贸n de memoria de b Operador de indirecci贸n * #  驴Para que se usa un apuntador?, como mencione las aplicaciones son amplias, pero la base es la misma, se trata de acceder al contenido guardado en una direcci贸n de memoria de manera indirecta. Una vez establecido un apuntador, usamos el operador de indirecci贸n para acceder al contenido a donde apunta.\nint b = 0; int * apuntador = \u0026amp;b; *apuntador = 10; //ahora b contiene el valor 10 y no 0. Una de las aplicaciones m谩s importantes es el paso de par谩metros a funciones, cuya intensi贸n sea modificar tales par谩metros, por ejemplo\nint a = 5; int b= 3; //Se pasan dos apuntadores intercambiar(\u0026amp;a, \u0026amp;b); //pasar \u0026amp;a, es equivalente a crear un apuntador //int *apuntador = \u0026amp;a y escribir intercambiar(apuntador, \u0026amp;b); //ahora a = 3 y b = 5; void intercambiar(int * v1, int * v2) { int tmp = *v1;//tmp = valor guardado en la //direcci贸n a donde apunta v1 *v1 = *v2; *v2 = tmp; } Usaremos ampliamente la forma de la funci贸n intercambiar, por ahora es suficiente con este conocimiento sobre apuntadores, por supuesto m谩s adelante veremos otras aplicaciones.\n"}),a.add({id:12,href:'/posts/contacto/',title:"Contacto",section:"Posts",content:"Hablemos . No dudes en ponerte en contacto con nosotros mediante la informaci贸n de contacto a continuaci贸n, o env铆anos un mensaje mediante el formulario.\nPonte en contacto con nosotros #  Calle Ejemplo, 10\nCiudad, 10100\nEspa帽a\ncorreoelectronico@ejemplo.com\n(+34) 399 555 234\nEnv铆anos un mensaje #  "}),a.add({id:13,href:'/posts/gpio-atmega328p/',title:"GPIO atmega328p.",section:"Posts",content:"_Si, se nos acabo la duela y pintamos la tierra, 驴qu茅 trucazo no? #  Moe Szyslak_\n Sigue mi blog #  Recibe nuevo contenido directamente en tu bandeja de entrada.\n[jetpack_subscription_form subscribe_placeholder=\u0026ldquo;Direcci贸n de correo electr贸nico\u0026rdquo; show_subscribers_total=\u0026ldquo;false\u0026rdquo; button_on_newline=\u0026ldquo;true\u0026rdquo; submit_button_text=\u0026ldquo;Suscribir\u0026rdquo; custom_background_emailfield_color=\u0026ldquo;undefined\u0026rdquo; custom_background_button_color=\u0026ldquo;undefined\u0026rdquo; custom_text_button_color=\u0026ldquo;undefined\u0026rdquo; custom_font_size=\u0026ldquo;16\u0026rdquo; custom_border_radius=\u0026ldquo;0\u0026rdquo; custom_border_weight=\u0026ldquo;1\u0026rdquo; custom_border_color=\u0026ldquo;undefined\u0026rdquo; custom_padding=\u0026ldquo;15\u0026rdquo; custom_spacing=\u0026ldquo;10\u0026rdquo; submit_button_classes=\u0026ldquo;has-text-color has-background-color has-background has-primary-background-color\u0026rdquo; email_field_classes=\u0026quot;\u0026quot; show_only_email_and_button=\u0026ldquo;true\u0026rdquo; ]\n"}),a.add({id:14,href:'/docs/perifericos/gpio/perifericos-atmega328p-puertos-de-entrada-salida-de-proposito-general-gpio-iv-display-siete-segmentos/',title:"Display Siete Segmentos III.",section:"GPIO",content:"No se si ya lo hab铆a mencionado pero odio el entorno de desarrollo de arduino, en esta ocasi贸n por la forma tan pobre de manejar ficheros. Continuando la entrada anterior, vamos a mover nuestro m贸dulo en un par de archivos, creamos dos ficheros cuyo nombre deje en claro que hay escrito en 茅l, un buen nombre es display7,\n$touch display7.c $touch display7.h ahora en nuestro entorno de desarrollo incluimos los dos ficheros, para ello vamos al men煤 Programa-\u0026gt;A帽adir fichero y a帽adimos ambos ficheros, ambos aparecer谩n en nuestro entorno de desarrollo y podr谩n ser editados desde el mismo, movemos el m贸dulo a los nuevos ficheros, los prototipos van en 茅l .h y las definiciones al .c, de esta manera tenemos los tres ficheros siguientes\n//proyecto.ino #include\u0026lt;avr/io.h\u0026gt; int main(void) { DDRB |= (1\u0026lt;\u0026lt;PB0); DDRD |= (1\u0026lt;\u0026lt;PD2)|(1\u0026lt;\u0026lt;PD3)|(1\u0026lt;\u0026lt;PD4)| (1\u0026lt;\u0026lt;PD5)|(1\u0026lt;\u0026lt;PD6)|(1\u0026lt;\u0026lt;PD7); PORTB |= (1\u0026lt;\u0026lt;PB0); PORTD |= (1\u0026lt;\u0026lt;PD2)|(1\u0026lt;\u0026lt;PD4)|(1\u0026lt;\u0026lt;PD5)|(1\u0026lt;\u0026lt;PD7); return 0; } //display7.h void display7_init(void); void display7_setNumber(short number); void display7_destroy(void);\n//display7.c void display7\\_init(void) { } void display7\\_setNumber(short number) { } void display7\\_destroy(void) { } ``` nuevamente compilamos el programa y no nos dar谩 ning煤n error, salvo que no hace nada. Para poder acceder a la interfaz del m贸dulo, es necesario incluirla en nuestro fichero principal, basta con agregar la directiva #include\u0026quot;display7.h\u0026quot; antes de la funci贸n main, de esta forma el m贸dulo puede ser desarrollado de forma independiente y paralela al programa principal, modifiquemos nuestro .ino para usar la interfaz ``` #include\u0026lt;avr/io.h\u0026gt; #include\u0026quot;display7.h\u0026quot; int main(void) { display7\\_init(); while(1){ display7\\_setNumber(0); \\_delay\\_ms(1000); display7\\_setNumber(1); \\_delay\\_ms(1000); } } ``` pienso que el c贸digo se ve definitivamente m谩s limpio y muestra claramente que se est谩 haciendo, sin embargo si tratamos de compilar nos dar谩 un error, similar a este ``` undefined reference to `display7_init()' ``` en pocas palabras el compilador(en realidad el linker) no encuentra las definiciones del m贸dulo, las definiciones est谩n en el fichero .c, como mencionamos en entradas anteriores, el entorno arduino en realidad compila ficheros c++, pero como somos tercos y queremos programar en c debemos indicarle al compilador que nuestro ficheros no son c++, esto es muy sencillo, basta con a帽adir ``` extern \u0026quot;C\u0026quot; { ``` en el fichero de la interfaz y agregar despu茅s del ultimo prototipo un ``` } ``` el archivo .h queda ``` extern \u0026quot;C\u0026quot; { void display7\\_init(void); void display7\\_setNumber(short number); void display7\\_destroy(void); } ``` Compilamos y esta vez no obtendremos ning煤n error. De esta forma el compilador har谩 lo adecuado para poder usar el m贸dulo, esta soluci贸n sirve para nuestros prop贸sitos, sin embargo en el futuro, desarrollaremos nuestros programas con un compilador de \u0026quot;c\u0026quot;, el compilador no entender谩 la l铆nea extern \u0026quot;C\u0026quot; y nos dar谩 un error, 驴c贸mo hacemos que el m贸dulo funcione con el compilador de c y tambi茅n con el de c++?, nuevamente la soluci贸n es sencilla, cuando usamos un compilador de c++, este pasa una definici贸n, explicitamente ``` #define __cplusplus ``` esto no sucede cuando compilamos con un compilador de c, aprovechando esta definici贸n podemos usar la directiva ``` #ifdef ALGO //si ALGO fue definido, coloca estas lineas #endif ``` modificamos el fichero .h y obtenemos ``` //display7.h #ifdef \\_\\_cplusplus extern \u0026quot;C\u0026quot; { #endif void display7\\_init(void); void display7\\_setNumber(short number); void display7\\_destroy(void); #ifdef \\_\\_cplusplus } #endif ``` este fichero est谩 casi listo, funciona con ambos compiladores, sin embargo tiene un gran problema, 驴qu茅 pasa si por error incluimos m谩s de 1 vez nuestras interfaz?, la respuesta es que nos indicara un error de doble definici贸n, nuevamente nos apoyamos en la directiva #define, de la forma ``` #ifndef MODULO #define MODULO //Aqu铆 las definiciones #endif ``` claramente significa, si no esta definido, define y coloca la interfaz, de lo contrario si ya esta definido no hagas nada, nuestra implementaci贸n queda as铆 ``` //display7.h #ifndef DISPLAY7\\_H #define DISPLAY7\\_H #ifdef \\_\\_cplusplus extern \u0026quot;C\u0026quot; { #endif void display7\\_init(void); void display7\\_setNumber(short number); void display7\\_destroy(void); #ifdef \\_\\_cplusplus } #endif #endif//DISPLAY7\\_H ``` el fichero principal queda as铆 ``` //proyecto.ino #include\u0026lt;avr/io.h\u0026gt; //Necesario para \\_delay\\_ms(), frecuencia de nuestro arduino #define F\\_CPU 16000000UL #include\u0026lt;util/delay.h\u0026gt; //Nos permite usar delay\\_ms() #include\u0026quot;display7.h\u0026quot; int main(void) { display7\\_init(); while(1){ display7\\_setNumber(0); \\_delay\\_ms(1000); display7\\_setNumber(1); \\_delay\\_ms(1000); } } ``` anteriormente olvide las lineas 4 y 5, son necesarias para usar la funci贸n \\_delay\\_ms. Las definiciones est谩n en el fichero .c, debemos agregar la interfaz a este fichero tambi茅n con la directiva #include ``` //display7.c #include\u0026quot;display7.h\u0026quot; void display7\\_init(void) { } void display7\\_setNumber(short number) { } void display7\\_destroy(void) { } ``` En un entorno de desarrollo decente el fichero .c nos hubiera dado problemas pues no esta permitido compilar una implementaci贸n sin indicar a que interfaz pertenece, sin embargo el entorno de arduino nos auto corrige el error, esto es otra cosa por lo que no me gusta arduino, me oculta mis errores. Nuestro c贸digo ahora luce m谩s modular en un diagrama luce as铆 ![](https://eleckia.files.wordpress.com/2020/05/7segmod.png?w=366) Dise帽o en m贸dulo Como se ve en la imagen ahora proyecto.ino (funci贸n main) depende de la interfaz, mientras que display7.c implementa el modulo, dicho de otra forma, proyecto.ino no sabe que hay en display7.c, el solo conoce lo que hay en display7.h, de esta manera podemos reutilizar el m贸dulo en otros m贸dulos, sin miedo a romper el c贸digo fuera de este y muy importante sin tener que reescribir c贸digo extra. Establecido lo anterior, ahora si nos toca implementar el m贸dulo, por supuesto en la siguiente entrada."}),a.add({id:15,href:'/docs/perifericos/gpio/perifericos-atmega328p-puertos-de-entrada-salida-de-proposito-general-gpio-iii-display-siete-segmentos/',title:"Display Siete Segmentos II.",section:"GPIO",content:"Nuestro anterior programa sirve para dos cosas, para nada y para la basura, no hay ninguna diferencia con respecto a conectar los pines del display directamente a Vcc, requerimos funcionalidad, que el microcontrolador haga lo adecuado para mostrar el n煤mero que nosotros indiquemos y que nosotros hagamos el m铆nimo trabajo para indicarlo, algo similar a\nsetNumber(3); //Muestra el n煤mero 3 en el display de esta forma podemos realizar una secuencia de n煤meros\nint main(void) { while(1){ setNumber(0); delay setNumber(1); delay . . . setNumber(9); delay } } el display mostrara los n煤meros del 0 al 9 en orden ascendente, nuestro objetivo entonces es definir la funci贸n setNumber.\nAunque en este problema sencillo podemos programar la soluci贸n de forma monol铆tica(un solo fragmento de c贸digo), es de utilidad desarrollarlo en forma modular, como en la siguiente figura\ndisplay 7 segmentos como m贸dulo\npensar en forma modular tiene grandes ventajas y conforme crece el proyecto se vuelve la 煤nica forma sostenible de escribir c贸digo, la primer gran ventaja es la posibilidad de reutilizar c贸digo, seria absurdo escribir un controlador de 7 segmentos en cada proyecto nuevo, la segunda ventaja es la capacidad de extender el c贸digo ya escrito, la tercer gran ventaja es que el c贸digo es m谩s \u0026ldquo;mantenible\u0026rdquo;, entre muchas otras que se ir谩n comentando.\nPara nuestro prop贸sito un m贸dulo es un ente de software que est谩 aislado, autocontenido y es altamente cohesivo, dicho de otra forma, la funci贸n main no tiene conocimiento de las variables y funciones del m贸dulo, salvo por un conjunto de funciones com煤nmente llamadas interfaz. Una bonita interfaz para nuestro modulo puede ser\nvoid display7_init(void); void display7_setNumber(short number); void display7_destroy(void); elegir buenos nombres es una parte fundamental para que nuestro c贸digo sea de alta calidad, estoy seguro que al leer las funciones anteriores de inmediato formaste una idea de lo que hacen y a que pertenecen. Sin pensarlo hemos llegado a uno de los grandes dogmas de la programaci贸n y de la resoluci贸n de problemas en general, dividimos el problema en problemas m谩s peque帽os, ni tardos ni perezosos modificamos nuestro programa y agregamos el m贸dulo,\n#include\u0026lt;avr/io.h\u0026gt; void display7\\_init(void); void display7\\_setNumber(short number); void display7\\_destroy(void); int main(void) { DDRB |= (1\u0026lt;\u0026lt;PB0); DDRD |= (1\u0026lt;\u0026lt;PD2)|(1\u0026lt;\u0026lt;PD3)|(1\u0026lt;\u0026lt;PD4)| (1\u0026lt;\u0026lt;PD5)|(1\u0026lt;\u0026lt;PD6)|(1\u0026lt;\u0026lt;PD7); PORTB |= (1\u0026lt;\u0026lt;PB0); PORTD |= (1\u0026lt;\u0026lt;PD2)|(1\u0026lt;\u0026lt;PD4)|(1\u0026lt;\u0026lt;PD5)|(1\u0026lt;\u0026lt;PD7); return 0; } void display7\\_init(void) { } void display7\\_setNumber(short number) { } void display7\\_destroy(void) { } este c贸digo compila sin problemas pero no hace el trabajo requerido, al principio agregamos los prototipos del m贸dulo, pero aun no los llamamos en la funci贸n main, tampoco hemos implementado dichas funciones. Antes de definir la interfaz, anteriormente indique que la funci贸n main no tiene conocimiento de las funciones y variables de nuestro m贸dulo, si escribimos el c贸digo en el mismo fichero, el usuario de la funci贸n main tendr谩 a la vista todas las funciones y variables y probablemente tenga la tentaci贸n de usarlas, una buena idea para evitar que esto suceda es utilizar un par de archivos extra exclusivos para nuestro m贸dulo, esto lo veremos en la siguiente entrada.\n"}),a.add({id:16,href:'/docs/avr/programando-avr-en-c-el-flujo-del-programa-if-else-if-else/',title:"Programando Avr en C.- El flujo del programa, if, else, if else.",section:"Programaci贸n Avr en C.",content:"Definimos el flujo del programa como, la ruta que toma la ejecuci贸n del mismo, imaginemos que tenemos una lista de tareas que debemos ejecutar, digamos, tarea 1, tarea 2, tarea 3, \u0026hellip;, tarea n, ya vimos que podemos abstraer tareas como funciones, entonces simplemente podemos agregar cada una de las funciones en orden para ejecutarlas,\nint main(void) { tarea1(); tarea2(); tarea3(); tarean(); return 0; } pero que pasa si queremos ejecutar alguna de estas tareas solo si se cumple una condici贸n, digamos, solo si se pulsa un bot贸n determinado, o solo si el resultado de una operaci贸n satisface alg煤n requerimiento.\nPara ello contamos con la palabra if, si se cumple una condici贸n, el c贸digo dentro de sus llaves se ejecutara, de lo contrario el programa continuara despu茅s de la llave de cierre,\nint main(void) { tarea1(); if(condicion){ //si condici贸n es verdadera tarea2(); //se ejecutaran 茅sta dos tareas tarea3(); } tarea4(); //Aqu铆 continua tarean(); return 0; } tambi茅n es posible agregar la palabra else, para controlar el flujo cuando la condici贸n es falsa\nint main(void) { tarea1(); if(condicion){ //si condici贸n es verdadera tarea2(); //se ejecutara 茅sta tarea }else{ tarea3(); //si condici贸n es falsa, ejecuta 茅sta tarea } tarea4(); tarean(); return 0; } agregar m谩s sentencias nos permite un control aun m谩s preciso.\nint main(void) { tarea1(); if(condicion == 0){ //si condici贸n es igual a 0 tarea2(); //se ejecutara 茅sta tarea }else if(condicion == 1){ tarea3(); //si condici贸n igual a 1, ejecuta 茅sta tarea }else{ tarea4(); //si no se cumple ninguna de las anteriores } tarean(); return 0; } es importante se帽alar que la ejecuci贸n es en orden descendente, si tenemos varios if else y en m谩s de uno se cumple la condici贸n, solo se ejecutara el primero que la cumpla en orden descendente.\nint main(void) { tarea1(); if(true){ tarea2(); //se ejecutara 茅sta tarea }else if(true){ tarea3(); //No se ejecuta }else{ tarea4(); //No se ejecuta } tarean(); //una vez ejecutada tarea2, el programa continua aqu铆 return 0; } "}),a.add({id:17,href:'/docs/avr/programando-avr-en-c-constantes/',title:"Programando Avr en C.- Constantes",section:"Programaci贸n Avr en C.",content:"Las constantes son de gran utilidad en la programaci贸n, a diferencia de las variables, las constantes no pueden cambiar su valor.\nLas dos formas m谩s comunes de definir constantes son con la palabra reservada const y con la directiva define.\nLa palabra const #  Agregando la palabra const a la declaraci贸n de una variable, esta se convierte en constate, sin embargo tambi茅n debe asignarle el valor al momento de la declaraci贸n;\nuint8_t const NUMERO = 10; //Declaraci贸n de una constante NUMERO = 1; //error, no se puede reasignar Sin embargo el uso m谩s cotidiano que tiene la palabra const es en los argumentos de funciones,\nint8_t suma(int8_t const sumando1, int8_t const sumando2); Directiva define #  Entre otras cosas, la directiva define puede ser usada para definir constantes;\n#define NUMERO 10 cuando el programa se compilar, la palabra NUMERO, se reemplaza por el n煤mero 10,\n#define PRIMERO 5 int8_t = 5 + PRIMERO; al compilar, sera reemplazado por\nint8_t = 5 + 5; Enum #  Los enum son un tipo de dato que nos facilit谩 la creaci贸n de colecciones de constantes, su sintaxis es\nenum NOMBRE{CONSTANTE1 = 0, CONSTANTE2, CONSTANTE3 = 5, CONSTANTE4}; de esta forma CONSTANTE1 es una variable de tipo enum NOMBRE y contiene el valor de 0, CONSTANTE2 contiene el valor 1 y CONSTANTE3 tiene el valor de 5 y CONSTANTE4 tiene el valor de 6.\nenum numeros{CERO, UNO, DOS}; a = CERO + UNO + DOS; //a contiene el n煤mero 3 驴Por qu茅 usar constantes? #  Hay dos conceptos al utilizar constantes, ser constante y querer ser constante.\nSer constante se refiere a declarar una constante expl铆citamente por ejemplo el n煤mero PI, SQRT2, etc.\nQuerer ser constante, se refiere a evitar que las variables cambien por accidente su valor, por ejemplo las funciones suele recibir par谩metros constantes, se busca evitar que los par谩metros cambien su valor, esto tomara sentido cuando comentemos los apuntadores en entradas posteriores.\nMuchos lenguajes de programaci贸n nuevos, definen a las variables como constantes (inmutable) y es el usuario quien expl铆citamente declara una variable como variable (mutable), la raz贸n principal como se menciona es reducir la posibilidad de a帽adir errores de programaci贸n.\n"}),a.add({id:18,href:'/docs/avr/programando-avr-en-c-tipo-de-dato-booleano-operadores-booleanos-y-de-comparacion/',title:"Programando Avr en C.- Tipo de dato Booleano, operadores booleanos y de comparaci贸n.",section:"Programaci贸n Avr en C.",content:"Tipo de dato Booleano #  Otro tipo de datos b谩sico es el tipo booleano, este tipo de dato puede contener unicamente dos valores, verdadero(true) o Falso(false), para tener acceso a este tipo de dato debemos incluir la biblioteca stdbool.h, la sintaxis es:\n#include\u0026lt;stdbool.h\u0026gt; //Para declarar una variable bool un\\_nombre; //Para definir un valor un\\_nombre = true; un\\_nombre = false; Es com煤n asumir en C que cualquier valor diferente de cero o NULL es verdadero, sin embargo pienso que es mejor utilizar expl铆citamente los valores true o false para denotar valores booleanos, por razones de legibilidad.\nOperadores booleanos #  Como el nombre sugiere, los operadores booleanos operan sobre tipos de dato booleanos. El operador and(\u0026amp;\u0026amp;) probablemente es el m谩s utilizado,\na \u0026amp;\u0026amp; b el resultado de la operaci贸n previa dar谩 verdadero solo si ambos, a y b son verdaderos, resulta falso de lo contrario. La regla es\nfalse and false //es igual a false true and false //es igual a false false and true //es igual a false true and true //es igual a true El operador or(||)\na || b el resultado de la operaci贸n previa dar谩 verdadero si a o b, o ambos son verdaderos, resulta falso de lo contrario. La regla or es\nfalse or false //es igual a false true or false //es igual a true false or true //es igual a true true or true //es igual a true El operador de negaci贸n (!)\n!a resulta verdadero si a es falso, resulta falso si a es verdadero.\n!false //es igual a true !true //es igual a false Operadores de comparaci贸n #  Los operadores de comparaci贸n, comparan dos expresiones y eval煤an el resultado como falso o verdadero, por ejemplo el operador de igualdad (==)\na = 10; //entero b = 10; //entero c = (a == b); //boleano verdadero d = ((a+1) == b); //驴11 es igual a 10? falso la variable c contendr谩 verdadero, mientras que d sera falso pues 11 no es igual a 10.\notros operadores de comparaci贸n se resumen a continuaci贸n\n==\nIgual que\n!=\nDiferente de\n\u0026lt;\nmenor que\n\u0026gt;\nmayor que\n\u0026lt;=\nmenor o igual que\n\u0026gt;=\nmayor o igual que\n"}),a.add({id:19,href:'/docs/avr/programando-avr-en-c-funciones/',title:"Programando Avr en C.- Funciones",section:"Programaci贸n Avr en C.",content:"Las funciones son caracter铆sticas fundamentales de cualquier lenguaje de programaci贸n, inclusive existe un \u0026ldquo;estilo\u0026rdquo; de programaci贸n llamado programaci贸n funcional, veamos brevemente como funcionan las funciones en C. Una funci贸n tiene la siguiente sintaxis en C,\ntipo_de_retorno nombre_de_funcion(tipo_dato argumento_n) { ... hacer_tareas ... return un_objeto_del_tipo_de_retorno; } las funciones pueden ser usadas como una forma de realizar tareas de manera reiterada, pueden recibir \u0026ldquo;n\u0026rdquo; cantidad de argumentos y retornar un valor, un ejemplo sencillo, definimos la funci贸n suma,\nint8_t suma(int8_t sumando1, int8_t sumando2) { int8_t resultado = sumando1 + sumando2; return resultado; } esta funci贸n simplemente suma los dos argumentos pasados en ella, para usarla se usa la sintaxis:\nint8_t numero = suma(3,2); al ejecutarse, la variable numero contendr谩 el valor de 5, las funciones pueden retornar cualquier tipo de dato, incluso alguno definido por nosotros como veremos en el futuro.\nAhora que sabemos definir funciones sencillas, escribamos un programa sencillo donde la usemos.\n#include\u0026lt;avr/io.h\u0026gt; //No se usar谩 #include\u0026lt;stdint.h\u0026gt; //Para int8\\_t int main(void) { int8\\_t numero = suma(2,3); return 0; } int8\\_t suma(int8\\_t sumando1, int8\\_t sumando2) { int8\\_t resultado = sumando1 + sumando2; return resultado; } Ahora compilamos y nos dar谩 un error o probablemente no, si compilamos este programa con un compilador de C y sin el software de Arduino, nos mostrar un error donde se帽ala que la funci贸n no fue declarada,\nprogram.c: In function int main(): program.c:5:25: error: suma was not declared in this scope int8_t numero = suma(2,3); por definici贸n lo m谩s recomendable es declarar cualquier objeto antes de usarlo, en nuestro c贸digo la funci贸n suma se declara y define al final del fichero, podr铆amos reescribir la funci贸n suma antes de la funci贸n main, esto esta bien para programas peque帽os, sin embargo en programas grandes se vuelve una forma dif铆cil de mantener, una forma m谩s adecuada es usar un prototipo, un prototipo es una forma de declarar una funci贸n sin definirla, la sintaxis es similar a la definici贸n de una funci贸n pero sin llaves y sin cuerpo,\ntipo_de_retorno nombre_de_funcion(tipo_dato argumento_n); en el caso de nuestra funci贸n suma su prototipo es\nint8_t suma(int8_t sumando1, int8_t sumando2); el prototipo debe tener el mismo nombre el mismo tipo de retorno y los mismos tipos de argumentos. Ahora agregando este prototipo antes de la funci贸n main, podemos estar seguros de que no habr谩 un error de compilaci贸n, el compilador se encargara de buscar la definici贸n en el resto del c贸digo.\nArduino usa un compilador de C++ y probablemente no nos muestre ning煤n error, debido a que autogenera los prototipos, personalmente por cuestiones de legibilidad, prefiero definirlos yo mismo.\nEn las siguientes entradas entenderemos las ventajas que se obtiene de esta separaci贸n entre prototipo(declaraci贸n) y la definici贸n. El c贸digo final es el siguiente:\n#include\u0026lt;avr/io.h\u0026gt; //No se usar谩 #include\u0026lt;stdint.h\u0026gt; //Para int8\\_t int8\\_t suma(int8\\_t sumando1, int8\\_t sumando2);//Prototipo int main(void) { int8\\_t numero = suma(2,3);//Llamado a la funci贸n return 0; } //Definici贸n de la funci贸n int8\\_t suma(int8\\_t sumando1, int8\\_t sumando2) { int8\\_t resultado = sumando1 + sumando2; return resultado; } al ejecutarse el programa el valor final de la variable numero sera 5.\n"}),a.add({id:20,href:'/docs/perifericos/gpio/biblioteca7/',title:"Api Display Siete Segmentos",section:"GPIO",content:"Api para un display de siete segmentos #  Escribamos una biblioteca/api sencilla que nos permita configurar un n煤mero en un display de 7 segmentos, el circuito es el siguiente,\nConexi贸n Arduino-Display #  Contamos con un display de c谩todo com煤n por lo tanto cada segmento se enciende con un voltaje alto en el pin correspondiente, es decir para encender el segmento \u0026ldquo;A\u0026rdquo; debemos configurar el pin digital D2 en alto. Evitamos la conexi贸n en los pines D0 y D1, debido a que estos est谩n conectados al convertidor serial-usb, y pueden provocar problemas para subir el c贸digo a la tarjeta.\nComo primer paso debemos incluir la biblioteca \u0026ldquo;avr/io.h\u0026rdquo;, para tener acceso a los puertos de GPIOx de entrada/salida, cuyos registros asociados son DDRx, PORTx, PINx.\n#include\u0026lt;avr/io.h\u0026gt;Ahora declaramos la funci贸n principal, recordemos que la funci贸n principal es llamada autom谩ticamente cuando el programa es ejecutado,\nint main(void) { return 0; } Dentro de las llaves del main configuramos los pines adecuados como salidas, para hacerlo requerimos saber a que pines del microcontrolador corresponden los pines del Arduino,\nfuente:(http://www.chicoree.fr/w/Arduino_sur_ATmega328P)\nEn la anterior imagen observamos la correspondencia entre los pines del Arduino y los del microcontrolador, por ejemplo el pin digital D2 es en realidad el pin PD2 del atmega328p, por ejemplo el pin digital D8 es en realidad el pin PB0 del atmega328p. Configuramos el registro DDRB y DDRD como salidas,\nDDRB |= (1\u0026lt;\u0026lt;PB0); DDRD |= (1\u0026lt;\u0026lt;PD2)|(1\u0026lt;\u0026lt;PD3)|(1\u0026lt;\u0026lt;PD4)| (1\u0026lt;\u0026lt;PD5)|(1\u0026lt;\u0026lt;PD6)|(1\u0026lt;\u0026lt;PD7); Ahora solo encendemos los leds, poniendo en alto los pines requeridos, por ejemplo para el n煤mero cinco, encendemos los segmentos a,c,d,f,g.\nPara ello escribimos a los puertos PORTB y PORTD los pines indicados\nPORTB |= (1\u0026lt;\u0026lt;PB0); PORTD |= (1\u0026lt;\u0026lt;PD2)|(1\u0026lt;\u0026lt;PD4)|(1\u0026lt;\u0026lt;PD5)|(1\u0026lt;\u0026lt;PD7); El c贸digo completo luce como el siguiente,\n#include\u0026lt;avr/io.h\u0026gt; int main(void) { DDRB |= (1\u0026lt;\u0026lt;PB0); DDRD |= (1\u0026lt;\u0026lt;PD2)|(1\u0026lt;\u0026lt;PD3)|(1\u0026lt;\u0026lt;PD4)| (1\u0026lt;\u0026lt;PD5)|(1\u0026lt;\u0026lt;PD6)|(1\u0026lt;\u0026lt;PD7); PORTB |= (1\u0026lt;\u0026lt;PB0); PORTD |= (1\u0026lt;\u0026lt;PD2)|(1\u0026lt;\u0026lt;PD4)|(1\u0026lt;\u0026lt;PD5)|(1\u0026lt;\u0026lt;PD7); return 0; } Compilamos y subimos.\nEl \u0026ldquo;estilo\u0026rdquo; en que hemos escrito nuestro programa es coloquialmente llamado hardcoding, debido a que nosotros especificamos tanto los valores como el flujo, usualmente lo que queremos es que el programa calcule los valores y elija el flujo, imaginemos que ahora requerimos una secuencia de n煤meros en serie, comenzado con 1 y terminando en 9 y repetir esta secuencia 1000 veces, seria un poco tedioso cambiar uno por uno los estados de los segmentos, para evitar este trabajo nos apoyaremos en funciones y sentencias de flujo.\nBiblioteca #  Nuestro anterior programa sirve para dos cosas, para nada y para la basura, no hay ninguna diferencia con respecto a conectar los pines del display directamente a Vcc, requerimos funcionalidad, que el microcontrolador haga lo adecuado para mostrar cualquier n煤mero indicado, con una interfaz del tipo\ndisplay7_showNumber(3); //Muestra el n煤mero 3 en el display de esta forma podemos realizar una secuencia de n煤meros\nint main(void) { while(1){ display7_showNumber(0); //delay  display7_showNumber(1); //delay  . . . display7_showNumber(9); //delay  } } El display mostrara los n煤meros del 0 al 9 en orden ascendente, nuestro objetivo entonces es definir la funci贸n display7_showNumber(short const number).\nAunque en este problema sencillo podemos programar la soluci贸n de forma monol铆tica(un solo fragmento de c贸digo), es de utilidad desarrollarlo en forma modular, como en la siguiente figura\nDe tal forma que podemos utilizarla dentro de nuestra aplicaci贸n con un simple include, pensar en forma modular tiene grandes ventajas y conforme crece el proyecto se vuelve la 煤nica forma sostenible de escribir c贸digo, la primer gran ventaja es la posibilidad de reutilizar c贸digo, seria absurdo escribir un controlador de 7 segmentos en cada proyecto nuevo, la segunda ventaja es la capacidad de extender el c贸digo ya escrito, la tercer gran ventaja es que el c贸digo es m谩s \u0026ldquo;mantenible\u0026rdquo;, entre muchas otras que se ir谩n comentando.\nPara nuestro prop贸sito un m贸dulo es un ente de software que est谩 d茅bilmente acoplado, autocontenido y es altamente cohesivo, dicho de otra forma, la funci贸n main no tiene conocimiento de las variables y funciones del m贸dulo, salvo por un conjunto de funciones com煤nmente llamadas interfaz. Una bonita interfaz para nuestro modulo puede ser\nvoid display7_init(void); void display7_showNumber(short const number); void display7_destroy(void); Elegir buenos nombres es una parte fundamental para que nuestro c贸digo sea de alta calidad, estoy seguro que al leer las funciones anteriores de inmediato formaste una idea de lo que hacen y a que pertenecen. Sin pensarlo hemos llegado a uno de los grandes dogmas de la programaci贸n y de la resoluci贸n de problemas en general,\nDivide el problema en problemas m谩s peque帽os\nNi tardos ni perezosos modificamos nuestro programa y agregamos el m贸dulo,\n#include\u0026lt;avr/io.h\u0026gt; void display7_init(void); void display7_showNumber(short number); void display7_destroy(void); int main(void) { DDRB |= (1\u0026lt;\u0026lt;PB0); DDRD |= (1\u0026lt;\u0026lt;PD2)|(1\u0026lt;\u0026lt;PD3)|(1\u0026lt;\u0026lt;PD4)| (1\u0026lt;\u0026lt;PD5)|(1\u0026lt;\u0026lt;PD6)|(1\u0026lt;\u0026lt;PD7); PORTB |= (1\u0026lt;\u0026lt;PB0); PORTD |= (1\u0026lt;\u0026lt;PD2)|(1\u0026lt;\u0026lt;PD4)|(1\u0026lt;\u0026lt;PD5)|(1\u0026lt;\u0026lt;PD7); return 0; } void display7_init(void) { } void display7_showNumber(short number) { } void display7_destroy(void) { } Este c贸digo compila sin problemas pero no hace el trabajo requerido, al principio agregamos los prototipos del m贸dulo, pero aun no los llamamos en la funci贸n main, tampoco hemos implementado dichas funciones. Antes de definir la interfaz, anteriormente indique que la funci贸n main no tiene conocimiento de las funciones y variables de nuestro m贸dulo, si escribimos el c贸digo en el mismo fichero, el usuario de la funci贸n main tendr谩 a la vista todas las funciones y variables y probablemente tenga la tentaci贸n de usarlas, una buena idea para evitar que esto suceda es utilizar un par de archivos extra exclusivos para nuestro m贸dulo.\nCrear la biblioteca #  No se si ya lo hab铆a mencionado pero odio el entorno de desarrollo de Arduino, en esta ocasi贸n por la forma tan pobre de manejar ficheros. Continuando, vamos a mover nuestro m贸dulo en un par de archivos, creamos dos ficheros cuyo nombre deje en claro que hay escrito en 茅l, un buen nombre es display7,\n$touch display7.c $touch display7.h Ahora en nuestro entorno de desarrollo incluimos los dos ficheros, para ello vamos al men煤 Programa-\u0026gt;A帽adir fichero y a帽adimos ambos ficheros, ambos aparecer谩n en nuestro entorno de desarrollo y podr谩n ser editados desde el mismo, movemos desde el fichero principal el m贸dulo hacia los nuevos ficheros, los prototipos van en 茅l .h y las definiciones al .c, de esta manera tenemos los tres ficheros siguientes\n//proyecto.ino #include\u0026lt;avr/io.h\u0026gt;int main(void) { DDRB |= (1\u0026lt;\u0026lt;PB0); DDRD |= (1\u0026lt;\u0026lt;PD2)|(1\u0026lt;\u0026lt;PD3)|(1\u0026lt;\u0026lt;PD4)| (1\u0026lt;\u0026lt;PD5)|(1\u0026lt;\u0026lt;PD6)|(1\u0026lt;\u0026lt;PD7); PORTB |= (1\u0026lt;\u0026lt;PB0); PORTD |= (1\u0026lt;\u0026lt;PD2)|(1\u0026lt;\u0026lt;PD4)|(1\u0026lt;\u0026lt;PD5)|(1\u0026lt;\u0026lt;PD7); return 0; } //display7.h void display7_init(void); void display7_showNumber(short number); void display7_destroy(void); //display7.c void display7_init(void) { } void display7_showNumber(short number) { } void display7_destroy(void) { } Nuevamente compilamos el programa y no nos dar谩 ning煤n error, salvo el peque帽o detalle de que no hace nada. Para poder acceder a la interfaz del m贸dulo, es necesario incluirla en nuestro fichero principal, basta con agregar la directiva #include\u0026quot;display7.h\u0026quot; antes de la funci贸n main, de esta forma el m贸dulo puede ser desarrollado de forma independiente y paralela al programa principal, modifiquemos nuestro .ino para usar la interfaz\n#include\u0026lt;utils/delay.h\u0026gt;#include\u0026#34;display7.h\u0026#34; int main(void) { display7_init(); while(1){ display7_showNumber(0); _delay_ms(1000); display7_showNumber(1); _delay_ms(1000); } } Pienso que el c贸digo se ve definitivamente m谩s limpio y muestra claramente que se est谩 haciendo, sin embargo si tratamos de compilar nos dar谩 un error, similar a este\nundefined reference to `display7_init()\u0026#39; En pocas palabras el compilador (en realidad el linker) no encuentra las definiciones del m贸dulo, las definiciones est谩n en el fichero .c, como mencionamos en entradas anteriores, el entorno Arduino en realidad compila ficheros C++, pero como somos tercos y queremos programar en c debemos indicarle al compilador que nuestro ficheros no son C++, esto es muy sencillo, basta con a帽adir\nextern \u0026#34;C\u0026#34; { En el fichero .h donde est谩n los prototipos y cerrar despu茅s del ultimo prototipo con un\n} El archivo .h queda\nextern \u0026#34;C\u0026#34; { void display7_init(void); void display7_showNumber(short const number); void display7_destroy(void); } Compilamos y esta vez no obtendremos ning煤n error. De esta forma el compilador har谩 lo adecuado para poder usar el m贸dulo, la soluci贸n sirve para nuestros prop贸sitos, sin embargo en el futuro, desarrollaremos nuestros programas con un compilador de \u0026ldquo;c\u0026rdquo;, el compilador no entender谩 la l铆nea extern \u0026ldquo;C\u0026rdquo; y nos dar谩 un error, 驴c贸mo hacemos que el m贸dulo funcione con el compilador de C y tambi茅n con el de c++?, nuevamente la soluci贸n es sencilla, cuando usamos un compilador de C++, este pasa una definici贸n, explicitamente\n#define __cplusplus lo anterior no sucede cuando compilamos con un compilador de C, aprovechando esta definici贸n podemos usar la directiva\n#ifdef ALGO  //si ALGO fue definido, coloca estas lineas #endif Modificamos el fichero .h y escribimos\n//display7.h #ifdef __cplusplus extern \u0026#34;C\u0026#34; { #endif  void display7_init(void); void display7_showNumber(short const number); void display7_destroy(void); #ifdef __cplusplus } #endif El fichero est谩 casi listo, funciona con ambos compiladores, sin embargo tiene un gran problema, 驴qu茅 pasa si por error incluimos m谩s de una vez nuestras interfaz?, la respuesta es que nos indicara un error de doble declaraci贸n, nuevamente nos apoyamos en la directiva #define, de la forma\n#ifndef MODULO #define MODULO  //Aqu铆 las definiciones  #endif Significa, si no esta definido, define y coloca la interfaz, de lo contrario si ya esta definido no hagas nada, nuestra implementaci贸n queda as铆\n//display7.h #ifndef DISPLAY7_H #define DISPLAY7_H  #ifdef __cplusplus extern \u0026#34;C\u0026#34; { #endif  void display7_init(void); void display7_showNumber(short number); void display7_destroy(void); #ifdef __cplusplus } #endif #endif//DISPLAY7_H El fichero principal queda as铆\n//proyecto.ino //Necesario para _delay_ms(), frecuencia de nuestro arduino #define F_CPU 16000000UL #include\u0026lt;util/delay.h\u0026gt; //Nos permite usar delay_ms()#include\u0026#34;display7.h\u0026#34; int main(void) { display7_init(); while(1){ display7_showNumber(0); _delay_ms(1000); display7_showNumber(1); _delay_ms(1000); } } Las definiciones est谩n en el fichero .c, debemos agregar la interfaz a este fichero tambi茅n con la directiva #include\n//display7.c #include\u0026#34;display7.h\u0026#34;void display7_init(void) { } void display7_showNumber(short const number) { } void display7_destroy(void) { } En un entorno de desarrollo decente el fichero .c nos hubiera dado problemas pues no esta permitido compilar una implementaci贸n sin indicar a que interfaz pertenece, sin embargo el entorno de Arduino nos auto corrige el error, esto es otra cosa por lo que no me gusta Arduino, me oculta mis errores. Nuestro c贸digo ahora luce m谩s modular en un diagrama luce as铆\nComo se ve en la imagen ahora proyecto.ino (funci贸n main) depende de la interfaz, mientras que display7.c la implementa, dicho de otra forma, proyecto.ino no sabe que hay en display7.c, el solo conoce lo que hay en display7.h, de esta manera podemos reutilizar el m贸dulo en otros m贸dulos, sin miedo a romper el c贸digo fuera de 茅ste y muy importante sin tener que reescribir c贸digo extra.\nEstablecido lo anterior, ahora si nos toca implementar el m贸dulo.\nImplementando la biblioteca #  Nuestro trabajo consiste en implementar las funciones del m贸dulo contamos con un par de funciones, una para iniciar y otra para cerrar el m贸dulo y una tercera para mostrar el n煤mero, la interfaz es muy sencilla y para nuestro prop贸sito es m谩s que suficiente. Algo que olvide mencionar y que es importante, la interfaz del m贸dulo evoluciona, pues el desarrollo mismo provee realimentaci贸n importante.\nEs muy com煤n que los m贸dulos contengan dos funciones, init y close o create y destroy, el trabajo de estas dos funciones es llevar al m贸dulo a un estado conocido y liberar los recursos respectivamente. Para el m贸dulo display7 ambas funciones son simples.\nEn la funci贸n destroy, los recursos que se pueden liberar son los puertos y los pines, sin embargo en este caso es de poca utilidad, pues aunque liberemos los recursos nadie puede usarlos, esto no quiere decir que la funci贸n destroy siempre sera tan simple, en m贸dulos m谩s complejos tiene una importancia fundamental sobre todo la utilizar memoria din谩mica.\nLa funci贸n init tiene la misi贸n de establecer las condiciones adecuadas para que el resto del m贸dulo pueda hacer su trabajo, modificara los registros de los puertos para establecerlos como salidas y con nivel bajo. Por ahora sabemos la correspondencia de los pines, pero 驴qu茅 pasa si los encargados del hardware deciden cambiar alguno o todos los pines?, m谩s adelante veremos este escenario.\nIniciemos tratando de configurar los primeros pines, corresponde PD2 y PD3, como salida y en bajo nivel\n//display7.c #include \u0026#34;display7.h\u0026#34;#include \u0026lt;avr/io.h\u0026gt; void display7_init(void) { short pin = PD2; DDRD |= (1\u0026lt;\u0026lt;pin); PORTD \u0026amp;= ~(1\u0026lt;\u0026lt;pin); pin = PD3; DDRD |= (1\u0026lt;\u0026lt;pin); PORTD \u0026amp;= ~(1\u0026lt;\u0026lt;pin); } void display7_destroy(void) { } void display7_showNumber(short number) { } Excelente funciona para los dos, pero las dos asignaciones son pr谩cticamente id茅nticas, en la programaci贸n la duplicaci贸n de ideas debe evitarse pues es una fuente de errores. Se propone crear una funci贸n que nos ayude a evitar la repetici贸n.\n//display7.c #include \u0026#34;display7.h\u0026#34;#include \u0026lt;avr/io.h\u0026gt; static void setPinOutputAndLow(short const pin); void display7_init(void) { setPinOutputAndLow(PD2); setPinOutputAndLow(PD3); } static void setPinOutputAndLow(short const pin) { DDRD |= (1\u0026lt;\u0026lt;pin); PORTD \u0026amp;= ~(1\u0026lt;\u0026lt;pin); } void display7_destroy(void) { } void display7_showNumber(short const number) { } Mucho mejor, 驴pero que pasa con el pin que pertenece al puerto B?, lo primero que requerimos es pasar el puerto como argumento de la funci贸n setPinOutputAndLow, pues los nemot茅cnicos Pxn no son m谩s que enteros entre 0 y 7, lo segundo es establecer una relaci贸n entre los pines y los puertos, podemos hacer un arreglo bidimensional del tama帽o de los pines y en cada entrada asignar pin y puerto,\n//display7.c #include \u0026#34;display7.h\u0026#34;#include \u0026lt;avr/io.h\u0026gt; short pines_display[7] = { 4, 5, 6, 11, 12, 13, 14 }; typedef enum{PORT_B, PORT_C, PORT_D}PORT; short const pines_table[28][2] = { {PC6, PORT_C}, /* pin 1*/ {PD0, PORT_D}, {PD1, PORT_D}, {PD2, PORT_D}, {PD3, PORT_D}, {PD4, PORT_D}, {-1, -1}, {-1, -1}, {PB6, PORT_B}, {PB7, PORT_B}, {PD5, PORT_D}, {PD6, PORT_D}, {PD7, PORT_D}, {PB0, PORT_B}, /*pin 14*/ {PB1, PORT_B}, /*pin 15*/ {PB2, PORT_B}, {PB3, PORT_B}, {PB4, PORT_B}, {PB5, PORT_B}, {-1, -1}, {-1, -1}, {-1, -1}, {PC0, PORT_C}, {PC1, PORT_C}, {PC2, PORT_C}, {PC3, PORT_C}, {PC4, PORT_C}, {PC5, PORT_C}, /*pin 28*/ }; static void setPinOutputAndLow(short const pin, PORT); void display7_init(void) { short pin = pines_table[3][0]; PORT port = pines_table[3][1]; setPinOutputAndLow(pin, port); pin = pines_table[4][0]; port = pines_table[4][1]; setPinOutputAndLow(pin, port); pin = pines_table[13][0]; port = pines_table[13][1]; setPinOutputAndLow(pin, port); } static void setPinOutputAndLow(short const pin, PORT port) { if(port == PORT_D){ DDRD |= (1\u0026lt;\u0026lt;pin); PORTD \u0026amp;= ~(1\u0026lt;\u0026lt;pin); }else if(port == PORT_B){ DDRB |= (1\u0026lt;\u0026lt;pin); PORTB \u0026amp;= ~(1\u0026lt;\u0026lt;pin); } } void display7_destroy(void) { } void display7_showNumber(short const number) { } Requerimos indicar los pines como salida y establecerlos a nivel bajo, solo tenemos una lista del numero de los pines, requerimos una funcionalidad para que nos indique a que puerto y pin corresponden, o mejor aun, desarrollar un nuevo m贸dulo que se encargue de inicializar los pines, intentemos inicializar el primer pin\n//display7.c #include \u0026#34;display7.h\u0026#34;#include \u0026lt;avr/io.h\u0026gt; void display7_init(void) { DDRD |= (1\u0026lt;\u0026lt;pines_display[0]); PORTD |= (1\u0026lt;\u0026lt;pines_display[0]); } void display7_destroy(void) { } void display7_showNumber(short number) { } Hay modificaciones necesarias para el c贸digo anterior, lo comentare al final. La tarea de la funci贸n showNumber, es modificar un n煤mero decimal entre 0 y 9 de tal forma que se vea reflejado en el display, la siguiente es la implementaci贸n m谩s sencilla de la cual har茅 algunos comentarios.\nvoid display7\\_showNumber(short number) { if(number == 0){ PORTB \u0026amp;= ~(1\u0026lt;\u0026lt;PB0); //LED G apagado PORTD |= (1\u0026lt;\u0026lt;PD2)|(1\u0026lt;\u0026lt;PD3)|(1\u0026lt;\u0026lt;PD4)| (1\u0026lt;\u0026lt;PD5)|(1\u0026lt;\u0026lt;PD6)|(1\u0026lt;\u0026lt;PD7); }else if(number == 1){ PORTB \u0026amp;= ~(1\u0026lt;\u0026lt;PB0); PORTD \u0026amp;= ~((1\u0026lt;\u0026lt;PD2)| (1\u0026lt;\u0026lt;PD5)|(1\u0026lt;\u0026lt;PD6)|(1\u0026lt;\u0026lt;PD7)); PORTD |= (1\u0026lt;\u0026lt;PD3)|(1\u0026lt;\u0026lt;PD4);//LED B y C encendido } //... hasta number == 9 } Un dogma muy importante en el mundo de la programaci贸n especifica que, la repetici贸n de c贸digo es la mayor fuente de errores, con forme vamos agregando casos a la funci贸n showNumber vamos aumentando las posibilidades de equivocarnos, vale la pena suspender el desarrollo en aras de refactorizar lo que ya tenemos. Refactorizar es un gran tema que podr铆a entenderse como pulir el c贸digo, como primer paso vamos a reescribir esos horribles operandos OR, sabemos que PB0 corresponde al led G por el esquem谩tico, es m谩s eficiente que el propio c贸digo exprese a donde pertenece,\n#define led_A (1\u0026lt;\u0026lt;PD2) #define led_B (1\u0026lt;\u0026lt;PD3) #define led_C (1\u0026lt;\u0026lt;PD4) #define led_D (1\u0026lt;\u0026lt;PD5) #define led_E (1\u0026lt;\u0026lt;PD6) #define led_F (1\u0026lt;\u0026lt;PD7) #define led_G (1\u0026lt;\u0026lt;PB0) de esta forma el c贸digo luce m谩s expresivo\n//display7.c #include\u0026quot;display7.h\u0026quot; #include\u0026lt;avr/io.h\u0026gt; #define led\\_A (1\u0026lt;\u0026lt;PD2) #define led\\_B (1\u0026lt;\u0026lt;PD3) #define led\\_C (1\u0026lt;\u0026lt;PD4) #define led\\_D (1\u0026lt;\u0026lt;PD5) #define led\\_E (1\u0026lt;\u0026lt;PD6) #define led\\_F (1\u0026lt;\u0026lt;PD7) #define led\\_G (1\u0026lt;\u0026lt;PB2) void display7\\_init(void) { //pinout como salidas DDRB |= led\\_G; DDRD |= led\\_A|led\\_B|led\\_C| led\\_D|led\\_E|led\\_F; //pinout nivel bajo PORTB \u0026amp;= ~led\\_G; PORTD \u0026amp;= ~(led\\_A|led\\_B|led\\_C| led\\_D|led\\_E|led\\_F); } void display7\\_destroy(void) { //pinout como entradas DDRB \u0026amp;= ~led\\_G; DDRD \u0026amp;= ~(led\\_A|led\\_B|led\\_C| led\\_D|led\\_E|led\\_F); //pinout nivel bajo PORTB \u0026amp;= ~led\\_G; PORTD \u0026amp;= ~(led\\_A|led\\_B|led\\_C| led\\_D|led\\_E|led\\_F); } void display7\\_showNumber(short number) { if(number == 0){ PORTB \u0026amp;= ~led\\_G; //LED G apagado PORTD |= led\\_A|led\\_B|led\\_C| led\\_D|led\\_E|led\\_F; }else if(number == 1){ PORTB \u0026amp;= ~led\\_G; PORTD \u0026amp;= ~(led\\_A| led\\_D|led\\_E|led\\_F); PORTD |= led\\_B|led\\_C;//LED B y C encendido } //... hasta number == 9 } sin embargo se ve algo cr铆ptico y no muestra por si solo las intenciones de cada funci贸n. Haremos uso de funciones auxiliares, para ayudarnos a reducir el c贸digo repetido y ser m谩s expresivo. De inmediato identificamos que la funci贸n init esta compuesta de dos partes, establecer los pines como salidas y establecer los niveles en bajo, podemos refactorizar utilizando dos funciones auxiliares de la forma\nvoid display7_init(void) { pinoutAsOutputs(); pinoutLowLevel(); } de esta forma es sencillo ver la intensi贸n de la funci贸n init, para hacer valido el c贸digo colocamos ambas implementaciones antes de la funci贸n init\nstatic void pinoutAsOutputs(void) { //pinout como salidas DDRB |= led_G; DDRD |= led_A|led_B|led_C| led_D|led_E|led_F; } static void pinoutLowLevel(void) { //pinout nivel bajo PORTB \u0026amp;= ~led_G; PORTD \u0026amp;= ~(led_A|led_B|led_C| led_D|led_E|led_F); } void display7_init(void) { pinoutAsOutputs(); pinoutLowLevel(); } La palabra static(cuidado static tiene otros usos en otros contextos) sirve para indicar que las funciones 煤nicamente pueden ser llamadas desde el mismo archivo, en este caso display7.c, en el futuro har茅 una entrada especifica sobre el alcance(scope).\nLogramos un poco de legibilidad, pero tambi茅n importante es que evitamos la repetici贸n de c贸digo, 驴en donde?, hay que mirar la funci贸n destroy, que puede ser refactorizada como\nvoid display7_destroy(void) { pinoutAsInputs(); pinoutLowLevel(); } pinoutLowLevel ya la implementamos, solo queda implementar pinoutAsInputs,\nstatic void pinoutAsOutputs(void) { //pinout como salidas DDRB |= led_G; DDRD |= led_A|led_B|led_C| led_D|led_E|led_F; } static pinoutAsInputs(void) { //pinout como entradas DDRB \u0026amp;= ~led_G; DDRD \u0026amp;= ~(led_A|led_B|led_C| led_D|led_E|led_F); } static void pinoutLowLevel(void) { //pinout nivel bajo PORTB \u0026amp;= ~led_G; PORTD \u0026amp;= ~(led_A|led_B|led_C| led_D|led_E|led_F); } void display7_init(void) { pinoutAsOutputs(); pinoutLowLevel(); } void display7_destroy(void) { pinoutAsInputs(); pinoutLowLevel(); } aun le falta al c贸digo, pero ya comienza a verse la forma. M谩s refactorizaci贸n en la siguiente entrada.\n"}),a.add({id:21,href:'/posts/electronica-basica-display-de-7-segmentos/',title:"Electr贸nica b谩sica.- Display de 7 segmentos.",section:"Posts",content:"Un display de 7 segmentos es un arreglo de leds distribuidos de una manera determinada, 8 leds en total, el display de 7 segmentos tiene el prop贸sito de mostrar caracteres, usualmente n煤meros pero tambi茅n puede mostrar letras.\nDisplay 7 segmentos\nel circuito equivalente es muy sencillo,\nC谩todo com煤n\nesta configuraci贸n es llamada c谩todo com煤n, puesto que el c谩todo de todos los diodos est谩 en corto circuito, es una buena caracter铆stica pues tenemos un solo pin para todos los c谩todos y podemos usar un solo cable para la conexi贸n en lugar de ocho.\nnodo com煤n\nLa configuraci贸n de 谩nodo com煤n es similar a la de c谩todo com煤n salvo que los 谩nodos son los que est谩n conectados en corto.\nEl dispositivo cuenta con nueve terminales (aveces diez, dos dedicadas para el com煤n) una para el com煤n y el resto para los ocho leds, para el c谩todo com煤n; la terminal com煤n se conecta a tierra y los leds se encienden con voltaje alto, por el contrario para el 谩nodo com煤n; la terminal com煤n se conecta a Vcc y los leds se encienden con voltaje bajo.\nCada terminal es simplemente un led, por lo tanto para usarlo debemos agregar una resistencia para limitar la corriente, para nuestro atmega328p; resistencias para cada led de 330 $latex \\Omega$ o un poco mayores son suficientes. Cada led sera alimentado por 10[mA], si todos los leds se encienden al mismo tiempo, en total tenemos 80[mA], por lo que nuestro microcontrolador puede manejarlos sin problema, recordemos que la corriente m谩xima provista por el microcontrolador es de 200[mA] por todos los pines y 40[mA] en cada pin.\n"}),a.add({id:22,href:'/posts/electronica-basica-led-y-su-resistencia/',title:"Electr贸nica b谩sica.- Led y su resistencia.",section:"Posts",content:"La ley de Ohm es una herramienta fundamental en la electr贸nica, en esta ocasi贸n vamos a calcular la resistencia adecuada para que un diodo pueda operar de forma segura.\nAntes que nada definamos que es un diodo, sin entrar en detalles, un diodo es un dispositivo que permite el flujo de corriente en una sola direcci贸n, cuenta con dos terminales, el 谩nodo y el c谩todo, la regla es que si se conecta un voltaje alto al 谩nodo y uno bajo al c谩todo, entonces fluye corriente, esta operaci贸n del diodo se conoce como polarizaci贸n directa, si se invierten las conexiones se dice que el diodo esta polarizado en inversa y no fluye corriente. Un circuito simple se muestra en la figura,\nCircuito con Diodo\nAhora reemplazamos el diodo por su circuito equivalente,\nDiodo en Directa\nLa resistencia \u0026ldquo;interna\u0026rdquo; del diodo es muy peque帽a por lo que podemos despreciarla, no debemos olvidar que este circuito es un modelo, el modelo funciona bien porque representa el comportamiento del diodo, no significa que dentro del diodo exista una resistencia y una fuente de voltaje, el valor de la fuente de voltaje varia de diodo a diodo, debemos verificar la hoja de datos para ver que voltaje tiene el diodo en cuesti贸n, en algunos casos el voltaje es peque帽o comparado con el resto de voltajes y simplemente se desprecia, modelandolo como un simple corto circuito.\nEn el caso de la polarizaci贸n inversa el circuito es aun m谩s simple\nDiodo en Inversa\nes un circuito abierto y no hay circulaci贸n de corriente.\nLed. #  Un led es un diodo que tiene la capacidad de emitir luz, el voltaje del diodo led es mayor que el voltaje de otro tipo de diodos, siendo el rojo el mas peque帽o alrededor de 1.8 [V] y el azul el m谩s grande alrededor de 4.8 [V], esto para leds de 5mm, sin embargo esto valores cambian seg煤n el tama帽o del led, lo mejor es revisar en la hoja de datos del diodo en cuesti贸n.\nUn led generalmente se acompa帽a de una resistencia conectada en serie, 驴para qu茅?, la respuesta es simple, para limitar su corriente, entendamos que es un corto circuito.\nPartiendo del circuito anterior, tenemos una fuente en serie con una resistencia, recordemos que la corriente es\n$latex i = \\frac{V}{R}$\nun corto se entiende como una conexi贸n el茅ctrica de cero resistencia entre dos terminales. De esta forma los puntos A y B en el esquema est谩n en corto, dicho de otra manera no hay resistencia entre ellos, esto implica que la corriente puede fluir totalmente entre estos dos puntos, Las terminales C y D no est谩n en corto pues hay una resistencia entre ellas, 驴que pasar铆a si quitamos la resistencia?, pues tendr铆amos a las terminales C y D en corto y las consecuencias serian desastrosas. de la ley de Ohm tenemos $latex i = \\frac{V}{0} = \\infty$, las fuentes no pueden otorgar energ铆a infinita, est谩n dise帽ada para dar una corriente especifica, si se sobrepasa el limite se da帽aran, es por eso que nunca debes juntar las terminales de una fuente.\nRegresando a nuestro diodo led, 驴qu茅 pasar铆a si no colocamos una resistencia entre el diodo y la fuente?,\nDiodo en corto\ncomo dijimos la resistencia del modelo del diodo es muy peque帽a por lo tanto la fuente y el diodo est谩n pr谩cticamente en corto, es decir fluir谩 una gran cantidad de corriente desde la fuente hacia el diodo, si se tiene suerte el diodo se quemara y se abrir谩 el circuito, si tienes un mal d铆a tu fuente se da帽ara tambi茅n, los diodos est谩n fabricados para trabajar a un cierta corriente, en el caso de los diodos peque帽os de 5mm la corriente suele estar alrededor de los 10[mA], en el caso de los diodos led de iluminaci贸n es com煤n encontrar corrientes de 300[mA]. Calculemos r谩pidamente la resistencia de un led de 5mm rojo de 1.8[V] y 10[mA], que se desea conectar a una fuente de 5[V]. El circuito es el siguiente.\nde la ley de Ohm\n$latex V = Ri$\ndividiendo ambos lados entre la corriente\n$latex \\frac{V}{i} = R \\frac{i}{i} = R$\npara la resistencia R\n$latex R = \\frac{V_R}{i}$\ny la aplicamos a la resistencia R, recordemos que la corriente es un flujo, por lo tanto la corriente que pasa por la resistencia es la misma que pasa por el led, sabemos que el voltaje en la terminal positiva de la resistencia es 5V y el voltaje en la terminal negativa de la resistencia es 1.8V (estamos despreciando la resistencia interna del diodo), por lo tanto el voltaje que hay entre las terminales de la resistencia R es\n$latex V_R = (5 - 1.8) [V] = 3.2[V]$\nsabemos que la corriente de operaci贸n del led es de 10[mA], por lo tanto la resistencia adecuada debe ser\n$latex R = \\frac{3.2[V]}{10[mA]} = \\frac{3.2[V]}{0.010[A]} = 320 \\Omega$\nla resistencia comercial m谩s cercana es de 330 Ohms, usaremos esa, la corriente disminuir谩 una cantidad marginal.\n驴Y si quiero a帽adir un led adicional a la misma fuente?, podemos a帽adir el led de forma paralela al led ya existen y recalcular la resistencia.\nLeds en paralelo\nEl c谩lculo es id茅ntico salvo que ahora la corriente es el doble, pues se requiere satisfacer la corriente de cada diodo $latex i = i_{D1} + i_{D2} = 20[mA]$, la resistencia necesaria es $latex R = 160 \\Omega$, el problema es que la resistencia disipara m谩s potencia, que significa que se calentara m谩s. Un m茅todo m谩s recomendado es conectar una segunda rama (con diodo y resistencia incluidos), en paralelo a la fuente,\nDiodos con resistencia en paralelo\nde esta forma las dos resistencias son iguales a 330 Ohms. Podemos conectar tantas ramas en paralelo como deseemos, el limite es la capacidad de corriente de nuestra fuente, hay que recordar que el limite de un pin del atmega328p es de 40[mA].\n"}),a.add({id:23,href:'/posts/bloque-reutilizable-sin-titulo-2/',title:"res",section:"Posts",content:"La ley de Ohm es una herramienta fundamental en la electr贸nica, en esta ocasi贸n vamos a calcular la resistencia adecuada para que un diodo pueda operar de forma segura.\nAntes que nada definamos que es un diodo, sin entrar en detalles, un diodo es un dispositivo que permite el flujo de corriente en una sola direcci贸n, cuenta con dos terminales, el 谩nodo y c谩todo, la regla es que si se conecta un voltaje alto al 谩nodo y uno bajo al c谩todo, entonces fluye corriente, esta operaci贸n del diodo se conoce como polarizaci贸n directa, si se invierten las conexiones se dice que el diodo esta polarizado en inversa y no fluye corriente. Un circuito simple se muestra en la figura,\nCircuito con Diodo\nAhora reemplazamos el diodo por su circuito equivalente,\nDiodo en Directa\nLa resistencia \u0026ldquo;interna\u0026rdquo; del diodo es muy peque帽a por lo que podemos despreciarla, no debemos olvidar que este circuito es un modelo, este modelo funciona bien porque representa el comportamiento del diodo, no significa que dentro del diodo exista una resistencia y una fuente de voltaje, el valor de la fuente de voltaje varia de diodo a diodo, debemos verificar la hoja de datos para ver que voltaje tiene el diodo en cuesti贸n, en algunos casos el voltaje es peque帽o comparado con el resto de voltajes y simplemente se desprecia, modelando el diodo como un simple corto circuito.\nEn el caso de la polarizaci贸n inversa el circuito es aun m谩s simple\nDiodo en Inversa\nes un circuito y no hay circulaci贸n de corriente.\nLed. #  Un led es un diodo que tiene la capacidad de emitir luz, el voltaje del diodo led es mayor que el voltaje de otro tipo de diodos, siendo el rojo el mas peque帽o alrededor de 1.8 [V] y el azul el m谩s grande alrededor de 4.8 [V], esto para leds de 5mm, sin embargo esto valores cambian seg煤n el tama帽o del led, lo mejor es revisar en la hoja de datos del diodo en cuesti贸n.\nUn led generalmente se acompa帽a de una resistencia conectada en serie, 驴para qu茅?, la respuesta es simple, para limitar su corriente, entendamos que es un corto circuito.\nPartiendo del circuito anterior, tenemos una fuente en serie con una resistencia, recordemos que la corriente es\n$latex i = \\frac{V}{R}$\nun corto se entiende como una conexi贸n el茅ctrica de cero resistencia entre dos terminales. De esta forma los puntos A y B en el esquema est谩n en corto, dicho de otra manera no hay resistencia entre ellos, esto implica que la corriente puede fluir totalmente entre estos dos puntos, Las terminales C y D no est谩n en corto pues hay una resistencia entre ellas, 驴que pasar铆a si quitamos la resistencia?, pues tendr铆amos a las terminales C y D en corto y las consecuencias serian desastrosas. de la ley de Ohm tenemos $latex i = \\frac{V}{0} = \\infty$, las fuentes no pueden otorgar energ铆a infinita, est谩n dise帽ada para dar una corriente establecida de corriente, si se sobrepasa el limite se da帽aran, es por eso que nunca debes juntar las terminales de una fuente.\nRegresando a nuestro diodo led, 驴qu茅 pasar铆a si no colocamos una resistencia entre el diodo y la fuente?,\nDiodo en corto\ncomo dijimos la resistencia del modelo del diodo es muy peque帽a por lo tanto la fuente y el diodo est谩n en corto, es decir fluir谩 una gran cantidad de corriente desde la fuente hacia el diodo, si se tiene suerte el diodo se quemara y se abrir谩 el circuito, si tienes un mal d铆a tu fuente se da帽ara tambi茅n, los diodos est谩n fabricados para trabajar a un cierta corriente, en el caso de los diodos peque帽os de 5mm la corriente suele estar alrededor de los 10[mA], en el caso de los diodos led de iluminaci贸n es com煤n encontrar corrientes de 300[mA]. Calculemos r谩pidamente la resistencia de un led de 5mm rojo de 1.8[V] y 10[mA], que se desea conectar a una fuente de 5[V]. El circuito es el siguiente.\nde la ley de Ohm despejando la resistencia se tiene\n$latex R = \\frac{V_R}{i}$\ny la aplicamos a la resistencia R, recordemos que la corriente es un flujo, por lo tanto la corriente que pasa por la resistencia es la misma que pasa por el led, sabemos que el voltaje en la terminal positiva de la resistencia es 5V y el voltaje en la terminal negativa de la resistencia es 1.8V (estamos despreciando la resistencia interna del diodo), por lo tanto el voltaje que hay entre las terminales de la resistencia R es\n$latex V_R = (5 - 1.8) [V] = 3.2[V]$\nsabemos que la corriente de operaci贸n del led es de 10mA, por lo tanto la resistencia adecuada debe ser\n$latex R = \\frac{3.2[V]}{10[mA]} = \\frac{3.2[V]}{0.010[A]} = 320 \\Omega$\nla resistencia comercial m谩s cercana es de 330 Ohms, usaremos esa, la corriente disminuir谩 una cantidad marginal.\n驴Y si quiero a帽adir un led adicional a la misma fuente?, podemos a帽adir el led de forma paralela al led ya existen y recalcular la resistencia.\nLeds en paralelo\nEl c谩lculo es id茅ntico salvo que ahora la corriente es el doble, pues se requiere satisfacer la corriente de cada diodo $latex i = i_{D1} + i_{D2} = 20[mA]$, la resistencia necesaria es $latex R = 160 \\Omega$, el problema es que la resistencia disipara m谩s potencia, que significa que se calentara m谩s. Un m茅todo m谩s recomendado es conectar una segunda rama con diodo y resistencia incluidos en paralelo a la fuente,\nDiodos con resistencia en paralelo\nde esta forma las dos resistencias son iguales a 330 Ohms. Podemos conectar tantas ramas en paralelo que deseemos, el limite es la capacidad de corriente de nuestra fuente, hay que recordar que el limite de un pin del atmega328p es de 40[mA].\n"}),a.add({id:24,href:'/docs/avr/programando-avr-en-c-variables-y-tipos-caracteres/',title:"Programando Avr en C.- Variables y tipos, caracteres.",section:"Programaci贸n Avr en C.",content:"El tipo de variable char, sirve para guardar caracteres, generalmente el tama帽o de este tipo es de 8 bits, por ello es com煤n encontrar este tipo de dato en una gran cantidad de programas de 8 bits para almacenar resultados de operaciones con registros, sin embargo es preferible usar uint8_t, para un c贸digo consistente. El tipo char lo usaremos 煤nicamente para lo que es, es decir para guardar un car谩cter, por ejemplo;\nchar letra = 'A'; char numero = '1'; //Ambas variables guardan caracteres, uint8\\_t resultado = numero + numero; //Esto dar谩 resultados err贸neos, pues estamos sumando dos //caracteres y nos dos n煤meros. Para representar una palabra utilizaremos arreglos de caracteres, un arreglo es un conjunto contiguo de variables, los arreglos ser谩n analizados a detalle en otra entrada.\nEl tipo char puede almacenar los caracteres descritos por el c贸digo ASCII, incluidos los de control, por ejemplo el car谩cter nulo \u0026lsquo;\\0\u0026rsquo;, o el tabulador \u0026lsquo;\\t\u0026rsquo;, el uso de caracteres suele estar limitado a los dispositivos capaces de mostrarlos, como pantallas por ejemplo.\nAlgunas personas utilizan el puerto serial para enviar comandos por medio de caracteres, sin embargo es un m茅todo ineficiente, imagina que queremos enviar el n煤mero 200 desde un microcontrolador a una PC, podr铆as usar el puerto serial y enviar un \u0026lsquo;2\u0026rsquo;, \u0026lsquo;0\u0026rsquo; y \u0026lsquo;0\u0026rsquo;, cada uno es un car谩cter y tiene un tama帽o de 8 bits, en total son 3x8 bits, sin embargo el n煤mero 200 puede almacenarse sin problemas en solo 8 bits, ahora supongamos que queremos enviar el n煤mero 2,000,000,000, enviarlo car谩cter por car谩cter requerir铆a 8x10 bits, 80 bits, cuando perfectamente ese n煤mero puede ser almacenado en un entero de 32 bits, cuando comentemos el perif茅rico UART esto tomara sentido.\n"}),a.add({id:25,href:'/docs/avr/programando-avr-en-c-variables-y-tipos-enteros/',title:"Programando Avr en C.- Variables y tipos.- Enteros.",section:"Programaci贸n Avr en C.",content:"El lenguaje de programaci贸n C, es un lenguaje de tipo; tipado est谩tico, esto quiere decir que nosotros debemos indicar el tipo de dato que guarda una variable. 驴Qu茅 es una variable?, puede decirse que una variable es un espacio en memoria que guarda un valor determinado, y 驴qu茅 es un tipo', en C los tipos de variables b谩sicos (mejor llamados primitivos) son,\n Enteros, almacenan valores enteros, como: 1, 2, -100, 0b11111, 0x32, \u0026hellip; De punto Flotante, cantidades con decimales como: 1.111, 3.141598, -1.4142, \u0026hellip; Caracter. \u0026lsquo;a\u0026rsquo;, \u0026lsquo;y\u0026rsquo;, ' \u0026lsquo;, \u0026lsquo;\\n\u0026rsquo;, \u0026hellip; Boleanos, true, false.  Existen tipos adicionales pero son variantes de las anteriores, como dijimos para declarar una variable debemos especificar su tipo, esto se hace con la siguiente sintaxis,\ntipo nombre\\_de\\_variable; //Una variable entera llamado numero int numero; //Una variable de tipo car谩cter llamada letra char letra; //Una variable de tipo punto flotante llamada cantidad double cantidad; //Una variable boleana llamada condicion bool condicion; 驴F谩cil no?, pero en la vida nada es f谩cil :D, pero si sencilla, existen modificadores que nos permiten agregar o mejor dicho establecer propiedades a las variables.\nSigned y Unsigned #  Por defecto las variables de tipo entero pueden guardar enteros positivos y negativos, a costa de utilizar un bit para guardar el signo, de manera que si declaramos una variable como unsigned (sin signo), podemos utilizar ese bit para guardar informaci贸n adicional, pero perdemos la capacidad de almacenar n煤meros negativos.\n//Suponiendo que los enteros son binarios de 8 bits int numero1; //Puede guardar valores desde -128 a 127 //Por defecto las variables son de tipo signed signed int numero1; //Puede guardar valores desde -128 a 127 unsigned int numero2; //Puede guardar valores de 0 a 255 Al final la cantidad de informaci贸n guardada no cambia, tan solo cambiamos la forma en como se interpreta, sin embargo el utilizar unsigned generalmente lleva a un camino lleno de dolor, pues es una fuente de errores aritm茅ticos, as铆 que utilizaremos este modificador en situaciones bien definidas. El resto de tipos de variables limitaremos el uso de unsigned a las variables de tipo entero(int).\nEl tama帽o de los enteros, stdint.h #  En el ejemplo anterior asumimos que un entero guarda n煤meros de 8 bits, esto es poco probable, realmente a priori no sabemos que tama帽o tiene un entero(el n煤mero de bits), el tama帽o es determinado por el compilador y es dependiente de la arquitectura, muy probablemente un entero en Arduino sea de 16 bits pero en un cortex-m tal vez sera de 32, y una PC sea de 64 y puede variar entre compiladores en la misma plataforma, ser铆a muy riesgoso asumir un tama帽o por defecto, afortunadamente existe una biblioteca que nos permite declarar variables con el tama帽o que nosotros indiquemos, basta con incluir la biblioteca,\n#include\u0026lt;stdint.h\u0026gt; es importante declarar las variables con un tama帽o predeterminado cuando de operaciones con registros se trate, con aras de mejorar la portabilidad de nuestro c贸digo. 驴Como declaramos un entero con la anterior biblioteca?,\n#include\u0026lt;stdint.h\u0026gt; // Standard Int int8\\_t numero; //Variable entera de 8 bits //Podemos cambiar el 8 por 16, 32 o 64 siendo esto el //numero de bits uint8\\_t numero; //variable entera de 8 bits unsigned de esta forma nos aseguramos que la variable numero sera una variable entera de 8 bits en cualquier ambiente donde nuestro c贸digo se compile y ejecute, a manera de resumen\n8 bits pueden almacenar desde **\\-128 a 127** 16 bits pueden almacenar desde **\\-32768 a 32767** 32 bits pueden almacenar desde **\\-2147483648 a 2147483647** 64 bits pueden almacenar desde 9,223,372,036,854,775,808 a 9,223,372,036,854,775,807 nosotros evitaremos utilizar la declaraci贸n com煤n en favor de la declaraci贸n provista por la biblioteca stdint.h cuando de manipulaci贸n de registros se trate.\n"}),a.add({id:26,href:'/docs/perifericos/gpio/perifericos-atmega328p-puertos-de-entrada-salida-de-proposito-general-gpio/',title:"Perif茅ricos atmega328p.- Puertos de entrada/salida de prop贸sito general (GPIO)",section:"GPIO",content:"Puertos de entrada/salida de prop贸sito general. #  Cando pensamos en programar microcontroladores, lo que queremos es hacer que el mundo se mueva, controlar un motor, un relevador, una lampara, altavoz, etc. Para ello los microcontroladores cuentan con una serie de perif茅ricos. A grandes rasgos un perif茅rico puede definirse como: una interfaz que permite al microcontrolador comunicarse con el exterior, en esta entrada describiremos los puertos de entrada/salida de prop贸sito general; GPIOx.\nSeg煤n la hoja de datos el atmega328p tiene hasta 23 pines programables, cada uno con la posibilidad de ser programado individualmente, Arduino Uno tiene 20 pines disponibles, pues 2 est谩n destinados al reloj y el otro est谩 destinado al pin de reset.\nLos pines est谩n agrupados en puertos, en el atmega328 contamos con tres puertos disponibles, PORTB, PORTC, PORTD, de manera gen茅rica los llamamos PORTx, cada uno de estos puertos cuentan con tres registros asociados, DDRx, PORTx, PINx, donde \u0026ldquo;x\u0026rdquo; es el puerto(B, C, D), estos nueve registros nos permiten configurar y acceder a los valores de cada uno de los pines pertenecientes al microcontrolador.\nLos pines en el microcontrolador tienen un nombre del tipo Pxn, donde x es el puerto y n es 茅l n煤mero de pin, el pin PB0 y el pin PD7, son el pin 0 y el pin 7 del puerto B y del puerto D respectivamente.\nConfigurar un Pin como Salida. #  El acceso a los pines individuales no es posible, estamos limitados a a operaciones que involucran 8 bits como m铆nimo, pues este es el tama帽o del bus de datos y de los registros. Por lo tanto si requerimos escribir el estado del pin PB3, necesariamente debemos escribir todo el puerto B, desde PB0 hasta PB7 (el atmega328p no tiene disponibles todos lo pines PBn).\nSuponiendo que requerimos encender un led que esta conectado al pin PB4, podemos hacer una asignaci贸n al registro DDRB (Direction Data Register) como la siguiente\nDDRB = (1\u0026lt;\u0026lt;PB4); //En binario es igual a DDRB = 0b00010000; Esto efectivamente coloca al pin 4 como salida, sin embargo coloca al resto de los pines como entrada, para resolver este problema haremos uso del operador binario or. El operador or compara bit a bit y posici贸n por posici贸n con la regla,\n0 or 0 = 0 1 or 0 = 1 0 or 1 = 1 1 or 1 = 1 Por ejemplo, para los n煤meros binarios, 100 y 010, el resultado de hacer un or bit a bit es\nbit2 bit1 bit0 1 0 0 or or or 0 1 0 -------------- 1 1 0 Resultado Asumiendo que el registro DDRB contiene el valor 0000 0111, es decir los 3 primeros bits est谩n configurados como salidas, requerimos hacer que el bit correspondiente a PB4 sea 1, sin modificar el resto, para ello usamos la sintaxis,\nDDRB = DDRB | (1\u0026lt;\u0026lt;PB4); El s铆mbolo |, es el operador binario or, significa: or binario entre DDRB y el resultado de la operaci贸n (1\u0026lt;\u0026lt;PB4),\nDDRB = DDRB | (1\u0026lt;\u0026lt;PB4); //Es igual a DDRB = 0b00000111 | 0b00010000; //Ahora se hacer or, resulta DDRB = 0b00010111; //DDRB queda con el bit 5 en 1 y el resto sin modificar Configurar un Pin como Entrada. #  Para poder hacer acciones m谩s complejas requerimos que nuestro microcontrolador pueda \u0026ldquo;sentir\u0026rdquo; el mundo, los pines de nuestro microcontrolador pueden configurarse para que se pueda interpretar el estado de un pin, establecido por un elemento externo (como un bot贸n pulsador). Para ello tambi茅n se utiliza el registro DDRx, pero en esta ocasi贸n el pin a ser configurado se establece como un cero.\nEl operador binario and \u0026amp;, similar al operador or realiza la operaci贸n and bit a bit, con la siguiente regla,\n0 and 0 = 0 0 and 1 = 0 1 and 0 = 0 1 and 1 = 1 Por ejemplo en los siguientes n煤meros binarios el resultado es,\nbit2 bit1 bit0 1 0 0 and 0 1 0 -------------- 0 0 0 Otro operador (en este caso unario) importante es el complemento a uno ~, cambia el valor de 1 a 0 y de 0 a 1, por ejemplo:\n1010 ~ ----- 0101 Asumiendo que el registro DDRC contiene el n煤mero 010 0011, requerimos configurar el pin PC0 como entrada, asignar DDRC = 0 no es aceptable (colocar铆a todos los pines como entrada), en su lugar usaremos el siguiente c贸digo\nDDRC = DDRC \u0026amp; ~(1\u0026lt;\u0026lt;PC0); //Primero se realiza (1\u0026lt;\u0026lt;PC0), resulta DDRC = DDRC \u0026amp; ~0b00000001; //Ahora se aplica el operador complemento, resulta DDRC = DDRC \u0026amp; 0b11111110; //Operador And bit a bit, DDRC = 0b00100011 \u0026amp; 0b11111110; //Resulta DDRC = 0b00100010; De esta forma logramos establecer el pin requerido sin afectar el resto.\nEstablecer el estado cuando el pin es una salida. #  Cuando un pin es configurado como salida, puede entregar/recibir potencia, poquita, pero suficiente para mover al mundo, para ello se requiere establecer el estado del pin, asumiendo que tenemos conectado un led al pin PB4 y que dicho pin esta configurado como salida en el registro DDRB, entonces podemos establecer el estado del pin en el registro PORTB, donde un cero es nivel bajo(0 V) y un uno es nivel alto (5 V).\n//Led encendido PORTB = PORTB | (1\u0026lt;\u0026lt;PB4); //Led apagado PORTB = PORTB \u0026amp; ~(1\u0026lt;\u0026lt;PB4); Por supuesto lo mismo aplica para los otros puertos.\nResistencia de Pull up. #  驴Qu茅 pasa cuando escribimos los registros PORTx cuando DDRx es configurado como entrada?, la respuesta es que con un uno se conecta una resistencia interna llamada de Pull Up, mientras que con un cero se desconecta, la resistencia de pull up es de gran utilidad cuando se censan entradas, un pin configurado como entra, tiene la caracter铆stica de ser sensible al ruido electromagn茅tico del ambiente, cuando se activa la resistencia de pull up se produce una corriente que pasa por el pin, disminuyendo la sensibilidad al ruido y obligando una tensi贸n en el pin en nivel alto (5 Volts).\nLeer el estado de un pin. #  Cuando requerimos leer el estado del pin, utilizamos el registro PINx, es un registro de 8 bits, contiene el estado de cada unos de los pines del puerto, Para censar al pin, debemos configurarlo como entrada en el registro DDRx.\nPara leer el estado del pin PC0, asumiendo que PC0 esta conectado a 5V y que PC0 esta configurado como entrada en DDRC (con un cero),\n//suponiendo que declaramos una variable adecuada llamada //entrada entrada = PINC \u0026amp; (1\u0026lt;\u0026lt;PC0); //Es igual a entrada = 0bxxxxxxx1 \u0026amp; 0b00000001; //donde las x pueden ser 0 o 1 //aplicando and bit a bit resulta en entrada = 0b00000001; //entrada es exactamente igual a entrada = 1; //si PC0 estuvera conectado a tierra, //entrada resultar铆a en entrada = 0bxxxxxxx0 \u0026amp; 0b00000001; //aplicando and bit a bit resulta en entrada =0b00000000; //o entrada = 0; Operadores de asignaci贸n. #  Para evitar verbosidad podemos usar operadores de asignaci贸n m谩s complejos, por ahora presento dos adicionales, |= y \u0026amp;=, su utilidad es obvia\n//en lugar de PORTx = PORTx | (1\u0026lt;\u0026lt;Pxn); DDRx = DDRx \u0026amp; ~(1\u0026lt;\u0026lt;Pxn); //podemos usar PORTx |= 1\u0026lt;\u0026lt;Pxn; DDRx \u0026amp;= ~(1\u0026lt;\u0026lt;Pxn); //ambas expresiones producen resultados //identicos "}),a.add({id:27,href:'/posts/electronica-basica-voltaje-corriente-resistencia-y-ley-de-ohm/',title:"Electr贸nica B谩sica.- Voltaje, Corriente, resistencia y ley de Ohm.",section:"Posts",content:"Cuando la gente de computaci贸n escucha las palabras en el titulo de esta entrada, suele entrar en p谩nico y no es para menos, el an谩lisis de circuitos el茅ctricos puede llegar a ser muy complejo; sin embargo la electr贸nica descansa sobre una ley simple, la ley de Ohm,\n$latex V = iR$\nla ley de Ohm relaciona el voltaje con la corriente y la resistencia; pero esto no nos dice nada si no entendemos estos t茅rminos, comencemos con el voltaje, tambi茅n llamado tensi贸n o potencial el茅ctrico, en la f铆sica,\nE_l voltaje se define como la cantidad de trabajo necesaria para mover una carga desde el infinito hasta un punto determinado_.\nAhora que ya sabes y entendiste claramente el voltaje pasemos con lo siguiente (es broma obviamente), la definici贸n no nos sirve pues se aleja demasiado de la parte pr谩ctica, una forma m谩s laxa y 煤til de interpretarlo es;\nEl voltaje es una fuente de energ铆a el茅ctrica que impulsa a la corriente el茅ctrica a fluir a trav茅s de un circuito el茅ctrico.\nEsta definici贸n no rigurosa pero nos es de gran utilidad, por la definici贸n y por la ley de Ohm, su unidad de medida es el Volt [V], si el voltaje es muy grande la corriente que puede proveer la fuente es de mayor intensidad, por el contrario si el voltaje es negativo, \u0026ldquo;absorbe\u0026rdquo; corriente el茅ctrica.\n驴Pero qu茅 es la corriente el茅ctrica?, pues no es m谩s que un flujo de cargas el茅ctricas, flujo de electrones a trav茅s de un medio, usualmente un conductor, pero puede ser incluso a trav茅s del aire form谩ndose un arco el茅ctrico cuando hay voltaje muy alto, su unidad de medida es el Ampere [A], se le representa con un s铆mbolo \u0026ldquo;i\u0026rdquo; en el esquema a continuaci贸n, la direcci贸n de la corriente va de voltaje alto a voltaje bajo; o si solo hay una fuente va de la terminal positiva a tierra (una forma com煤n de referirse al voltaje o potencial 0[V]).\nDirecci贸n de la corriente\nUna resistencia es un elemento que se opone a el paso de la corriente, si colocamos en un circuito el茅ctrico un resistencia de 10 Ohms, la corriente que pasa por ella seria mucho mayor que si coloc谩ramos una resistencia de 1000 Ohms.\nPor ejemplo, tenemos una fuente de 5V, una resistencia de 330 Ohms conectada entre sus terminales, 驴Qu茅 corriente pasa por la resistencia?\nsabemos que $latex V = i R$, dividiendo ambos lados entre la resistencia\n$latex \\frac{V}{R} = \\frac{iR}{R}$\npor lo tanto, la corriente es\n$latex i = \\frac{V}{R}$\n$latex = \\frac{5}{330}=0.015 [A] = 15 [mA]$\n驴Por qu茅 es importante conocer la corriente?, debido a que cada pin de nuestro microcontrolador tiene poca capacidad de entregar o recibir potencia, dicho de otra forma la corriente que sale de cada pin est谩 limitada, para el atmega328p la corriente m谩xima de cada pin es de 40mA y la corriente entre todos los pines no debe ser superior a 200mA, sobrepasar este limite implica da帽ar el microcontrolador, para manejar corrientes grandes mayores a 10[mA] utilizaremos componentes externos.\n"}),a.add({id:28,href:'/posts/que-son-los-registros-en-un-microcontrolador/',title:"驴Qu茅 son los registros en un microcontrolador?",section:"Posts",content:"Hemos hablado acerca de los registros en anteriores entradas, vamos a profundizar un poco en el tema.\nPara entender un registro, definamos que es un bit, la palabra tiene varias acepciones, para nuestro prop贸sito un bit es la representaci贸n de un valor binario, este puede ser 1 o 0. Entonces un registro es sencillamente un conjunto de bits, en nuestro microcontrolador atmega328p, existen registros de 8bits, en otras arquitecturas como los cortex-m los registros son de 32 bits, algunos como el msp de texas instruments, tienen registros de 16 bits.\n驴Es mejor 32 que 8 bits?, no realmente, la diferencia radica en que un sistema de 32 bits requiere un bus de 32 bits, un bus podr铆a definirse como un conjunto paralelo de cables que comunica los registros con alg煤n otro elemento, en otras palabras un bus de 32 bits comunica mayor informaci贸n por cada ciclo, a priori esto es bueno, sin embargo las instrucciones que tambi茅n viajan por este bus, no necesariamente ocupan los 32 bits, esto deriva en programas m谩s grandes para las arquitecturas de 32 bits. Hoy por hoy las arquitecturas de 32 bits son muy populares, siendo incluso m谩s baratas y eficientes que sus contrapartes de 8 bits, la gran ventaja de los 8 bits radica en su facilidad y simpleza.\nSiguiendo con los registros, programar un microcontrolador se resume a modificar los registros, ya comentamos el registro DDRx, donde x es un puerto determinado (haremos una serie especifica sobre puertos), modificar dicho registro nos permite establecer el comportamiento de cada uno de los pines pertenecientes a dicho puerto. A lo largo de las entradas iremos revisando varios de los registros y explicaremos las implicaciones que se tienen al modificarlos. En realidad DDRx es un nemot茅cnico no un registro, cuando escribimos DDRB, realmente estamos escribiendo algo similar a *(0xfa020121029120), una vez que estudiemos los apuntadores detallaremos que es lo anterior, adelanto que el n煤mero entre par茅ntesis es la direcci贸n del registro).\nEl tema de los registros tiene una gran exposici贸n cuando se programa en ensamblador, el ensamblador es un lenguaje muy estimulante de aprender y el ensamblador de avr es muy limpio y sencillo, quiz谩 en el futuro expliquemos un poco.\n"}),a.add({id:29,href:'/docs/avr/programando-avr-en-c-hola-mundo/',title:"Programando Avr en C.- Hola mundo",section:"Programaci贸n Avr en C.",content:"Antes de analizar el c贸digo Blink en C, explicaremos la estructura b谩sica de un programa en C, el siguiente c贸digo muestra un programa m铆nimo\n#include\u0026lt;bibliotecas.h\u0026gt; int main(void) { tipo1 variable1; tipo\\_n variable\\_n; while(1){ hacer\\_cosas(var1, var2, varn); } return 0; } Al inicio de este listado tenemos una directiva del preprocesador, las directivas comienzan con un #, en este caso tenemos una directiva include, que le indica al compilador que copie el contenido del fichero bibliotecas.h en nuestro c贸digo, esto nos habilita a usar los objetos y funciones que hay dentro de bibliotecas.h, existen diferentes directivas que nos ayudaran a tener un c贸digo m谩s limpio, es importante no subestimar al preprocesador, pues nos ayudara a hacer cosas que no pueden hacerse de otra forma.\nPosteriormente tenemos la funci贸n main, la funci贸n main es un ente importante, cuando el programa se ejecuta, la funci贸n main es llamada autom谩ticamente, es decir el c贸digo dentro de las llaves se ejecutara linea por l铆nea, lo que est茅 fuera de dicha funci贸n deber谩 ser llamado expl铆citamente para poder ejecutarse. Por definici贸n la funci贸n main retorna un entero al finalizar y en el caso de microcontroladores no suele recibir argumentos por eso la palabra void(m谩s adelante analizaremos la estructura de las funciones), una vez llamada la funci贸n main, se comienzan a ejecutar cada uno de las l铆neas dentro de ella en orden descendente, en este caso declaramos dos variables de cierto tipo, variable_1 y variable_n.\nPosteriormente hay una parte importante una estructura de flujo while, mantiene en ejecuci贸n el c贸digo que contiene mientras la condici贸n que esta entre par茅ntesis se mantenga verdadera, un 1 siempre es verdadero por lo tanto esto se considera un ciclo infinito, es decir el c贸digo dentro del while se ejecutara constantemente, cuando llegue a la 煤ltima l铆nea saltara a la primera dentro sus llaves.\nFinalmente tenemos un retorno, como nuestro programa se queda \u0026ldquo;ciclado\u0026rdquo; dentro del while, nunca alcanzaremos esta l铆nea, sin embargo es conveniente poner esta l铆nea o el compilador nos dar谩 un warning o advertencia.\nYa estamos un poco m谩s familiarizados con la estructura del programa, ahora si analicemos el programa Blink,\n#include\u0026lt;avr/io.h\u0026gt; #include\u0026lt;util/delay.h\u0026gt; int main(void) { DDRB = 1 \u0026lt;\u0026lt; PB5; PORTB = 0; while(1){ PORTB = 1 \u0026lt;\u0026lt; PB5; \\_delay\\_ms(1000); PORTB = 0; \\_delay\\_ms(1000); } return 0; } Al inicio tenemos dos directivas include, la primera io.h, nos permite acceder a los registros de los puertos de nuestro microcontrolador, en este caso el puerto B, har茅 una entrada especifica para este tema, la segunda delay.h nos permite usar la funci贸n _delay_ms, que como deducir谩s nos permite crear un tiempo muerto.\nIniciamos con la funci贸n main y lo primero que tenemos es una asignaci贸n, te preguntaras que es DDRB, para entenderlo primero debo explicar que es un registro y lo explicare en una entrada dedicada, por ahora vamos a decir que DDRB es una variable a secas, a esta variable le asignamos el resultado de una operaci贸n 1\u0026laquo;PB5, el s铆mbolo \u0026ldquo;\u0026laquo;\u0026rdquo; es un operado binario llamado left shift o corrimiento a la izquierda, indica que el n煤mero a la izquierda sera recorrido el n煤mero de veces que tiene a la derecha en binario, por ejemplo\n3 en binario es 0b0011 3\u0026lt;\u0026lt;1 es en binario 0b0011\u0026lt;\u0026lt;1 y da como resultado 0b0 0110 en decimal 6 3\u0026lt;\u0026lt;2 es en binario 0b0011\u0026lt;\u0026lt;2 y da como resultado 0b0 1100 en decimal 12 3\u0026lt;\u0026lt;3 es en binario 0b0011\u0026lt;\u0026lt;3 y da como resultado 0b1 1000 en decimal 24 en nuestro caso casi siempre, solo usaremos un 1 a la izquierda del operador, por lo tanto\n1 en binario es 0b1 1\u0026lt;\u0026lt;1 da como resultado 0b10 1\u0026lt;\u0026lt;2 da como resultado 0b100 1\u0026lt;\u0026lt;3 da como resultado 0b1000 1\u0026lt;\u0026lt;7 da como result. 0b10000000 //bit 76543210 //Posici贸n 87654321 realmente no nos interesa el valor en decimal, lo que nos interesa es donde queda posicionado el 1, al final de la operaci贸n con 1\u0026laquo;2, el 1 queda posicionado en la tercera de derecha a izquierda, con 1\u0026laquo;7, queda en la octava de derecha a izquierda.\n驴Para que es esto?, DDRB es una \u0026ldquo;variable\u0026rdquo; que le indica al microcontrolador si el pin es de entrada o de salida, si el bit es cero el pin operara como entrada, de lo contrario opera como salida. DDRB contiene 8 bits y cada bit corresponde a un pin de nuestro microcontrolador, al inicio contiene el valor binario 0b0000 0000, cuando revisas la hoja de datos de tu microcontrolador te dar谩s cuenta que los pines est谩n rotulados con las leyendas PA0, PB0, PC0, PA1, etc, estos son los \u0026ldquo;nombres\u0026rdquo; de los pines, A,B,C, es el puerto al que pertenecen, por lo tanto el pin 5 del puerto B es PB5.\nEl pin PB5 esta conectado al led de nuestra tarjeta, hay que decirle a DDRB que ponga el pin 5 como salida, tan f谩cil como\nDDRB = 1\u0026lt;\u0026lt;PB5; //que es exactamente igual a DDRB = 0b00100000; //bit 76543210 Seguimos adelante y tenemos otra asignaci贸n, PORTB es otro registro, de igual forma asumiremos por ahora que es una variable, controla el estado del pin, el estado puede ser 0 para bajo o 1 para alto, en s铆ntesis cuando el pin se configura en alto tendr谩 5 volts y cuando se configura en bajo tendr谩 0 volts, cuando necesitemos encender el led lo configuramos como alto con\nPORTB = 1\u0026lt;\u0026lt;PB5; //que es exactamente igual a PORTB = 0b00100000; 驴y si queremos ponerlo en bajo?, por ahora solo esto,\nPORTB = 0; //que es id茅ntico a PORTB = 0b00000000; esto tiene el peque帽o inconveniente de poner el resto de pines en bajo y es muy probable que nuestro colega que este us谩ndolos se enoje con nosotros, m谩s adelante encontraremos una mejor manera.\nSiguiendo con el programa, entramos al ciclo infinito en donde la parte interesante es la funci贸n _delay_ms(), la funci贸n se explica por si misma, cuando se llama toma el control de la ejecuci贸n del programa y espera la cantidad de tiempo indicada en milisegundos, en este caso 1000 que equivale a un segundo.\nEl programa se queda en este bucle encendiendo y apagando el led cada dos segundos. La 煤ltima l铆nea no se ejecuta pues el ciclo no se interrumpe.\n"}),a.add({id:30,href:'/docs/workstation/arduino-basico-iii/',title:"Arduino B谩sico III",section:"Estaci贸n de trabajo.",content:"El siguiente paso obvio es analizar el programa Blink, sin embargo aqu铆 no usaremos las bibliotecas de Arduino, usaremos c贸digo c para dispositivos AVR, entonces 驴para que tanto problema instalando la maquina virtual y Arduino?, simplemente porque utilizaremos la infraestructura ya hecha para nuestro prop贸sito, abrimos el ejemplo Blink y reemplazamos el c贸digo por:\n#include\u0026lt;avr/io.h\u0026gt; #include\u0026lt;util/delay.h\u0026gt; int main(void) { DDRB = 1 \u0026lt;\u0026lt; PB5; PORTB = 0; while(1){ PORTB = 1 \u0026lt;\u0026lt; PB5; \\_delay\\_ms(1000); PORTB = 0; \\_delay\\_ms(1000); } return 0; } compilamos y subimos el c贸digo, el comportamiento es exactamente el mismo, pero el c贸digo es totalmente C y no C++, tambi茅n evitamos el uso de las bibliotecas de Arduino en favor de las avr. Esto se nota de inmediato en el tama帽o del programa, mientras que nuestro c贸digo usa 108 Bytes, el c贸digo de Arduino usa 924 Bytes, esto realmente no es determinante, en un proyecto complejo y grande usar una biblioteca u otra no tendr谩 gran impacto en el tama帽o final. En realidad las Arduino usan como base las bibliotecas avr. Este peque帽o hola mundo, da para comentar muchas cosas, no te preocupes por no entender el c贸digo, iremos desglos谩ndolo en las siguientes entradas, tambi茅n mostrare como liberarnos del IDE y por si fuera poco como liberarnos de la tarjeta.\n驴Por qu茅 no usar unicamente Arduino para todo?, la verdad es que la 煤nica raz贸n verdadera y valida es que no me gusta, otras razones menos validas son:\n Te limita a un pu帽ado de microcontroladores.- Dentro de la familia de los microcontroladores avr apenas unos cuantos son utilizados para las tarjetas Arduino, existen ports a otras arquitecturas y micros, pero suelen ser limitadas, quiz谩 lo que requieres realizar sea un programa muy sencillo, quiz谩 no necesites toda la potencia que te ofrece un atmega328p, tal vez lo que necesites sea un attiny13(hiper barato y peque帽o), por el contrario tal vez requieres algo muy r谩pido y potente como un amr cortex m7, o un risc V, no siempre tenemos a disponibilidad las bibliotecas de Arduino, pienso que es importante saber hacer tus propias bibliotecas y adaptarlas a un hardware cambiante. Te obliga a usar C++, aunque es posible enlazar bibliotecas de C++ en C, es un proceso un poco traum谩tico, el problema de C++ es que es dif铆cil de leer, el ejemplo cl谩sico es el siguiente  struct unaEstructura primero = nuevoNumero(); struct unaEstructura segundo = nuevoNumero(); // C a = primero.num + segundo.num; //En C esto tiene un significado obvio // C++ a = primero + segundo; //A priori no sabemos que esta pasando aqu铆 pudiera parecer una trivialidad, pero de igual forma sucede con varias otras situaciones, realmente es una cuesti贸n de simple gusto, C++ es un lenguaje muy potente, si te sientes c贸modo con 茅l 煤salo y expl贸talo al m谩ximo.\n El entorno en general es precario. No se puede tener todo, si es f谩cil tiene que haber un costo, el costo es que no tenemos herramientas de debugging, el editor es horrible, no se adapta muy bien a los proyectos colaborativos, no hay control de versiones.  Sin embargo hay muchas cosas buenas que no se encuentran en ning煤n otro ambiente, por lo tanto debemos equilibrar nuestras preferencias en aras de obtener el mejor rendimiento y calidad.\n"}),a.add({id:31,href:'/posts/bloque-reutilizable-sin-titulo/',title:"save",section:"Posts",content:"El siguiente paso obvio es analizar el programa Blink, sin embargo aqu铆 no usaremos las bibliotecas de Arduino, usaremos c贸digo c para dispositivos AVR, entonces 驴para que tanto problema instalando la maquina virtual y Arduino?, simplemente porque utilizaremos la infraestructura ya hecha para nuestro prop贸sito, abrimos el ejemplo Blink y reemplazamos el c贸digo por:\n#include\u0026lt;avr/io.h\u0026gt; #include\u0026lt;util/delay.h\u0026gt; int main(void) { DDRB = 1 \u0026lt;\u0026lt; PB5; PORTB = 0; while(1){ PORTB |= 1 \u0026lt;\u0026lt; PB5; \\_delay\\_ms(1000); PORTB \u0026amp;= ~(1\u0026lt;\u0026lt;PB5); \\_delay\\_ms(1000); } } compilamos y subimos el c贸digo, el comportamiento es exactamente el mismo, pero el c贸digo es totalmente C y no C++, tambi茅n evitamos el uso de las bibliotecas de Arduino en favor de las avr. Esto se nota de inmediato en el tama帽o del programa, mientras que nuestro c贸digo usa 108 Bytes, el c贸digo de Arduino usa 924 Bytes, esto realmente no es determinante, en un proyecto complejo y grande usar una biblioteca u otra no tendr谩 gran impacto en el tama帽o final. En realidad las Arduino usa como base las bibliotecas avr. Este peque帽o hola mundo, da para comentar muchas cosas, no te preocupes por no entender el c贸digo iremos desglos谩ndolo en las siguientes entradas, tambi茅n mostrare como liberarnos del IDE y por si fuera poco como liberarnos de la tarjeta.\n驴Por qu茅 no usar unicamente Arduino para todo?, la verdad es que la 煤nica raz贸n verdadera y valida es que no me gusta, otras razones menos validas son:\n Te limita a un pu帽ado de microcontroladores.- Dentro de la familia de los microcontroladores avr apenas unos cuantos son utilizados para las tarjetas Arduino, existen ports a otras arquitecturas y micros, pero suelen ser limitadas, quiz谩 lo que requieres realizar sea un programa muy sencillo, quiz谩 no necesites toda la potencia que te ofrece un atmega328p, tal vez lo que necesites sea un attiny13(hiper barato y peque帽o), por el contrario tal vez requieres algo muy r谩pido y potente como un amr cortex m7, o un risc V, no siempre tenemos a disponibilidad las bibliotecas de Arduino, pienso que es importante saber hacer tus propias bibliotecas y adaptarlas a un hardware cambiante. Te obliga a usar C++, aunque es posible enlazar bibliotecas de C++ en C, es un proceso un poco traum谩tico, el problema de C++ es que es muy dif铆cil de leer, el ejemplo cl谩sico es el siguiente  struct unaEstructura primero = nuevoNumero(); struct unaEstructura segundo = nuevoNumero(); // C a = primero.num + segundo.num; //En C esto tiene un significado obvio // C++ a = primero + segundo; //A priori no sabemos que esta pasando aqu铆 pudiera parecer una trivialidad, pero de igual forma sucede con varias otras situaciones, realmente es una cuesti贸n de simple gusto, C++ es un lenguaje muy potente, si te sientes c贸modo con 茅l 煤salo y expl贸talo al m谩ximo.\n El entorno en general es precario. No se puede tener todo, si es f谩cil tiene que haber un costo, el costo es que no tenemos herramientas de debugging, el editor es horrible, no se adapta muy bien a los proyectos colaborativos, no hay control de versiones.  Sin embargo hay muchas cosas buenas que no se encuentran en ning煤n otro ambiente, por lo tanto debemos equilibrar nuestras preferencias en aras de obtener el mejor rendimiento y calidad.\n"}),a.add({id:32,href:'/docs/workstation/arduino-basico-ii-hola-mundo/',title:"Arduino B谩sico II.- Hola Mundo",section:"Estaci贸n de trabajo.",content:"Prometo que ahora si comenzamos. :D\nConectamos nuestro Arduino a nuestra PC por medio del cable USB, si estas utilizando Virtual Box, es necesario que le des permiso al \u0026ldquo;invitado\u0026rdquo; para que use el puerto USB, esto se hace en el men煤 de Virtual Box, devices-\u0026gt;USB-\u0026gt; dispositivo correspondiente a Arduino(probablemente FTDI). Para verificar que nuestro Arduino esta conectado y lo reconoce el sistema, abrimos una terminal y tecleamos\n[eleckia@tuxin-lp ~]$ dmesg si el dispositivo esta conectado obtendremos una salida similar a esta\n[26227.988155] usb 2-1: new full-speed USB device number 3 using ohci-pci [26228.164271] usb 2-1: New USB device found, idVendor=2341, idProduct=0043, bcdDevice= 0.01 [26228.164279] usb 2-1: New USB device strings: Mfr=1, Product=2, SerialNumber=220 [26228.164284] usb 2-1: Manufacturer: Arduino (www.arduino.cc) [26228.164287] usb 2-1: SerialNumber: 7553334343635121A191 [26228.282966] cdc_acm 2-1:1.0: ttyACM0: USB ACM device [26228.287986] usbcore: registered new interface driver cdc_acm [26228.287989] cdc_acm: USB Abstract Control Model driver for USB modems and ISDN adapters Esto implica que nuestro Arduino esta conectado y la PC lo reconoce como un dispositivo ACM, ahora abrimos el IDE de Arduino, la primera vez que lo abrimos nos aparecer谩 algo como esto. (Si no aparece la salida anterior, probablemente no seleccionaste el dispositivo correcto en virtual box, prueba con otro.)\n   hacemos click en herramientas-\u0026gt;Puerto y seleccionamos el puerto al que este conectado el Arduino, probablemente solo haya uno disponible, en mi caso /dev/ttyACM0, en el caso de que no apareciera ning煤n puerto disponible, lo m谩s probable es que te falte agregar tu usuario a los grupos lock y dialout simplemente,\n[eleckia@tuxin-lp ~]$ sudo gpasswd -a $USER lock [eleckia@tuxin-lp ~]$ sudo gpasswd -a $USER dialout debes salir de la sesi贸n o en su defecto reiniciar tu sistema.\nContinuamos, el \u0026ldquo;Hola Mundo\u0026rdquo; es un programa tradicional en el mundo de la programaci贸n, consiste en mostrar la frase \u0026ldquo;Hola mundo\u0026rdquo; en la pantalla, traducida a los sistemas embebidos consiste en hacer parpadear un led. El entorno de desarrollo trae el c贸digo ya escrito, vamos a Archivo-\u0026gt;Ejemplos-\u0026gt;Basic-\u0026gt;Blink nos abrir谩 una ventana con el siguiente c贸digo\n// the setup function runs once when you press reset or power the board void setup() { // initialize digital pin LED\\_BUILTIN as an output. pinMode(LED\\_BUILTIN, OUTPUT); } // the loop function runs over and over again forever void loop() { digitalWrite(LED\\_BUILTIN, HIGH); // turn the LED on (HIGH is the voltage level) delay(1000); // wait for a second digitalWrite(LED\\_BUILTIN, LOW); // turn the LED off by making the voltage LOW delay(1000); // wait for a second } Sin modificar nada, vamos a subir este programa a la tarjeta, tan solo hacemos click en el icono de la palomita para compilar y despu茅s en el icono de la flecha para subir, o con las teclas ctrl+R y ctrl+U respectivamente. Si todo esta correcto veremos que el led de nuestro Arduino comienza a parpadear cada segundo aproximadamente.\n"}),a.add({id:33,href:'/docs/workstation/arduino-basico-i/',title:"Arduino B谩sico I.",section:"Estaci贸n de trabajo.",content:"Comenzamos formalmente nuestro estudio, como se menciono anteriormente, Arduino se compone tanto de software como de hardware, miremos un poco el hardware.\nEl Arduino Uno (placa de desarrollo), cuenta con un puerto usb, por el que se alimenta la placa; enviamos y recibimos datos, este puerto esta conectado a un circuito integrado que no es m谩s que un convertidor serial-usb, al mismo tiempo este convertidor se conecta a unos pines espec铆ficos del microcontrolador. Lo importante a destacar es que esta conexi贸n ya esta hecha y es perfectamente funcional, sino fuera as铆 tendr铆amos que dise帽ar un circuito para poder conectar el microcontrolador con la PC, esta es sin duda la gran caracter铆stica que dio paso al 茅xito, una plataforma lista para usarse sin necesidad de componentes adicionales.\nEl convertidor serial varia dependiendo de la versi贸n de tu tarjeta, pero su comportamiento es similar en todas las versiones, por ahora nos enfocamos en conocer el microcontrolador,\nEl atmega328p es un microcontrolador RISC de 8 bits, no entraremos en detalles de la arquitectura pero si en sus caracter铆sticas, quiz谩 el par谩metro m谩s importante es la capacidad de memoria con la que cuenta, la asombrosa cantidad de 32KB de flash o memoria de programa y 2KB de ram, teniendo en cuenta que en este momento contamos con PCs regularmente de 8GB de ram y mayores de 1TB de almacenamiento, la memoria del atmega328p parecer铆a poco, sin embargo se pueden hacer muchas cosas con ella y cuando digo muchas es muchas, adicionalmente cuenta con 1KB de memoria eeprom, en la cual podemos guardar datos y evitar que se pierdan cuando se corta la alimentaci贸n.\nOtro par谩metro importante es la frecuencia a la que trabaja, siendo hasta 20MHz el m谩ximo posible, internamente cuenta con un oscilador que puede ser configurado hasta 8MHz, si queremos frecuencias mayores podemos conseguirlas conectado un oscilador externo, usualmente un reloj de cuarzo, la regla es que a mayor frecuencia mayor capacidad de procesamiento, pero mayor gasto de energ铆a. En el caso del Arduino(tarjeta), tiene un reloj de 16MHz ya conectado, por lo que el entorno esta desarrollado con este reloj en mente.\nCuenta con 23 pines programables en la versi贸n DIP y hasta 32 en la versi贸n de montaje superficial.\nlos perif茅ricos con los que cuenta\n Tiimer con output compare ADC USART SPI I2C Y varias fuentes de interrupciones  describir茅 con mucho detalle los perif茅ricos en posteriores entradas.\nAunque suene trillado, este es el coraz贸n de Arduino. Mi objetivo es exponer al microcontrolador per se m谩s que al ambiente Arduino en general.\nAdicionalmente la tarjeta cuenta con un par de hileras de pines donde podemos conectar componentes externos, un jack de alimentaci贸n por el cual podemos conectar hasta 9V, recomiendo no conectar USB y jack al mismo tiempo, finalmente un LED conectado al pin 13.\n"}),a.add({id:34,href:'/docs/workstation/estacion-de-trabajo-iv/',title:"Estaci贸n de trabajo IV",section:"Estaci贸n de trabajo.",content:"Finalizamos esta serie de post iniciales con una lista de materiales recomendada, en ebay existen una gran variedad de paquetes donde se incluyen Arduinos, resistencias, capacitores, transistores y algunos sensores, basta con ir a ebay o mercadolibre y buscar kit Arduino, adquirir uno de ellos es un buen comienzo, personalmente recomiendo,\nhttps://www.ebay.com/itm/UNO-R3-Updated-version-of-the-RFID-Starter-Kit-LCD-learn-Suite-1602-for-Arduino/201644819283?hash=item2ef2f7c353:g:UroAAOSwIgNXrjMk\nigualmente puedes adquirir kits de resistencias, capacitores y leds, adem谩s de jumpers, cables y un par de atmega328p DIP adicionales.\nCon esto podemos comenzar nuestro estudio, m谩s adelante requeriremos m谩s componentes, pero se mencionar谩n con forme se requieran.\n"}),a.add({id:35,href:'/docs/workstation/estacion-de-trabajo-iii/',title:"Estaci贸n de trabajo III",section:"Estaci贸n de trabajo.",content:"Ya casi estamos listos, damos click en Actividades y abrimos una terminal, la terminal puede ser intimidante, pero creeme una vez te acostumbres a ella la amaras.\nEn los sistemas linux tenemos diferentes tipos de usuarios cada uno de ellos con diferentes privilegios, el usuario con m谩s privilegios es el usuario root, puede hacer y deshacer el sistema, nuestro usuario por defecto tiene pocos privilegios para evitar que el usuario pueda romper el sistema por accidente. Al abrir la terminal tendremos algo similar a esto\n[eleckia@tuxin-lp ~]$ donde eleckia es el nombre de usuario que se eligi贸, y tuxin-lp es el nombre que se le dio a la pc, delante del signo $, podemos escribir.\nDNF es el manejador de paquetes de Fedora, es una herramienta que nos permite actualizar, instalar y remover los programas y/o bibliotecas instaladas en nuestro sistema, para utilizarlo simplemente tecleamos\n[eleckia@tuxin-lp ~]$ dnf nos desplegara una enorme lista de las opciones disponibles para este comando, el que nos interesa por ahora es update, esta opci贸n nos actualiza todos los paquetes a la 煤ltima versi贸n disponible, tecleamos\n[eleckia@tuxin-lp ~]$ dnf update Error: Este comando debe ejecutarse como usuario root. el error nos indica que requerimos privilegios altos, la forma de escapar de la tiran铆a el usuario root, es anteponer la palabra sudo, es decir\n[eleckia@tuxin-lp ~]$ sudo dnf update nos pedir谩 introducir la contrase帽a que creamos al iniciar Fedora por primera vez, la introducimos y nos desplegar谩 la lista de actualizaciones disponibles, nos pedir谩 confirmaci贸n a lo que responderemos s. La primera vez que actualicemos, habr谩 muchas actualizaciones, por lo que se tardara un poco, al terminar de actualizar, reiniciaremos el sistema y abriremos nuevamente una terminal, una vez hecho esto instalaremos Arduino por fin. Para instalarlo tan f谩cil como escribir lo siguiente:\n[eleckia@tuxin-lp ~]$ sudo dnf install arduino terminada la descarga e instalaci贸n, ya tenemos disponible el software Arduino, hacemos click en actividades y lo ejecutamos, nos indicara que debemos agregar nuestro usuario a los grupos dialout y lock, le decimos que si e introducimos la contrase帽a del sistema, tenemos finalmente todo listo para comenzar a programar, tan solo nos falta conectar nuestro Arduino a un puerto usb.\nAnteriormente mencione que trabajaremos con Arduino uno, sin embargo debo confesar que cualquier Arduino de 8 bits es valido, de hecho ni siquiera es necesario instalar Fedora, puedes instalar Arduino en casi cualquier sistema operativo, la raz贸n de instalar Fedora es que nos ofrece todas las herramientas de manera simple e inmediata, al estar dentro de una m谩quina virtual no debemos preocuparnos de da帽ar el sistema accidentalmente, yo har茅 todo desde Fedora, por que es mi sistema instalado, pero sientete libre de utilizar lo que m谩s te acomode, eso si, si tienes alg煤n problema con tu sistema no podre ayudarte puesto que yo no lo uso (windows). Lo mismo va para la tarjeta Arduino que utilices, funciona cualquiera, pero los registros de cada microcontrolador varian mucho, sobre todo de una arquitectura a otra, los microcontroladores de 8 bits no tiene nada que ver con los micros de 32 o 16 bits.\nNo es de mi inter茅s centrarme en Arduino, pero es la opci贸n de aprendizaje m谩s adecuada y ser铆a tonto no empezar con ella.\nLos lugares m谩s comunes para adquirir la tarjeta es ebay, amazon y mercadolibre, es tu elecci贸n, tambi茅n requerimos algunos dispositivos como leds, resistencias, transistores, capacitores, etc, en el siguiente post daremos algunos detalles adicionales.\n"}),a.add({id:36,href:'/docs/workstation/estacion-de-trabajo-ii/',title:"Estaci贸n de trabajo II",section:"Estaci贸n de trabajo.",content:"En este post instalaremos Fedora en la maquina virtual.\nAbrimos VirtualBox y seleccionamos la maquina virtual Fedora que creamos anteriormente, ahora damos click en Configuraci贸n, se nos abrir谩 una nueva ventana, seleccionamos Almacenamiento y en controlador IDE, seleccionamos Vaci贸, a la derecha de unidad 贸ptica damos click en el icono de un disco azul y seleccionamos el .iso de Fedora que descargamos anteriormente, finalmente damos click en aceptar.\nSi tienes anfitri贸n linux, ah铆 mismo en configuraci贸n seleccionamos Pantalla y cambiamos Controlador Gr谩fico a VBoxVGA y aumenta la memoria de video a por lo menos 64MB.\nNuevamente en Configuraci贸n, ahora seleccionamos Sistema y en la pesta帽a Procesador, seleccionamos el n煤mero de procesadores que tenemos, damos click en aceptar.\nNuestra maquina virtual, esta lista para arrancar y ya tiene el \u0026ldquo;disco\u0026rdquo; de instalaci贸n insertado, procedemos a iniciarla con el icono Iniciar.\nArrancamos y la primer pantalla de selecci贸n nos da tres opciones, seleccionamos la primera, Start Fedora, cuidado por defecto esta seleccionada la segunda opci贸n.\nEsperamos a que el sistema inicie y tenemos una versi贸n live de Fedora funcionando,\nGnome en Fedora\nEsta versi贸n de Fedora es totalmente funcional, podemos jugar con ella, revisar los programas y menus, cambiar la resoluci贸n, etc, sabedores de que los cambios que hagamos no se guardaran, cuando estemos listos damos click en Install to Hard Drive. Se abrir谩 el asistente de instalaci贸n Anaconda (puede que tarde unos minutos), aqu铆 elegimos el idioma y la regi贸n y damos click en continuar,\nAnaconda\nseleccionamos nuestra distribuci贸n de teclado(probablemente espa帽ol latinoamericano) y la zona horaria, click en Destino de la Instalaci贸n, sin modificar nada damos click en Hecho en la esquina superior izquierda y comenzamos la instalaci贸n.\nComenzar Instalaci贸n\nEsperamos unos minutos a que termine la instalaci贸n y damos click en salir.\nFinalizado\nApagamos la maquina virtual y removemos la imagen .iso de Fedora.\nIniciamos nuevamente la maquina virtual esta vez iniciara Fedora instalado, todo lo que hagamos ahora si se guardara, nos dar谩 la bienvenida un asistente de configuraci贸n donde nos pedir谩 algunos datos, de ellos lo importante es el usuario y la contrase帽a, los cuales debemos recordar o en su defecto anotar. Una vez ingresados nuestro sistema estar谩 listo para poder instalar Arduino.\nFedora\nContinuaremos con la instalaci贸n de Arduino en el siguiente post.\n"}),a.add({id:37,href:'/docs/workstation/estacion-de-trabajo-i/',title:"Estaci贸n de trabajo I",section:"Estaci贸n de trabajo.",content:"No es obligatorio instalar Fedora, pero todos los ejemplos se har谩n desde este sistema operativo, eres libre de adaptar lo que aqu铆 se mencione a tus circunstancias.\nPara poder trabajar a gusto es necesario disponer de un conjunto de herramientas adecuado, dejando de lado el tipo de computadora con la que se cuenta, lo importante es el sistema operativo, como se menciono en el post anterior utilizaremos software libre, por lo que nuestro sistema operativo sera linux, concretamente Fedora, esta distribuci贸n cuenta con los paquetes necesarios para nuestros prop贸sitos, as铆 que si utilizas algo diferente comienza borrado tu disco duro e instala Fedora (esto es broma obviamente).\nLa manera m谩s sencilla de comenzar en este mundo (y la que seguiremos aqu铆) es con linux + arduino, hablemos r谩pida y brevemente de ellos.\nLinux es una pieza de software que funciona como interfaz entre el hardware de una computadora (memoria, procesador, perif茅ricos, etc), en pocas palabras y de manera muy general, linux se encarga de administrar el hardware de una PC, por otro lado existe software (GNU) que se comunica con linux para formar un sistema operativo, de ah铆 surgen los sistemas GNU/Linux, a grandes rasgos el software GNU se encarga de administrar el sistema, envi谩ndole instrucciones a Linux (com煤nmente llamado kernel o n煤cleo) y este 煤ltimo las ejecuta en el hardware. Para el que este interesado en entender un poco m谩s sobre el origen y filosof铆a de GNU/linux y el software libre, les recomiendo ver el documental \u0026ldquo;C贸digo linux\u0026rdquo;, disponible en youtube en espa帽ol. Compa帽铆as aprovechan este conjunto de software para crear distribuciones, en nuestro caso trabajaremos con la distribuci贸n Fedora, patrocinada por Red Hat, disponible para su descarga gratuitamente.\nArduino es una plataforma de desarrollo, contiene tanto software como hardware, sera com煤n referirnos de manera indistinta al software o hardware con la palabra Arduino, con respecto al hardware hay muchas versiones, siendo el \u0026ldquo;Arduino uno\u0026rdquo; el m谩s com煤n y el que utilizaremos, este Arduino cuenta con un microcontrolador atmega328p, es un microcontrolador de la empresa Microchip, anteriormente le pertenec铆a a Atmel, pero fue comprada por la anterior mencionada, el microcontrolador es de 8 bits y contiene numerosos perif茅ricos. Arduino es software libre pero tambi茅n hardware libre, esto implica que los clones funcionen de manera id茅ntica a el hardware original, aunque si puedes comprarlo original siempre es bueno apoyar a los creadores. En la parte de software Arduino cuenta con su propio entorno de desarrollo (aunque a mi me parece horrible) y cuenta con miles de bibliotecas listas para ser usadas en nuestros proyectos.\nLo que requerimos:\n-Instalar Fedora\n-Adquirir un Arduino\n-Instalar Arduino dentro de Fedora\nComencemos instalando Fedora, como mencionamos Fedora es un sistema operativo, por lo tanto requerimos instalarlo en nuestra PC, podemos instalar junto a nuestro sistema operativo actual, podemos reemplazar nuestro sistema operativo actual por Fedora o si ya utilizamos Fedora como sistema operativo principal no hay necesidad de reinstalarlo, la 煤ltima opci贸n es instalarlo en una maquina virtual, si eres usuario windows probablemente esta opci贸n es la m谩s adecuada para ti.\nUna maquina virtual es un entorno que permite ejecutar un sistema operativo adicional sobre uno ya en ejecuci贸n, el sistema adicional se conoce como \u0026ldquo;huesped\u0026rdquo;(guess) y el que ya esta en ejecuci贸n se le denomina \u0026ldquo;anfitri贸n\u0026rdquo;(host), de esta manera podemos instalar Fedora sin la necesidad de modificar nuestro sistema operativo actual.\nProcedemos a instalar la maquina virtual, para ello visitamos el enlace https://www.virtualbox.org/\ny descargamos la versi贸n m谩s reciente para nuestro sistema operativo anfitrion(probablemente windows), no entrare en detalles sobre como instalar virtual box puesto que cada sistema es diferente, pero confi贸 en que sabes como instalar programas en tu sistema, para instalarlo en windows doble click sobre el ejecutable descargado, si eres usuario linux seguramente viene en los repositorios oficiales de tu distribuci贸n.\nAhora descargaremos Fedora, accedemos al enlace\nhttps://getfedora.org/es/\nexisten varias ediciones, elegimos Workstation y la descargamos, la descarga es una imagen .iso de alrededor de 2GB, una vez descargado procedemos a instalar.\nAbrimos Virtualbox y seleccionamos \u0026ldquo;nueva\u0026rdquo;\nSe abrir谩 una nueva ventana escribimos \u0026ldquo;Fedora\u0026rdquo; en nombre, carpeta la dejamos por defecto, seleccionamos, tipo \u0026ldquo;Linux\u0026rdquo; y Versi贸n \u0026ldquo;Fedora (64-bit)\u0026rdquo;, click en siguiente.\nAhora nos pide configurar la memoria, aqui aparece un control de deslizamiento, selecciona por lo menos 2GB y da click en siguiente.\nAhora nos pide configurar un nuevo disco duro, seleccionamos \u0026ldquo;Crear un disco virtual Ahora\u0026rdquo; y damos click en siguiente.\nTipo de archivo de disco duro, VDI, siguiente.\nAlmacenamiento en unidad de disco duro f铆sica, Reservado din谩micamente, siguiente.\nUbicaci贸n del archivo y tama帽o, dejamos la ubicaci贸n por defecto y seleccionamos un tama帽o de 20GB, siguiente.\nHemos finalizado la creaci贸n de la maquina virtual, procedemos a instalar Fedora en el siguiente post.\n"}),a.add({id:38,href:'/posts/about/',title:"About",section:"Posts",content:"This is an example of a page. Unlike posts, which are displayed on your blogs front page in the order theyre published, pages are better suited for more timeless content that you want to be easily accessible, like your About or Contact information. Click the Edit link to make changes to this page or add another page.\n"})})()