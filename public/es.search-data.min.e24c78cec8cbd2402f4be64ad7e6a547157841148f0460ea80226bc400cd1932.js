'use strict';(function(){const b={cache:!0};b.doc={id:'id',field:['title','content'],store:['title','href','section']};const a=FlexSearch.create('balance',b);window.bookSearchIndex=a,a.add({id:0,href:'/eleckia/docs/workstation/',title:"Estaci√≥n de trabajo",section:"Docs",content:"Hay que trabajar, hay que aprender, hay que comer, hay que descansar y tambi√©n hay que jugar, esas son las bases del entrenamiento del maestro Roshi para tener una buena condici√≥n.\nKame Senin.\n"}),a.add({id:1,href:'/eleckia/docs/avr/',title:"Programaci√≥n Avr en C.",section:"Docs",content:"Programando avr en C #  Una l√≠nea de Othello sobre un bebedor, ahora un hombre sensible; por el alcohol se convierte en bestia, eso lo explica todo.\nBarney G√≥mez.\nEn esta secci√≥n introduzco algunos conceptos de C que considero necesarios para programar.\n"}),a.add({id:2,href:'/eleckia/docs/avr/programando-avr-en-c-arreglos/',title:"Programando Avr en C. Arreglos.",section:"Programaci√≥n Avr en C.",content:"Los arreglos o arrays son elementos que permiten hacer colecciones de datos del tipo indicado, su uso es amplio en pr√°cticamente todos los lenguajes de programaci√≥n, en C los arreglos se declaran con la siguiente sintaxis,\ntipo_dato nombre_array[TAMA√ëO]; Por ejemplo para declarar un arreglo de 5 enteros llamado horas:\nint horas[5]; Para declarar un arreglo de 3 boleanos llamado respuestas:\n#include\u0026lt;stdbool.h\u0026gt; bool respuestas[3]; Los arreglos pueden ser de cualquier tipo de dato. El n√∫mero entre corchetes (par√©ntesis cuadrados) indica la cantidad de elementos que puede almacenar, en el caso del arreglo horas, este puede almacenar hasta 5 enteros, la forma de asignar los valores es la siguiente:\nint horas[5] = {1, 2, 1, 2, 3}; //o tambi√©n int horas[5]; horas[0] = 1; horas[1] = 2; horas[2] = 1; horas[3] = 2; horas[4] = 3; Ambas asignaciones resultaran en los mismos enteros para el arreglo, n√≥tese que cuando asignamos los valores, la primera posici√≥n es cero y no uno, esto implica que la √∫ltima posici√≥n sea cuatro y no cinco, si asign√°ramos horas[5] = 4; obtendr√≠amos un error en tiempo de ejecuci√≥n, este error es muy diferente de el error en tiempo de compilaci√≥n, de hecho el programa compilara sin error, pero si se intenta ejecutar dentro del microcontrolador la ejecuci√≥n sera err√°tica, probablemente el programa se reinicie al tratar de ejecutar la instrucci√≥n o tal vez se detenga en ese instante, o tal vez no pase nada, depende de la forma en que se organiza la memoria en el micro, por lo tanto hay que tener cuidado en no rebasar el indice, el m√°ximo es igual a el tama√±o menos uno.\nArreglos y apuntadores. #  Los arreglos y apuntadores tienen una relaci√≥n importante, el nombre de un arreglo es un apuntador que apunta a la direcci√≥n del primer elemento o elemento cero,\nint numeros[2] = {1, 4}; int a = *numeros + numeros[1]; //a contendra el valor de 5 A pesar de esta equivalencia, prefiero utilizar los corchetes cuando de arreglos se trata, esto me evita la sobrecargar de conceptos en la cabeza y me permite diferenciar claramente el prop√≥sito de un arreglo y el de un apuntador, con el arreglo quiero manejar una colecci√≥n de datos, mientras que con los apuntadores quiero manejar el acceso a objetos individuales.\n"}),a.add({id:3,href:'/eleckia/posts/principio-de-responsabilidad-unica-srp/',title:"Principio de responsabilidad √∫nica (SRP)",section:"Posts",content:"En el desarrollo √°gil, el principio de responsabilidad √∫nica es uno de los cinco principios fundamentales, el principio define lo siguiente:\nUn m√≥dulo debe tener un solo motivo para cambiar.\nY eso es todo, ¬øf√°cil no?, yo tambi√©n lo creo, ¬øqu√© es lo que creo?, no lo entiendo. Vamos por partes, las palabras son obvias, pero la frase es un poco ambigua, el meollo del asunto es claramente un solo motivo para cambiar, podemos apoyarnos en el nombre del principio, responsabilidad √∫nica, mmm parece ser que ambas frases se refieren a lo mismo, ¬øa qu√© mismo?, mmm, lo que esta claro es que un m√≥dulo solo debe tener una sola responsabilidad, por ejemplo suponiendo que requerimos un sistema que controle el movimiento de un robot m√≥vil, el robot puede ir hacia adelante, atr√°s y rotar las ruedas de direcci√≥n, una forma de visualizarlo es la siguiente,\nSeparaci√≥n obvia.\nSe sugiere una separaci√≥n de responsabilidades, en lugar de que el m√≥dulo robot_posici√≥n administre el avance, retroceso y giro, separamos las responsabilidades y las asignamos a nuevos m√≥dulos, esta separaci√≥n es lo primero que se me vino a la mente, ¬øpero esta separaci√≥n es la m√°s adecuada?, las repuesta no es evidente ni definitiva, es aqu√≠ donde recurrimos a la definici√≥n un solo motivo para cambiar, los m√≥dulos traslaci√≥n y rotaci√≥n cumplen con el principio srp, solo si al requerir una nueva caracter√≠stica, solo uno de los dos m√≥dulos necesita modificarse.\nSuponiendo que los requerimientos cambian y que se requiere que la velocidad a la que se mueve el robot hacia adelante y atr√°s sea controlable, es evidente que el m√≥dulo traslaci√≥n sera el √∫nico que cambie, por lo tanto la separaci√≥n que se realizo es adecuada y cumple con el principio srp.\nAhora suponiendo que la especificaci√≥n cambia, se desea que el robot tenga movimiento continuo, es decir que el robot avance hacia adelante o atr√°s mientras est√° rotando. Ahora nuestros m√≥dulos no cumplen con el principio, pues ambos deben ser modificados para alcanzar los nuevos requerimientos, este ser√° un buen momento para replantear nuestra anterior separaci√≥n en m√≥dulos, una refactorizaci√≥n nos da el siguiente modelo,\nDe esta manera velocidad solo se encarga de mover los motores avance y de retroceso, tren_de_giro se encarga de girar un motor de direcci√≥n o el ajuste necesario dependiendo de la forma del robot.\nCon esto quiero decir que los m√≥dulos deben agruparse de tal forma que las razones por las que cambian est√©n juntas, con esto logramos que al agregar nuevos cambios, solo debamos modificar el m√≠nimo de m√≥dulos.\n¬øY cuales son esas razones de cambio?, la respuesta es el cliente, el usuario, si el cliente del m√≥dulo hace una nueva especificaci√≥n que implique un cambio y para lograr la implementaci√≥n se requieren modificar m√°s de un m√≥dulo se debe replantear la forma y el tama√±o de los m√≥dulos.\nRepito, el objetivo del SRP es proveer una forma de \u0026ldquo;modularizar\u0026rdquo; el programa en base a peticiones de cambios, aunque exista la tentaci√≥n de agrupar m√≥dulos por forma, color, sabor, etc, que pudieran parecer m√°s naturales, agrupar por motivos de cambios, nos dar√° como resultado un software altamente √°gil en el sentido de nuevas caracter√≠sticas.\nEn el ejemplo anterior, ¬øque sentido tendr√≠a mezclar el c√≥digo de control de posici√≥n con el c√≥digo de control visi√≥n del robot?, si nosotros requerimos modificar el contraste o el brillo de la imagen, ¬øser√≠a necesario modificar la velocidad del robot?, las respuesta obvia es que no, sin embargo piensa que las c√°maras aveces son muy lentas, quiz√° requerimos tomar una imagen cuando el robot se acerque a un objeto, entonces si la c√°mara es lenta necesariamente requerimos bajar la velocidad, ni modo, es triste, pero debemos refactorizar los m√≥dulos en har√°s de lograr el objetivo.\nEl SRP es el principio m√°s sencillo de describir, pero el m√°s dif√≠cil de asimilar, requiere pr√°ctica, esfuerzo, experiencia y mucha meditaci√≥n.\n"}),a.add({id:4,href:'/eleckia/posts/solid/',title:"SOLID",section:"Posts",content:"_Soy malo y eso es bueno, yo jam√°s ser√© bueno y eso no es malo, no hay nadie que quiera ser adem√°s de mi. #  - Ralph el demoledor._\nSOLID #  Dentro del mundo de la programaci√≥n existen los famosos paradigmas de programaci√≥n, entre ellos: la programaci√≥n funcional, la programaci√≥n orientada a eventos, la programaci√≥n estructurada, la programaci√≥n orientada a objetos y otros m√°s. En esta fecha 2020, la programaci√≥n orientada a objetos sin duda domina la forma en que se escribe el software en general, vale la pena aprender este paradigma pues no ser√° raro encontrarnos con programas basados en √©l.\nEl √©xito de la programaci√≥n orientada a objetos, se basa en la abstracci√≥n de objetos, ¬øqu√© es la abstracci√≥n de objetos?, personalmente la defino como una combinaci√≥n entre imaginar, separar y simplificar, es decir tomamos un objeto real por ejemplo un motor, identificamos lo que nos interesa por ejemplo la velocidad y la direcci√≥n de giro y descartamos el resto de detalles, el tipo de motor, la potencia, la tensi√≥n de entrada, el par, marca, color, peso, etc, este motor que √∫nicamente gira a la velocidad y direcci√≥n indicada, es una abstracci√≥n de un motor real, esto que parece tan trivial tiene la cualidad de simplificar la forma en que se resuelven los problema, pues los humanos estamos adaptados a pensar en objetos abstractos.\nDentro de la programaci√≥n orientada a objetos han surgido diferentes corrientes de desarrollo, en los √∫ltimos a√±os el desarrollo √°gil gano una popularidad importante. En las catacumbas de un lugar de cuyo nombre no quiero acordarme, se reuni√≥ un grupo de programadores con gran experiencia en el desarrollo de software, conspirando en contra de la t√©cnicas tradicionales escribieron el manifiesto √°gil,\nhttps://agilemanifesto.org/iso/es/manifesto.html\nuna vez popularizado el desarrollo √°gil comenzaron a desarrollarse numerosas metodolog√≠as de trabajo, entre ellas: scrum, kaban, xp, tdd, etc, como mencione las personas funcionamos en base a abstracciones por lo que las metodolog√≠as √°giles pueden salir del mundo de la programaci√≥n e implementarse en otros rubros de la humanidad.\nPersonalmente yo no me sent√≠ seguro con mi c√≥digo hasta que aprend√≠ TDD (Test Driven Development), Desarrollo Guiado por Pruebas.\nAqu√≠ tratare de describir los cinco principios fundamentales del desarrollo √°gil, acu√±ados por Robert C. Martin, Agile Software Development, Principles, Patterns, and Practices. Es un excelente referencia para cualquiera que pretenda aprender a programar.\nSOLID es un acr√≥nimo formador por los cinco principios del desarrollo √°gil.\nS Single responsibility principle (Principio de responsabilidad √∫nica)\nO Open/closed principle (Principio Abierto/Cerrado)\nL Liskov substitution principle (Principio de sustituci√≥n de Liskov)\nI Interface segregation principle (Principio de segregaci√≥n de la interfaz)\nD Dependency inversion principle (Principio de inversi√≥n de dependencia)\nSi cumplimos con estos principios dentro de nuestro c√≥digo, entonces podemos decir que nuestro c√≥digo es √°gil\n Sigue mi blog #  Recibe nuevo contenido directamente en tu bandeja de entrada.\n[jetpack_subscription_form subscribe_placeholder=\u0026ldquo;Introduce tu direcci√≥n de correo electr√≥nico\u0026rdquo; show_subscribers_total=\u0026ldquo;false\u0026rdquo; button_on_newline=\u0026ldquo;false\u0026rdquo; submit_button_text=\u0026ldquo;Registrarse\u0026rdquo; custom_background_emailfield_color=\u0026ldquo;undefined\u0026rdquo; custom_background_button_color=\u0026ldquo;undefined\u0026rdquo; custom_text_button_color=\u0026ldquo;undefined\u0026rdquo; custom_font_size=\u0026ldquo;16\u0026rdquo; custom_border_radius=\u0026ldquo;0\u0026rdquo; custom_border_weight=\u0026ldquo;1\u0026rdquo; custom_border_color=\u0026ldquo;undefined\u0026rdquo; custom_padding=\u0026ldquo;15\u0026rdquo; custom_spacing=\u0026ldquo;10\u0026rdquo; submit_button_classes=\u0026quot;\u0026quot; email_field_classes=\u0026quot;\u0026quot; show_only_email_and_button=\u0026ldquo;true\u0026rdquo; ]\n"}),a.add({id:5,href:'/eleckia/posts/electronica/',title:"Electr√≥nica",section:"Posts",content:"Ah, ¬øpero que oigo?, una intromisi√≥n, debe ser #  Lisa Simpson, la respuesta a una pregunta que\nnunca hizo nadie.\n-Ned Flanders\n Sigue mi blog #  Recibe nuevo contenido directamente en tu bandeja de entrada.\n[jetpack_subscription_form show_only_email_and_button=\u0026ldquo;true\u0026rdquo; custom_background_button_color=\u0026ldquo;undefined\u0026rdquo; custom_text_button_color=\u0026ldquo;undefined\u0026rdquo; submit_button_text=\u0026ldquo;Suscribir\u0026rdquo; submit_button_classes=\u0026ldquo;undefined\u0026rdquo; show_subscribers_total=\u0026ldquo;false\u0026rdquo; ]\n"}),a.add({id:6,href:'/eleckia/docs/avr/programando-avr-en-c-apuntadores-punteros-pointers-ii-apuntadores-dobles/',title:"Programando Avr en C.- Apuntadores, punteros, pointers III. Apuntadores Dobles.",section:"Programaci√≥n Avr en C.",content:"Los apuntadores suenan bastante complejos, nuestro cerebro amplifica su complejidad, pero al igual que cualquier otra variable su funcionamiento es simple,\ntipo ** nombre_apuntador; a que me refiero con apuntador doble, a un apuntador que guarda direcciones de otros apuntadores de su mismo tipo,\nchar caracter1 = 'a'; char caracter2 = 'b'; char \\* letra = \u0026amp;caracter1; char \\*\\* apuntador\\_doble = \u0026amp;letra; \\*apuntador\\_doble = \u0026amp;caracter2; //ahora letra apunta a la direcci√≥n de caracter2, //\\*letra es 'b' el prop√≥sito evidente de los apuntadores dobles, es cambiar el valor a donde apuntan apuntadores simples,\nint \\* pointer1=NULL; int \\* pointer2=NULL; void updatePointers(int \\*\\* a, int \\*\\* b) { \\*a = direction\\_1; \\*b = direction\\_2; } //ahora los apuntadores apuntan a las //direcciones en direction\\_n Esta aplicaci√≥n es muy sencilla, la usaremos con frecuencia.\n"}),a.add({id:7,href:'/eleckia/docs/avr/programando-avr-en-c-apuntadores-punteros-pointers-ii-apuntadores-a-funciones/',title:"Programando Avr en C.- Apuntadores, punteros, pointers II. Apuntadores a funciones.",section:"Programaci√≥n Avr en C.",content:"Como ya he dicho un apuntador es una variable que apunta a direcciones de memoria, tambi√©n hemos mencionado que los apuntadores deben ser especificados sobre el tipo, cuando las funciones se compilan se les asigna una direcci√≥n en memoria, ¬øexistir√°n apuntadores a funciones?, la respuesta es afirmativa, la sintaxis es un poco rara,\ntipo (*nombre_apuntador)(argumento1, argumento2, ..., argumento_n); al igual que los apuntadores comunes, los apuntadores a funciones deben ser especificados con el tipo de dato que regresan, entre parentesis se coloca el operador * seguido del nombre del apuntador, finalmente se especifican los par√°metros)\nint (\\*operacion)(int a, int b); int suma(int a, int b) { return a + b; } int resta(int a, int b) { return a - b; } int a = 5; int b = 10; if(condicion) operacion = suma; else operacion = resta; int c = operacion(a , b); /\\* S√≠ condici√≥n es verdadera c contendr√° 15 de \\* lo contrario c contendr√° -5 \\*/ gracias a los apuntadores a funciones, tambi√©n es posible pasar funciones como argumentos de otras funciones,\nint operadorBinario(int (\\*operation)(int a, int b), int c, int d) { return operation(c,d); } int resultado = operadorBinario(suma, 5, 10); //resultado es igual a 15 resultado = operadorBinario(resta, 5, 10); //resultado = -5; Esta caracter√≠stica nos ayudara a mejorar la calidad del c√≥digo.\n"}),a.add({id:8,href:'/eleckia/docs/avr/programando-avr-en-c-apuntadores-punteros-pointers/',title:"Programando Avr en C.- Apuntadores, punteros, pointers I.",section:"Programaci√≥n Avr en C.",content:"Los apuntadores (pienso que esta es la traducci√≥n m√°s acertada), tambi√©n conocidos como punteros o pointers en ingles, es un tipo de dato caracter√≠stico de lenguajes de bajo nivel y algunos de nivel medio, C por supuesto cuenta con tal tipo de dato.\nUn apuntador es una variable cuyo tipo de dato almacena direcciones de memoria, tan simple como eso. Aunque una direcci√≥n de memoria puede ser interpretada como un entero, es mejor pensar que una direcci√≥n de memoria es un tipo de dato diferente, un tipo de dato de tipo apuntador.\nLos apuntadores son temidos y exaltados, por buenas razones, el problema es que los apuntadores sirven para gran cantidad de aplicaciones y da la impresi√≥n de que debes conocerlas todas, por supuesto no es as√≠, se puede usar apuntadores de forma efectiva sin tener todo el bagaje t√©cnico alrededor, e ir aprendiendo gradualmente los pormenores. El secreto esta en auto limitarse y ser disciplinado.\nla sintaxis para declarar un apuntador es la siguiente\ntipo_a_donde_apunta * nombre_apuntador; un apuntador que apunta a una variable de tipo entero es diferente a un apuntador que apunta a una variable de tipo car√°cter,\nchar a; int b; int * apuntador1; // solo puede apuntar hacia b, apuntar hacia a implica un error Operador addressOff \u0026amp; #  Para almacenar la direcci√≥n de una variable primero debemos obtener su direcci√≥n, para ello contamos con el operador \u0026amp;,\nint b = 0; int * apuntador = \u0026amp;b; //apuntador ahora contiene la direcci√≥n de memoria de b Operador de indirecci√≥n * #  ¬øPara que se usa un apuntador?, como mencione las aplicaciones son amplias, pero la base es la misma, se trata de acceder al contenido guardado en una direcci√≥n de memoria de manera indirecta. Una vez establecido un apuntador, usamos el operador de indirecci√≥n para acceder al contenido a donde apunta.\nint b = 0; int * apuntador = \u0026amp;b; *apuntador = 10; //ahora b contiene el valor 10 y no 0. Una de las aplicaciones m√°s importantes es el paso de par√°metros a funciones, cuya intensi√≥n sea modificar tales par√°metros, por ejemplo\nint a = 5; int b= 3; //Se pasan dos apuntadores intercambiar(\u0026amp;a, \u0026amp;b); //pasar \u0026amp;a, es equivalente a crear un apuntador //int *apuntador = \u0026amp;a y escribir intercambiar(apuntador, \u0026amp;b); //ahora a = 3 y b = 5; void intercambiar(int * v1, int * v2) { int tmp = *v1;//tmp = valor guardado en la //direcci√≥n a donde apunta v1 *v1 = *v2; *v2 = tmp; } Usaremos ampliamente la forma de la funci√≥n intercambiar, por ahora es suficiente con este conocimiento sobre apuntadores, por supuesto m√°s adelante veremos otras aplicaciones.\n"}),a.add({id:9,href:'/eleckia/posts/contacto/',title:"Contacto",section:"Posts",content:"Hablemos üëã. No dudes en ponerte en contacto con nosotros mediante la informaci√≥n de contacto a continuaci√≥n, o env√≠anos un mensaje mediante el formulario.\nPonte en contacto con nosotros #  Calle Ejemplo, 10\nCiudad, 10100\nEspa√±a\ncorreoelectronico@ejemplo.com\n(+34) 399 555 234\nEnv√≠anos un mensaje #  "}),a.add({id:10,href:'/eleckia/posts/gpio-atmega328p/',title:"GPIO atmega328p.",section:"Posts",content:"_Si, se nos acabo la duela y pintamos la tierra, ¬øqu√© trucazo no? #  Moe Szyslak_\n Sigue mi blog #  Recibe nuevo contenido directamente en tu bandeja de entrada.\n[jetpack_subscription_form subscribe_placeholder=\u0026ldquo;Direcci√≥n de correo electr√≥nico\u0026rdquo; show_subscribers_total=\u0026ldquo;false\u0026rdquo; button_on_newline=\u0026ldquo;true\u0026rdquo; submit_button_text=\u0026ldquo;Suscribir\u0026rdquo; custom_background_emailfield_color=\u0026ldquo;undefined\u0026rdquo; custom_background_button_color=\u0026ldquo;undefined\u0026rdquo; custom_text_button_color=\u0026ldquo;undefined\u0026rdquo; custom_font_size=\u0026ldquo;16\u0026rdquo; custom_border_radius=\u0026ldquo;0\u0026rdquo; custom_border_weight=\u0026ldquo;1\u0026rdquo; custom_border_color=\u0026ldquo;undefined\u0026rdquo; custom_padding=\u0026ldquo;15\u0026rdquo; custom_spacing=\u0026ldquo;10\u0026rdquo; submit_button_classes=\u0026ldquo;has-text-color has-background-color has-background has-primary-background-color\u0026rdquo; email_field_classes=\u0026quot;\u0026quot; show_only_email_and_button=\u0026ldquo;true\u0026rdquo; ]\n"}),a.add({id:11,href:'/eleckia/docs/avr/programando-avr-en-c-el-flujo-del-programa-if-else-if-else/',title:"Programando Avr en C.- El flujo del programa, if, else, if else.",section:"Programaci√≥n Avr en C.",content:"Definimos el flujo del programa como, la ruta que toma la ejecuci√≥n del mismo, imaginemos que tenemos una lista de tareas que debemos ejecutar, digamos, tarea 1, tarea 2, tarea 3, \u0026hellip;, tarea n, ya vimos que podemos abstraer tareas como funciones, entonces simplemente podemos agregar cada una de las funciones en orden para ejecutarlas,\nint main(void) { tarea1(); tarea2(); tarea3(); tarean(); return 0; } pero que pasa si queremos ejecutar alguna de estas tareas solo si se cumple una condici√≥n, digamos, solo si se pulsa un bot√≥n determinado, o solo si el resultado de una operaci√≥n satisface alg√∫n requerimiento.\nPara ello contamos con la palabra if, si se cumple una condici√≥n, el c√≥digo dentro de sus llaves se ejecutara, de lo contrario el programa continuara despu√©s de la llave de cierre,\nint main(void) { tarea1(); if(condicion){ //si condici√≥n es verdadera tarea2(); //se ejecutaran √©sta dos tareas tarea3(); } tarea4(); //Aqu√≠ continua tarean(); return 0; } tambi√©n es posible agregar la palabra else, para controlar el flujo cuando la condici√≥n es falsa\nint main(void) { tarea1(); if(condicion){ //si condici√≥n es verdadera tarea2(); //se ejecutara √©sta tarea }else{ tarea3(); //si condici√≥n es falsa, ejecuta √©sta tarea } tarea4(); tarean(); return 0; } agregar m√°s sentencias nos permite un control aun m√°s preciso.\nint main(void) { tarea1(); if(condicion == 0){ //si condici√≥n es igual a 0 tarea2(); //se ejecutara √©sta tarea }else if(condicion == 1){ tarea3(); //si condici√≥n igual a 1, ejecuta √©sta tarea }else{ tarea4(); //si no se cumple ninguna de las anteriores } tarean(); return 0; } es importante se√±alar que la ejecuci√≥n es en orden descendente, si tenemos varios if else y en m√°s de uno se cumple la condici√≥n, solo se ejecutara el primero que la cumpla en orden descendente.\nint main(void) { tarea1(); if(true){ tarea2(); //se ejecutara √©sta tarea }else if(true){ tarea3(); //No se ejecuta }else{ tarea4(); //No se ejecuta } tarean(); //una vez ejecutada tarea2, el programa continua aqu√≠ return 0; } "}),a.add({id:12,href:'/eleckia/docs/avr/programando-avr-en-c-constantes/',title:"Programando Avr en C.- Constantes",section:"Programaci√≥n Avr en C.",content:"Las constantes son de gran utilidad en la programaci√≥n, a diferencia de las variables, las constantes no pueden cambiar su valor.\nLas dos formas m√°s comunes de definir constantes son con la palabra reservada const y con la directiva define.\nLa palabra const #  Agregando la palabra const a la declaraci√≥n de una variable, esta se convierte en constate, sin embargo tambi√©n debe asignarle el valor al momento de la declaraci√≥n;\nuint8_t const NUMERO = 10; //Declaraci√≥n de una constante NUMERO = 1; //error, no se puede reasignar Sin embargo el uso m√°s cotidiano que tiene la palabra const es en los argumentos de funciones,\nint8_t suma(int8_t const sumando1, int8_t const sumando2); Directiva define #  Entre otras cosas, la directiva define puede ser usada para definir constantes;\n#define NUMERO 10 cuando el programa se compilar, la palabra NUMERO, se reemplaza por el n√∫mero 10,\n#define PRIMERO 5 int8_t = 5 + PRIMERO; al compilar, sera reemplazado por\nint8_t = 5 + 5; Enum #  Los enum son un tipo de dato que nos facilit√° la creaci√≥n de colecciones de constantes, su sintaxis es\nenum NOMBRE{CONSTANTE1 = 0, CONSTANTE2, CONSTANTE3 = 5, CONSTANTE4}; de esta forma CONSTANTE1 es una variable de tipo enum NOMBRE y contiene el valor de 0, CONSTANTE2 contiene el valor 1 y CONSTANTE3 tiene el valor de 5 y CONSTANTE4 tiene el valor de 6.\nenum numeros{CERO, UNO, DOS}; a = CERO + UNO + DOS; //a contiene el n√∫mero 3 ¬øPor qu√© usar constantes? #  Hay dos conceptos al utilizar constantes, ser constante y querer ser constante.\nSer constante se refiere a declarar una constante expl√≠citamente por ejemplo el n√∫mero PI, SQRT2, etc.\nQuerer ser constante, se refiere a evitar que las variables cambien por accidente su valor, por ejemplo las funciones suele recibir par√°metros constantes, se busca evitar que los par√°metros cambien su valor, esto tomara sentido cuando comentemos los apuntadores en entradas posteriores.\nMuchos lenguajes de programaci√≥n nuevos, definen a las variables como constantes (inmutable) y es el usuario quien expl√≠citamente declara una variable como variable (mutable), la raz√≥n principal como se menciona es reducir la posibilidad de a√±adir errores de programaci√≥n.\n"}),a.add({id:13,href:'/eleckia/docs/avr/programando-avr-en-c-tipo-de-dato-booleano-operadores-booleanos-y-de-comparacion/',title:"Programando Avr en C.- Tipo de dato Booleano, operadores booleanos y de comparaci√≥n.",section:"Programaci√≥n Avr en C.",content:"Tipo de dato Booleano #  Otro tipo de datos b√°sico es el tipo booleano, este tipo de dato puede contener unicamente dos valores, verdadero(true) o Falso(false), para tener acceso a este tipo de dato debemos incluir la biblioteca stdbool.h, la sintaxis es:\n#include\u0026lt;stdbool.h\u0026gt; //Para declarar una variable bool un\\_nombre; //Para definir un valor un\\_nombre = true; un\\_nombre = false; Es com√∫n asumir en C que cualquier valor diferente de cero o NULL es verdadero, sin embargo pienso que es mejor utilizar expl√≠citamente los valores true o false para denotar valores booleanos, por razones de legibilidad.\nOperadores booleanos #  Como el nombre sugiere, los operadores booleanos operan sobre tipos de dato booleanos. El operador and(\u0026amp;\u0026amp;) probablemente es el m√°s utilizado,\na \u0026amp;\u0026amp; b el resultado de la operaci√≥n previa dar√° verdadero solo si ambos, a y b son verdaderos, resulta falso de lo contrario. La regla es\nfalse and false //es igual a false true and false //es igual a false false and true //es igual a false true and true //es igual a true El operador or(||)\na || b el resultado de la operaci√≥n previa dar√° verdadero si a o b, o ambos son verdaderos, resulta falso de lo contrario. La regla or es\nfalse or false //es igual a false true or false //es igual a true false or true //es igual a true true or true //es igual a true El operador de negaci√≥n (!)\n!a resulta verdadero si a es falso, resulta falso si a es verdadero.\n!false //es igual a true !true //es igual a false Operadores de comparaci√≥n #  Los operadores de comparaci√≥n, comparan dos expresiones y eval√∫an el resultado como falso o verdadero, por ejemplo el operador de igualdad (==)\na = 10; //entero b = 10; //entero c = (a == b); //boleano verdadero d = ((a+1) == b); //¬ø11 es igual a 10? falso la variable c contendr√° verdadero, mientras que d sera falso pues 11 no es igual a 10.\notros operadores de comparaci√≥n se resumen a continuaci√≥n\n==\nIgual que\n!=\nDiferente de\n\u0026lt;\nmenor que\n\u0026gt;\nmayor que\n\u0026lt;=\nmenor o igual que\n\u0026gt;=\nmayor o igual que\n"}),a.add({id:14,href:'/eleckia/docs/avr/programando-avr-en-c-funciones/',title:"Programando Avr en C.- Funciones",section:"Programaci√≥n Avr en C.",content:"Las funciones son caracter√≠sticas fundamentales de cualquier lenguaje de programaci√≥n, inclusive existe un \u0026ldquo;estilo\u0026rdquo; de programaci√≥n llamado programaci√≥n funcional, veamos brevemente como funcionan las funciones en C. Una funci√≥n tiene la siguiente sintaxis en C,\ntipo_de_retorno nombre_de_funcion(tipo_dato argumento_n) { ... hacer_tareas ... return un_objeto_del_tipo_de_retorno; } las funciones pueden ser usadas como una forma de realizar tareas de manera reiterada, pueden recibir \u0026ldquo;n\u0026rdquo; cantidad de argumentos y retornar un valor, un ejemplo sencillo, definimos la funci√≥n suma,\nint8_t suma(int8_t sumando1, int8_t sumando2) { int8_t resultado = sumando1 + sumando2; return resultado; } esta funci√≥n simplemente suma los dos argumentos pasados en ella, para usarla se usa la sintaxis:\nint8_t numero = suma(3,2); al ejecutarse, la variable numero contendr√° el valor de 5, las funciones pueden retornar cualquier tipo de dato, incluso alguno definido por nosotros como veremos en el futuro.\nAhora que sabemos definir funciones sencillas, escribamos un programa sencillo donde la usemos.\n#include\u0026lt;avr/io.h\u0026gt; //No se usar√° #include\u0026lt;stdint.h\u0026gt; //Para int8\\_t int main(void) { int8\\_t numero = suma(2,3); return 0; } int8\\_t suma(int8\\_t sumando1, int8\\_t sumando2) { int8\\_t resultado = sumando1 + sumando2; return resultado; } Ahora compilamos y nos dar√° un error o probablemente no, si compilamos este programa con un compilador de C y sin el software de Arduino, nos mostrar un error donde se√±ala que la funci√≥n no fue declarada,\nprogram.c: In function ‚Äòint main()‚Äô: program.c:5:25: error: ‚Äòsuma‚Äô was not declared in this scope int8_t numero = suma(2,3); por definici√≥n lo m√°s recomendable es declarar cualquier objeto antes de usarlo, en nuestro c√≥digo la funci√≥n suma se declara y define al final del fichero, podr√≠amos reescribir la funci√≥n suma antes de la funci√≥n main, esto esta bien para programas peque√±os, sin embargo en programas grandes se vuelve una forma dif√≠cil de mantener, una forma m√°s adecuada es usar un prototipo, un prototipo es una forma de declarar una funci√≥n sin definirla, la sintaxis es similar a la definici√≥n de una funci√≥n pero sin llaves y sin cuerpo,\ntipo_de_retorno nombre_de_funcion(tipo_dato argumento_n); en el caso de nuestra funci√≥n suma su prototipo es\nint8_t suma(int8_t sumando1, int8_t sumando2); el prototipo debe tener el mismo nombre el mismo tipo de retorno y los mismos tipos de argumentos. Ahora agregando este prototipo antes de la funci√≥n main, podemos estar seguros de que no habr√° un error de compilaci√≥n, el compilador se encargara de buscar la definici√≥n en el resto del c√≥digo.\nArduino usa un compilador de C++ y probablemente no nos muestre ning√∫n error, debido a que autogenera los prototipos, personalmente por cuestiones de legibilidad, prefiero definirlos yo mismo.\nEn las siguientes entradas entenderemos las ventajas que se obtiene de esta separaci√≥n entre prototipo(declaraci√≥n) y la definici√≥n. El c√≥digo final es el siguiente:\n#include\u0026lt;avr/io.h\u0026gt; //No se usar√° #include\u0026lt;stdint.h\u0026gt; //Para int8\\_t int8\\_t suma(int8\\_t sumando1, int8\\_t sumando2);//Prototipo int main(void) { int8\\_t numero = suma(2,3);//Llamado a la funci√≥n return 0; } //Definici√≥n de la funci√≥n int8\\_t suma(int8\\_t sumando1, int8\\_t sumando2) { int8\\_t resultado = sumando1 + sumando2; return resultado; } al ejecutarse el programa el valor final de la variable numero sera 5.\n"}),a.add({id:15,href:'/eleckia/docs/perifericos/gpio/biblioteca7/',title:"Api Display Siete Segmentos",section:"GPIO",content:"Api para un display de siete segmentos #  Escribamos una biblioteca/api sencilla que nos permita configurar un n√∫mero en un display de 7 segmentos, el circuito es el siguiente,\nConexi√≥n Arduino-Display #  Contamos con un display de c√°todo com√∫n por lo tanto cada segmento se enciende con un voltaje alto en el pin correspondiente, es decir para encender el segmento \u0026ldquo;A\u0026rdquo; debemos configurar el pin digital D2 en alto. Evitamos la conexi√≥n en los pines D0 y D1, debido a que estos est√°n conectados al convertidor serial-usb, y pueden provocar problemas para subir el c√≥digo a la tarjeta.\nComo primer paso debemos incluir la biblioteca \u0026ldquo;avr/io.h\u0026rdquo;, para tener acceso a los puertos de GPIOx de entrada/salida, cuyos registros asociados son DDRx, PORTx, PINx.\n#include\u0026lt;avr/io.h\u0026gt;Ahora declaramos la funci√≥n principal, recordemos que la funci√≥n principal es llamada autom√°ticamente cuando el programa es ejecutado,\nint main(void) { return 0; } Dentro de las llaves del main configuramos los pines adecuados como salidas, para hacerlo requerimos saber a que pines del microcontrolador corresponden los pines del Arduino,\nfuente:(http://www.chicoree.fr/w/Arduino_sur_ATmega328P)\nEn la anterior imagen observamos la correspondencia entre los pines del Arduino y los del microcontrolador, por ejemplo el pin digital D2 es en realidad el pin PD2 del atmega328p, por ejemplo el pin digital D8 es en realidad el pin PB0 del atmega328p. Configuramos el registro DDRB y DDRD como salidas,\nDDRB |= (1\u0026lt;\u0026lt;PB0); DDRD |= (1\u0026lt;\u0026lt;PD2)|(1\u0026lt;\u0026lt;PD3)|(1\u0026lt;\u0026lt;PD4)| (1\u0026lt;\u0026lt;PD5)|(1\u0026lt;\u0026lt;PD6)|(1\u0026lt;\u0026lt;PD7); Ahora solo encendemos los leds, poniendo en alto los pines requeridos, por ejemplo para el n√∫mero cinco, encendemos los segmentos a,c,d,f,g.\nPara ello escribimos a los puertos PORTB y PORTD los pines indicados\nPORTB |= (1\u0026lt;\u0026lt;PB0); PORTD |= (1\u0026lt;\u0026lt;PD2)|(1\u0026lt;\u0026lt;PD4)|(1\u0026lt;\u0026lt;PD5)|(1\u0026lt;\u0026lt;PD7); El c√≥digo completo luce como el siguiente,\n#include\u0026lt;avr/io.h\u0026gt; int main(void) { DDRB |= (1\u0026lt;\u0026lt;PB0); DDRD |= (1\u0026lt;\u0026lt;PD2)|(1\u0026lt;\u0026lt;PD3)|(1\u0026lt;\u0026lt;PD4)| (1\u0026lt;\u0026lt;PD5)|(1\u0026lt;\u0026lt;PD6)|(1\u0026lt;\u0026lt;PD7); PORTB |= (1\u0026lt;\u0026lt;PB0); PORTD |= (1\u0026lt;\u0026lt;PD2)|(1\u0026lt;\u0026lt;PD4)|(1\u0026lt;\u0026lt;PD5)|(1\u0026lt;\u0026lt;PD7); return 0; } Compilamos y subimos.\nEl \u0026ldquo;estilo\u0026rdquo; en que hemos escrito nuestro programa es coloquialmente llamado hardcoding, debido a que nosotros especificamos tanto los valores como el flujo, usualmente lo que queremos es que el programa calcule los valores y elija el flujo, imaginemos que ahora requerimos una secuencia de n√∫meros en serie, comenzado con 1 y terminando en 9 y repetir esta secuencia 1000 veces, seria un poco tedioso cambiar uno por uno los estados de los segmentos, para evitar este trabajo nos apoyaremos en funciones y sentencias de flujo.\nBiblioteca #  Nuestro anterior programa sirve para dos cosas, para nada y para la basura, no hay ninguna diferencia con respecto a conectar los pines del display directamente a Vcc, requerimos funcionalidad, que el microcontrolador haga lo adecuado para mostrar cualquier n√∫mero indicado, con una interfaz del tipo\ndisplay7_showNumber(3); //Muestra el n√∫mero 3 en el display de esta forma podemos realizar una secuencia de n√∫meros\nint main(void) { while(1){ display7_showNumber(0); //delay  display7_showNumber(1); //delay  . . . display7_showNumber(9); //delay  } } El display mostrara los n√∫meros del 0 al 9 en orden ascendente, nuestro objetivo entonces es definir la funci√≥n display7_showNumber(short const number).\nAunque en este problema sencillo podemos programar la soluci√≥n de forma monol√≠tica(un solo fragmento de c√≥digo), es de utilidad desarrollarlo en forma modular, como en la siguiente figura\nDe tal forma que podemos utilizarla dentro de nuestra aplicaci√≥n con un simple include, pensar en forma modular tiene grandes ventajas y conforme crece el proyecto se vuelve la √∫nica forma sostenible de escribir c√≥digo, la primer gran ventaja es la posibilidad de reutilizar c√≥digo, seria absurdo escribir un controlador de 7 segmentos en cada proyecto nuevo, la segunda ventaja es la capacidad de extender el c√≥digo ya escrito, la tercer gran ventaja es que el c√≥digo es m√°s \u0026ldquo;mantenible\u0026rdquo;, entre muchas otras que se ir√°n comentando.\nPara nuestro prop√≥sito un m√≥dulo es un ente de software que est√° d√©bilmente acoplado, autocontenido y es altamente cohesivo, dicho de otra forma, la funci√≥n main no tiene conocimiento de las variables y funciones del m√≥dulo, salvo por un conjunto de funciones com√∫nmente llamadas interfaz. Una bonita interfaz para nuestro modulo puede ser\nvoid display7_init(void); void display7_showNumber(short const number); void display7_destroy(void); Elegir buenos nombres es una parte fundamental para que nuestro c√≥digo sea de alta calidad, estoy seguro que al leer las funciones anteriores de inmediato formaste una idea de lo que hacen y a que pertenecen. Sin pensarlo hemos llegado a uno de los grandes dogmas de la programaci√≥n y de la resoluci√≥n de problemas en general,\nDivide el problema en problemas m√°s peque√±os\nNi tardos ni perezosos modificamos nuestro programa y agregamos el m√≥dulo,\n#include\u0026lt;avr/io.h\u0026gt; void display7_init(void); void display7_showNumber(short number); void display7_destroy(void); int main(void) { DDRB |= (1\u0026lt;\u0026lt;PB0); DDRD |= (1\u0026lt;\u0026lt;PD2)|(1\u0026lt;\u0026lt;PD3)|(1\u0026lt;\u0026lt;PD4)| (1\u0026lt;\u0026lt;PD5)|(1\u0026lt;\u0026lt;PD6)|(1\u0026lt;\u0026lt;PD7); PORTB |= (1\u0026lt;\u0026lt;PB0); PORTD |= (1\u0026lt;\u0026lt;PD2)|(1\u0026lt;\u0026lt;PD4)|(1\u0026lt;\u0026lt;PD5)|(1\u0026lt;\u0026lt;PD7); return 0; } void display7_init(void) { } void display7_showNumber(short number) { } void display7_destroy(void) { } Este c√≥digo compila sin problemas pero no hace el trabajo requerido, al principio agregamos los prototipos del m√≥dulo, pero aun no los llamamos en la funci√≥n main, tampoco hemos implementado dichas funciones. Antes de definir la interfaz, anteriormente indique que la funci√≥n main no tiene conocimiento de las funciones y variables de nuestro m√≥dulo, si escribimos el c√≥digo en el mismo fichero, el usuario de la funci√≥n main tendr√° a la vista todas las funciones y variables y probablemente tenga la tentaci√≥n de usarlas, una buena idea para evitar que esto suceda es utilizar un par de archivos extra exclusivos para nuestro m√≥dulo.\nCrear la biblioteca #  No se si ya lo hab√≠a mencionado pero odio el entorno de desarrollo de Arduino, en esta ocasi√≥n por la forma tan pobre de manejar ficheros. Continuando, vamos a mover nuestro m√≥dulo en un par de archivos, creamos dos ficheros cuyo nombre deje en claro que hay escrito en √©l, un buen nombre es display7,\n$touch display7.c $touch display7.h Ahora en nuestro entorno de desarrollo incluimos los dos ficheros, para ello vamos al men√∫ Programa-\u0026gt;A√±adir fichero y a√±adimos ambos ficheros, ambos aparecer√°n en nuestro entorno de desarrollo y podr√°n ser editados desde el mismo, movemos desde el fichero principal el m√≥dulo hacia los nuevos ficheros, los prototipos van en √©l .h y las definiciones al .c, de esta manera tenemos los tres ficheros siguientes\n//proyecto.ino #include\u0026lt;avr/io.h\u0026gt;int main(void) { DDRB |= (1\u0026lt;\u0026lt;PB0); DDRD |= (1\u0026lt;\u0026lt;PD2)|(1\u0026lt;\u0026lt;PD3)|(1\u0026lt;\u0026lt;PD4)| (1\u0026lt;\u0026lt;PD5)|(1\u0026lt;\u0026lt;PD6)|(1\u0026lt;\u0026lt;PD7); PORTB |= (1\u0026lt;\u0026lt;PB0); PORTD |= (1\u0026lt;\u0026lt;PD2)|(1\u0026lt;\u0026lt;PD4)|(1\u0026lt;\u0026lt;PD5)|(1\u0026lt;\u0026lt;PD7); return 0; } //display7.h void display7_init(void); void display7_showNumber(short number); void display7_destroy(void); //display7.c void display7_init(void) { } void display7_showNumber(short number) { } void display7_destroy(void) { } Nuevamente compilamos el programa y no nos dar√° ning√∫n error, salvo el peque√±o detalle de que no hace nada. Para poder acceder a la interfaz del m√≥dulo, es necesario incluirla en nuestro fichero principal, basta con agregar la directiva #include\u0026quot;display7.h\u0026quot; antes de la funci√≥n main, de esta forma el m√≥dulo puede ser desarrollado de forma independiente y paralela al programa principal, modifiquemos nuestro .ino para usar la interfaz\n#include\u0026lt;utils/delay.h\u0026gt;#include\u0026#34;display7.h\u0026#34; int main(void) { display7_init(); while(1){ display7_showNumber(0); _delay_ms(1000); display7_showNumber(1); _delay_ms(1000); } } Pienso que el c√≥digo se ve definitivamente m√°s limpio y muestra claramente que se est√° haciendo, sin embargo si tratamos de compilar nos dar√° un error, similar a este\nundefined reference to `display7_init()\u0026#39; En pocas palabras el compilador (en realidad el linker) no encuentra las definiciones del m√≥dulo, las definiciones est√°n en el fichero .c, como mencionamos en entradas anteriores el entorno Arduino en realidad compila ficheros C++, pero como somos tercos y queremos programar en C debemos indicarle al compilador que nuestros ficheros no son C++, esto es muy sencillo, basta con a√±adir\nextern \u0026#34;C\u0026#34; { En el fichero .h donde est√°n los prototipos y cerrar despu√©s del ultimo prototipo con un\n} El archivo .h queda\nextern \u0026#34;C\u0026#34; { void display7_init(void); void display7_showNumber(short const number); void display7_destroy(void); } Compilamos y esta vez no obtendremos ning√∫n error. De esta forma el compilador har√° lo adecuado para poder usar el m√≥dulo, la soluci√≥n sirve para nuestros prop√≥sitos, sin embargo en el futuro, desarrollaremos nuestros programas con un compilador de \u0026ldquo;C\u0026rdquo;, el compilador no entender√° la l√≠nea extern \u0026ldquo;C\u0026rdquo; y nos dar√° un error, ¬øc√≥mo hacemos que el m√≥dulo funcione con el compilador de C y tambi√©n con el de C++?, nuevamente la soluci√≥n es sencilla, cuando usamos un compilador de C++, este pasa una definici√≥n, explicitamente\n#define __cplusplus lo anterior no sucede cuando compilamos con un compilador de C, aprovechando esta definici√≥n podemos usar la directiva\n#ifdef ALGO  //si ALGO fue definido, coloca estas lineas #endif Modificamos el fichero .h y escribimos\n//display7.h #ifdef __cplusplus extern \u0026#34;C\u0026#34; { #endif  void display7_init(void); void display7_showNumber(short const number); void display7_destroy(void); #ifdef __cplusplus } #endif El fichero est√° casi listo, funciona con ambos compiladores, sin embargo tiene un gran problema, ¬øqu√© pasa si por error incluimos m√°s de una vez nuestra interfaz?, la respuesta es que nos indicara un error de doble declaraci√≥n, nuevamente nos apoyamos en la directiva #define, de la forma\n#ifndef MODULO #define MODULO  //Aqu√≠ las definiciones  #endif Significa, si no esta definido, define y coloca la interfaz, de lo contrario si ya esta definido no hagas nada, nuestra implementaci√≥n queda as√≠\n//display7.h #ifndef DISPLAY7_H #define DISPLAY7_H  #ifdef __cplusplus extern \u0026#34;C\u0026#34; { #endif  void display7_init(void); void display7_showNumber(short number); void display7_destroy(void); #ifdef __cplusplus } #endif #endif//DISPLAY7_H El fichero principal queda as√≠\n//proyecto.ino //Necesario para _delay_ms(), frecuencia de nuestro arduino #define F_CPU 16000000UL #include\u0026lt;util/delay.h\u0026gt; //Nos permite usar delay_ms()#include\u0026#34;display7.h\u0026#34; int main(void) { display7_init(); while(1){ display7_showNumber(0); _delay_ms(1000); display7_showNumber(1); _delay_ms(1000); } } Las definiciones est√°n en el fichero .c, debemos agregar la interfaz a este fichero tambi√©n con la directiva #include\n//display7.c #include\u0026#34;display7.h\u0026#34;void display7_init(void) { } void display7_showNumber(short const number) { } void display7_destroy(void) { } En un entorno de desarrollo decente el fichero .c nos hubiera dado problemas pues no esta permitido compilar una implementaci√≥n sin indicar a que interfaz pertenece, sin embargo el entorno de Arduino nos auto corrige el error, esto es otra cosa por lo que no me gusta Arduino, me oculta mis errores. Nuestro c√≥digo ahora luce m√°s modular en un diagrama luce as√≠\nComo se ve en la imagen ahora proyecto.ino (funci√≥n main) depende de la interfaz, mientras que display7.c la implementa, dicho de otra forma, proyecto.ino no sabe que hay en display7.c, el solo conoce lo que hay en display7.h, de esta manera podemos reutilizar el m√≥dulo en otros m√≥dulos, sin miedo a romper el c√≥digo fuera de √©ste y muy importante sin tener que reescribir c√≥digo extra.\nEstablecido lo anterior, ahora si nos toca implementar el m√≥dulo.\nImplementando la biblioteca #  Nuestro trabajo consiste en implementar las funciones del m√≥dulo contamos con un par de funciones, una para iniciar y otra para cerrar el m√≥dulo y una tercera para mostrar el n√∫mero, la interfaz es muy sencilla y para nuestro prop√≥sito es m√°s que suficiente. Algo que olvide mencionar y que es importante, la interfaz del m√≥dulo evoluciona, pues el desarrollo mismo provee realimentaci√≥n importante.\nEs muy com√∫n que los m√≥dulos contengan dos funciones, init y close o create y destroy, el trabajo de estas dos funciones es llevar al m√≥dulo a un estado conocido y liberar los recursos respectivamente. Para el m√≥dulo display7 ambas funciones son simples.\nEn la funci√≥n destroy, los recursos que se pueden liberar son los puertos y los pines, sin embargo en este caso es de poca utilidad, pues aunque liberemos los recursos nadie puede usarlos, esto no quiere decir que la funci√≥n destroy siempre sera tan simple, en m√≥dulos m√°s complejos tiene una importancia fundamental sobre todo la utilizar memoria din√°mica.\nLa funci√≥n init tiene la misi√≥n de establecer las condiciones adecuadas para que el resto del m√≥dulo pueda hacer su trabajo, modificara los registros de los puertos para establecerlos como salidas y con nivel bajo. Por ahora sabemos la correspondencia de los pines, pero ¬øqu√© pasa si los encargados del hardware deciden cambiar alguno o todos los pines?, m√°s adelante veremos este escenario.\nIniciemos tratando de configurar los dos primeros pines, PD2 y PD3, como salida y en nivel bajo,\n//display7.c #include \u0026#34;display7.h\u0026#34;#include \u0026lt;avr/io.h\u0026gt; void display7_init(void) { short pin = PD2; DDRD |= (1\u0026lt;\u0026lt;pin); PORTD \u0026amp;= ~(1\u0026lt;\u0026lt;pin); pin = PD3; DDRD |= (1\u0026lt;\u0026lt;pin); PORTD \u0026amp;= ~(1\u0026lt;\u0026lt;pin); } void display7_destroy(void) { } void display7_showNumber(short number) { } Excelente funciona para los dos, pero las dos asignaciones son pr√°cticamente id√©nticas, en la programaci√≥n la duplicaci√≥n de ideas debe evitarse pues es una fuente de errores. Se propone crear una funci√≥n que nos ayude a evitar la repetici√≥n.\n//display7.c #include \u0026#34;display7.h\u0026#34;#include \u0026lt;avr/io.h\u0026gt; static void setPinOutputAndLow(short const pin); void display7_init(void) { setPinOutputAndLow(PD2); setPinOutputAndLow(PD3); } static void setPinOutputAndLow(short const pin) { DDRD |= (1\u0026lt;\u0026lt;pin); PORTD \u0026amp;= ~(1\u0026lt;\u0026lt;pin); } void display7_destroy(void) { } void display7_showNumber(short const number) { } Mucho mejor, ¬øpero que pasa con el pin que pertenece al puerto B?, no podemos pasar PB0 al registro DDRD y PORTD, mi propuesta es \u0026ldquo;rotular\u0026rdquo; los pines del microcontrolador en una tabla y asignar su nemot√©cnico,\n//display7.c #include \u0026#34;display7.h\u0026#34;#include \u0026lt;avr/io.h\u0026gt; short const pin_table[28] = { PC6, /* pin 1*/ PD0, PD1, PD2, PD3, PD4, -1, -1, PB6, PB7, PD5, PD6, PD7, PB0, /*pin 14*/ PB1, PB2, PB3, PB4, PB5, -1, -1, -1, PC0, PC1, PC2, PC3, PC4, PC5, /*pin 28*/ }; static void setPinOutputAndLow(short const pin); void display7_init(void) { setPinOutputAndLow(4); //PD2 	setPinOutputAndLow(5); //PD3 	setPinOutputAndLow(14); //PB0 } static void setPinOutputAndLow(short const pin) { DDRD |= (1\u0026lt;\u0026lt;pin); PORTD \u0026amp;= ~(1\u0026lt;\u0026lt;pin); } void display7_destroy(void) { } void display7_showNumber(short const number) { } Ahora ajustaremos setPinOutputAndLow. Tenemos una tabla con cada uno de los pines, sacamos ventaja y discriminamos a los puertos por su agrupamiento.\nstatic void setPinOutputAndLow(short const pin) { if((pin \u0026gt;= 2 \u0026amp;\u0026amp; pin \u0026lt;= 6) || pin \u0026gt;= 11 \u0026amp;\u0026amp; pin \u0026lt;= 13){ //puertoD 	}else if(pin == 8 || pin == 9 || (pin \u0026gt;= 14 \u0026amp;\u0026amp; pin \u0026lt;= 19)){ //puertoB 	}else if(pin == 1 || (pin \u0026gt;= 23 \u0026amp;\u0026amp; pin \u0026lt;= 28)) //puertoC } F√°cil, ahora nos interesa modificar los registros correspondientes al puerto y el bit correspondiente al pin, para ello basta con acceder a la tabla con pin-1.\n#include \u0026#34;display7.h\u0026#34;#include \u0026lt;avr/io.h\u0026gt; short const pin_table[28] = { PC6, /* pin 1*/ PD0, PD1, PD2, PD3, PD4, -1, -1, PB6, PB7, PD5, PD6, PD7, PB0, /*pin 14*/ PB1, PB2, PB3, PB4, PB5, -1, -1, -1, PC0, PC1, PC2, PC3, PC4, PC5, /*pin 28*/ }; static void setPinOutputAndLow(short const pin); void display7_init(void) { i	setPinOutputAndLow(4); //PD2 	setPinOutputAndLow(5); //PD3 	setPinOutputAndLow(6); //PD4 	setPinOutputAndLow(11); //PD5 	setPinOutputAndLow(12); //PD6 	setPinOutputAndLow(13); //PD7 	setPinOutputAndLow(14); //PB0 } static void setPinOutputAndLow(short const pin) { if((pin \u0026gt;= 2 \u0026amp;\u0026amp; pin \u0026lt;= 6) || pin \u0026gt;= 11 \u0026amp;\u0026amp; pin \u0026lt;= 13){ DDRD |= (1\u0026lt;\u0026lt;pin_table[pin-1]); PORTD \u0026amp;= ~(1\u0026lt;\u0026lt;pin_table[pin-1]); }else if(pin == 8 || pin == 9 || (pin \u0026gt;= 14 \u0026amp;\u0026amp; pin \u0026lt;= 19)){ DDRB |= (1\u0026lt;\u0026lt;pin_table[pin-1]); PORTB \u0026amp;= ~(1\u0026lt;\u0026lt;pin_table[pin-1]); }else if(pin == 1 || (pin \u0026gt;= 23 \u0026amp;\u0026amp; pin \u0026lt;= 28)){ DDRC |= (1\u0026lt;\u0026lt;pin_table[pin-1]); PORTC \u0026amp;= ~(1\u0026lt;\u0026lt;pin_table[pin-1]); } } void display7_destroy(void) { } void display7_showNumber(short const number) { } Ceder la responsabilidad #  Funciona, hemos inicializado nuestros pines, ahora requerimos implementar la funci√≥n display7_showNumber, pero me gustar√≠a pasar todo el trabajo anterior a un nuevo m√≥dulo, requiero que display7 se encargue solo de mostrar los n√∫meros, no de malabarear los registros, la propuesta es la siguiente.\nDentro de gpio me interesan dos funciones,\ntypedef enum {INPUT, OUTPUT} DIRECTION; typedef enum {LOW, HIGH} LEVEL; void gpio_setDirection(short const pin, DIRECTION); void gpio_setLevel(short const pin, LEVEL); al m√°s puro estilo Arduino, as√≠ que trasladamos todo el trabajo de pines y registros, quedando los m√≥dulos como sigue:\n//display7.c #include \u0026#34;display7.h\u0026#34;#include \u0026#34;gpio.h\u0026#34; static void setPinOutputAndLow(short const pin); void display7_init(void) { setPinOutputAndLow(4); //PD2 	setPinOutputAndLow(5); //PD3 	setPinOutputAndLow(6); //PD4 	setPinOutputAndLow(11); //PD5 	setPinOutputAndLow(12); //PD6 	setPinOutputAndLow(13); //PD7 	setPinOutputAndLow(14); //PB0 } static void setPinOutputAndLow(short const pin) { gpio_setDirection(pin, OUTPUT); gpio_setLevel(pin, LOW); } void display7_destroy(void) { } void display7_showNumber(short const number) { } //gpio.h #ifndef GPIO_H #define GPIO_H typedef enum {INPUT, OUTPUT} DIRECTION; typedef enum {LOW, HIGH} LEVEL; void gpio_setDirection(short const pin, DIRECTION); void gpio_setLevel(short const pin, LEVEL); #endif // GPIO_H //gpio.c #include \u0026#34;gpio.h\u0026#34;#include \u0026lt;avr/io.h\u0026gt; short const pin_table[28] = { PC6, /* pin 1*/ PD0, PD1, PD2, PD3, PD4, -1, -1, PB6, PB7, PD5, PD6, PD7, PB0, /*pin 14*/ PB1, PB2, PB3, PB4, PB5, -1, -1, -1, PC0, PC1, PC2, PC3, PC4, PC5 /*pin 28*/ }; void gpio_setDirection(short const pin, DIRECTION direction) { if(direction == OUTPUT){ if((pin \u0026gt;= 2 \u0026amp;\u0026amp; pin \u0026lt;= 6) || pin \u0026gt;= 11 \u0026amp;\u0026amp; pin \u0026lt;= 13){ DDRD |= (1\u0026lt;\u0026lt;pin_table[pin-1]); }else if(pin == 8 || pin == 9 || (pin \u0026gt;= 14 \u0026amp;\u0026amp; pin \u0026lt;= 19)){ DDRB |= (1\u0026lt;\u0026lt;pin_table[pin-1]); }else if(pin == 1 || (pin \u0026gt;= 23 \u0026amp;\u0026amp; pin \u0026lt;= 28)){ DDRC |= (1\u0026lt;\u0026lt;pin_table[pin-1]); } }else if(direction == INPUT){ if((pin \u0026gt;= 2 \u0026amp;\u0026amp; pin \u0026lt;= 6) || pin \u0026gt;= 11 \u0026amp;\u0026amp; pin \u0026lt;= 13){ DDRD \u0026amp;= ~(1\u0026lt;\u0026lt;pin_table[pin-1]); }else if(pin == 8 || pin == 9 || (pin \u0026gt;= 14 \u0026amp;\u0026amp; pin \u0026lt;= 19)){ DDRB \u0026amp;= ~(1\u0026lt;\u0026lt;pin_table[pin-1]); }else if(pin == 1 || (pin \u0026gt;= 23 \u0026amp;\u0026amp; pin \u0026lt;= 28)){ DDRC \u0026amp;= ~(1\u0026lt;\u0026lt;pin_table[pin-1]); } } } void gpio_setLevel(short const pin, LEVEL level) { if(level == HIGH){ if((pin \u0026gt;= 2 \u0026amp;\u0026amp; pin \u0026lt;= 6) || pin \u0026gt;= 11 \u0026amp;\u0026amp; pin \u0026lt;= 13){ PORTD |= (1\u0026lt;\u0026lt;pin_table[pin-1]); }else if(pin == 8 || pin == 9 || (pin \u0026gt;= 14 \u0026amp;\u0026amp; pin \u0026lt;= 19)){ PORTB |= (1\u0026lt;\u0026lt;pin_table[pin-1]); }else if(pin == 1 || (pin \u0026gt;= 23 \u0026amp;\u0026amp; pin \u0026lt;= 28)){ PORTC |= (1\u0026lt;\u0026lt;pin_table[pin-1]); } }else if(level == LOW){ if((pin \u0026gt;= 2 \u0026amp;\u0026amp; pin \u0026lt;= 6) || pin \u0026gt;= 11 \u0026amp;\u0026amp; pin \u0026lt;= 13){ PORTD \u0026amp;= ~(1\u0026lt;\u0026lt;pin_table[pin-1]); }else if(pin == 8 || pin == 9 || (pin \u0026gt;= 14 \u0026amp;\u0026amp; pin \u0026lt;= 19)){ PORTB \u0026amp;= ~(1\u0026lt;\u0026lt;pin_table[pin-1]); }else if(pin == 1 || (pin \u0026gt;= 23 \u0026amp;\u0026amp; pin \u0026lt;= 28)){ PORTC \u0026amp;= ~(1\u0026lt;\u0026lt;pin_table[pin-1]); } } } la responsabilidad fue movida con √©xito, pero el modulo gpio dista de estar terminado, la duplicaci√≥n es obvia, esos if y else if se ven reducibles, se repiten 4 veces y son pr√°cticamente id√©nticos.\nMe apoyare de dos funciones locales, anteponiendo la palabra static en la declaraci√≥n le indicamos al compilador que el alcance de estas funciones √∫nicamente abarca el fichero, tambi√©n indicamos a la tabla de pines como local.\ntypedef enum {DIRECTION_TYPE, LEVEL_TYPE} REGISTER_TYPE; static char portOfPin(short const pin); static volatile uint8_t *registerOfPort(char const port, REGISTER_TYPE); la primer funci√≥n portOfPin indica en forma de car√°cter el puerto al que pertenece el pin:\nstatic char portOfPin(short const pin) { if((pin \u0026gt;= 2 \u0026amp;\u0026amp; pin \u0026lt;= 6) || pin \u0026gt;= 11 \u0026amp;\u0026amp; pin \u0026lt;= 13){ return \u0026#39;d\u0026#39;; }else if(pin == 8 || pin == 9 || (pin \u0026gt;= 14 \u0026amp;\u0026amp; pin \u0026lt;= 19)){ return \u0026#39;b\u0026#39;; }else if(pin == 1 || (pin \u0026gt;= 23 \u0026amp;\u0026amp; pin \u0026lt;= 28)){ return \u0026#39;c\u0026#39;; } } bastante simple. La segunda funci√≥n es m√°s compleja, los registros son direcciones de memoria en el microcontrolador, una clara diferencia de estos con respecto a otras localidades es que agentes externos puede cambiar el estado de los registros, port ejemplo el registro PIND puede ser cambiado por un pulsador en el pin PD1, para asegurar la consistencia de la ejecuci√≥n del programa utilizamos la palabra volatile en aquellas variables que apunten a un registro que puede ser cambiado externamente, entonces la funci√≥n registerOfPort retorna un apuntador a un registro y lo calificamos como volatile, la implementaci√≥n deja claro su funcionamiento,\nstatic volatile uint8_t * registerOfPort(char const port, REGISTER_TYPE type) { if(type == DIRECTION_TYPE){ if(port == \u0026#39;d\u0026#39;) return \u0026amp;DDRD; else if(port == \u0026#39;b\u0026#39;) return \u0026amp;DDRB; else if(port == \u0026#39;c\u0026#39;) return \u0026amp;DDRC; }else if(type == LEVEL_TYPE){ if(port == \u0026#39;d\u0026#39;) return \u0026amp;PORTD; else if(port == \u0026#39;b\u0026#39;) return \u0026amp;PORTB; else if(port == \u0026#39;c\u0026#39;) return \u0026amp;PORTC; } } vamos bien, ahora escribimos a los puertos, en el caso de establecer el pin como salida o entrada, obtenemos el puerto desde el pin, obtenemos el registro desde el puerto y finalmente actualizamos el registro.\nvoid gpio_setDirection(short const pin, DIRECTION direction) { char port = portOfPin(pin); volatile uint8_t *register_ = registerOfPort(port, DIRECTION_TYPE); if(direction == OUTPUT){ *register_ |= 1\u0026lt;\u0026lt;pin_table[pin-1]; }else if(direction == INPUT){ *register_ \u0026amp;=~(1\u0026lt;\u0026lt;pin_table[pin-1]); } } Quiz√° no sea la mejor implementaci√≥n, pero cumple bien su cometido y pienso que es clara y concisa, la implementaci√≥n completa es la siguiente:\n//gpio.c #include \u0026#34;gpio.h\u0026#34;#include \u0026lt;avr/io.h\u0026gt; static short const pin_table[28] = { PC6, PD0, PD1, PD2, PD3, PD4, -1, -1, PB6, PB7, PD5, PD6, PD7, PB0, PB1, PB2, PB3, PB4, PB5, -1, -1, -1, PC0, PC1, PC2, PC3, PC4, PC5 }; typedef enum {DIRECTION_TYPE, LEVEL_TYPE} REGISTER_TYPE; static char portOfPin(short const pin); static volatile uint8_t *registerOfPort(char const port, REGISTER_TYPE); void gpio_setDirection(short const pin, DIRECTION direction) { char port = portOfPin(pin); volatile uint8_t *register_ = registerOfPort(port, DIRECTION_TYPE); if(direction == OUTPUT){ *register_ |= 1\u0026lt;\u0026lt;pin_table[pin-1]; }else if(direction == INPUT){ *register_ \u0026amp;=~(1\u0026lt;\u0026lt;pin_table[pin-1]); } } static char portOfPin(short const pin) { if((pin \u0026gt;= 2 \u0026amp;\u0026amp; pin \u0026lt;= 6) || pin \u0026gt;= 11 \u0026amp;\u0026amp; pin \u0026lt;= 13){ return \u0026#39;d\u0026#39;; }else if(pin == 8 || pin == 9 || (pin \u0026gt;= 14 \u0026amp;\u0026amp; pin \u0026lt;= 19)){ return \u0026#39;b\u0026#39;; }else if(pin == 1 || (pin \u0026gt;= 23 \u0026amp;\u0026amp; pin \u0026lt;= 28)){ return \u0026#39;c\u0026#39;; } } static volatile uint8_t * registerOfPort(char const port, REGISTER_TYPE type) { if(type == DIRECTION_TYPE){ if(port == \u0026#39;d\u0026#39;) return \u0026amp;DDRD; else if(port == \u0026#39;b\u0026#39;) return \u0026amp;DDRB; else if(port == \u0026#39;c\u0026#39;) return \u0026amp;DDRC; }else if(type == LEVEL_TYPE){ if(port == \u0026#39;d\u0026#39;) return \u0026amp;PORTD; else if(port == \u0026#39;b\u0026#39;) return \u0026amp;PORTB; else if(port == \u0026#39;c\u0026#39;) return \u0026amp;PORTC; } } void gpio_setLevel(short const pin, LEVEL level) { char port = portOfPin(pin); volatile uint8_t *register_ = registerOfPort(port, LEVEL_TYPE); if(level == HIGH){ *register_ |= 1\u0026lt;\u0026lt;pin_table[pin-1]; }else if(level == LOW){ *register_ \u0026amp;=~(1\u0026lt;\u0026lt;pin_table[pin-1]); } } Decimal a 7 segmentos #  Resuelto el problema de inicializar los pines, concentr√©monos en encontrar las secuencias de pines para mostrar el n√∫mero deseado. El problema implica convertir un n√∫mero decimal entre 0 y 9 a siete llamadas a la funci√≥n gpio_setLevel, lo primero que se me ocurre es esto\nvoid display7_showNumber(short const number) { if( number == 0){ gpio_setLevel(4, HIGH); gpio_setLevel(5, HIGH); gpio_setLevel(6, HIGH); gpio_setLevel(11, HIGH); gpio_setLevel(12, HIGH); gpio_setLevel(13, HIGH); gpio_setLevel(14, LOW); }else if( number == 1){ gpio_setLevel(4, LOW); gpio_setLevel(5, HIGH); gpio_setLevel(6, HIGH); gpio_setLevel(11, LOW); gpio_setLevel(12, LOW); gpio_setLevel(13, LOW); gpio_setLevel(14, LOW); } . . . } ya te la sabes, hay que eliminar la duplicaci√≥n, una nueva funci√≥n que ejecute los pasos anteriores estar√≠a bien, claramente hay dos listas, una de pines y otra de niveles, ser√°n los argumentos para la nueva funci√≥n:\nstatic void writeToDisplay(short const pins[], LEVEL const levels[]) { for(int i = 0; i \u0026lt; 7; i++){ gpio_setLevel(pins[i], levels[i]); } } ahora showNumber queda as√≠,\nvoid display7_showNumber(short const number) { if( number == 0){ short pins[] = {4, 5, 6, 11, 12, 13, 14}; LEVEL levels[] = {HIGH, HIGH, HIGH, HIGH, HIGH, HIGH, LOW}; writeToDisplay(pins, levels); }else if( number == 1){ short pins[] = {4, 5, 6, 11, 12, 13, 14}; LEVEL levels[] = {LOW, HIGH, HIGH, LOW, LOW, LOW, LOW}; writeToDisplay(pins, levels); } . . . } podemos sacar short pins de los if\u0026rsquo;s, pero me prefiero sacarlo de la funci√≥n showNumber y dejarla con alcance de archivo, con la intenci√≥n de utilizarla en display7_init.\nvoid display7_init(void) { for(int i = 0; i \u0026lt; 7; i++){ setPinOutputAndLow(pins[i]); } } void display7_showNumber(short const number) { if( number == 0){ LEVEL levels[] = {HIGH, HIGH, HIGH, HIGH, HIGH, HIGH, LOW}; writeToDisplay(pins, levels); }else if( number == 1){ LEVEL levels[] = {LOW, HIGH, HIGH, LOW, LOW, LOW, LOW}; writeToDisplay(pins, levels); } . . . } Pienso que el problema esta resuelto, quiz√° el arreglo levels no es tan eficiente, pero la verdad no quiero invertirle m√°s tiempo, pues cumple bien con el objetivo, si lo requiero, en el futuro vengo y lo modifico. La condici√≥n de los for no me convence, la cambio por\nstatic short const pins_length = sizeof(pins)/sizeof(pins[0]); void display7_init(void) { for(int i = 0; i \u0026lt; pins_length; i++){ setPinOutputAndLow(pins[i]); } } compilamos y vemos que el programa ocupa algo m√°s del 10% de memoria ram, eso es algo inaceptable, fui muy ingenuo al pensar que los arreglos no serian un problema, antes de resolver ese problema, quiero hacer algo que me esta haciendo ruido desde hace algunas lineas.\nEstablecer los pines al inicio #  Actualmente el c√≥digo luce como sigue:\n//display7.c #include \u0026#34;display7.h\u0026#34;#include \u0026#34;gpio.h\u0026#34; static short const pins[] = {4, 5, 6, 11, 12, 13, 14}; static short const pins_length = sizeof(pins)/sizeof(pins[0]); static void setPinOutputAndLow(short const pin); static void writeToDisplay(short const pins[], LEVEL const levels[]); void display7_init(void) { for(int i = 0; i \u0026lt; pins_length; i++){ setPinOutputAndLow(pins[i]); } } static void setPinOutputAndLow(short const pin) { gpio_setDirection(pin, OUTPUT); gpio_setLevel(pin, LOW); } void display7_showNumber(short const number) { /*	A B	C D E F G */ if( number == 0){ LEVEL const levels[] = {HIGH, HIGH, HIGH, HIGH, HIGH, HIGH, LOW}; writeToDisplay(pins, levels); }else if( number == 1){ LEVEL const levels[] = {LOW, HIGH, HIGH, LOW, LOW, LOW, LOW}; writeToDisplay(pins, levels); }else if( number == 2){ LEVEL const levels[] = {HIGH, HIGH, LOW, HIGH, HIGH, LOW, HIGH}; writeToDisplay(pins, levels); }else if( number == 3){ LEVEL const levels[] = {HIGH, HIGH, HIGH, HIGH, LOW, LOW, HIGH}; writeToDisplay(pins, levels); }else if( number == 4){ LEVEL const levels[] = {LOW, HIGH, HIGH, LOW, LOW, HIGH, HIGH}; writeToDisplay(pins, levels); }else if( number == 5){ LEVEL const levels[] = {HIGH, LOW, HIGH, HIGH, LOW, HIGH, HIGH}; writeToDisplay(pins, levels); }else if( number == 6){ LEVEL const levels[] = {HIGH, LOW, HIGH, HIGH, HIGH, HIGH, HIGH}; writeToDisplay(pins, levels); }else if( number == 7){ LEVEL const levels[] = {HIGH, HIGH, HIGH, LOW, LOW, LOW, LOW}; writeToDisplay(pins, levels); }else if( number == 8){ LEVEL const levels[] = {HIGH, HIGH, HIGH, HIGH, HIGH, HIGH, HIGH}; writeToDisplay(pins, levels); }else if( number == 9){ LEVEL const levels[] = {HIGH, HIGH, HIGH, LOW, LOW, HIGH, HIGH}; writeToDisplay(pins, levels); }else{ LEVEL const levels[] = {LOW, LOW, LOW, LOW, LOW, LOW, HIGH}; writeToDisplay(pins, levels); } } static void writeToDisplay(short const pins[], LEVEL const levels[]) { for(int i = 0; i \u0026lt; pins_length; i++){ gpio_setLevel(pins[i], levels[i]); } } Mi problema con este c√≥digo es con elegir los pines del display, por ahora utilizamos el arreglo pins para indicar los pines, me gustar√≠a darle la posibilidad al usuarios de la biblioteca de poder elegir los pines que el necesite, propongo cambiar la interfaz de la funci√≥n display7_init, para permitir indicar los pines, posteriormente rellenar el arreglo pins:\n//display7.c #define NUMBERDISPLAYPINS 8  static short pins[NUMBERDISPLAYPINS]; void display7_init(short const pin_a, short const pin_b, short const pin_c, short const pin_d, short const pin_e, short const pin_f, short const pin_g, short const pin_dot) { pins[0] = pin_a; pins[1] = pin_b; pins[2] = pin_c; pins[3] = pin_d; pins[4] = pin_e; pins[5] = pin_f; pins[6] = pin_g; pins[7] = pin_dot; for(int i = 0; i \u0026lt; NUMBERDISPLAYPINS; i++){ setPinOutputAndLow(pins[i]); } } y para llamar\n//proyecto.ino #define F_CPU 16000000UL #include\u0026lt;util/delay.h\u0026gt;#include\u0026#34;display7.h\u0026#34; int main(void) { display7_init(4, 5, 6, 11, 12, 13, 14, 15); while(1){ for(int i = 0; i\u0026lt;10; i++){ display7_showNumber(i); _delay_ms(1000); } } } Agrego tambi√©n el pin del punto nada m√°s por puro remordimiento. Ahora si vamos a optimizar showNumber.\nOtra vez de nuevo #  Ni modo, reimplementaremos la funci√≥n tomando en cuenta las sensaciones anteriores,\nvoid display7_showNumber(short const number) { /*	A B	C D E F G */ if( number == 0){ LEVEL const levels[] = {HIGH, HIGH, HIGH, HIGH, HIGH, HIGH, LOW}; writeToDisplay(pins, levels); }else if( number == 1){ LEVEL const levels[] = {LOW, HIGH, HIGH, LOW, LOW, LOW, LOW}; writeToDisplay(pins, levels); }else if( number == 2){ LEVEL const levels[] = {HIGH, HIGH, LOW, HIGH, HIGH, LOW, HIGH}; writeToDisplay(pins, levels); . . . } ¬øc√≥mo reimplement ese mazacote?, LEVELS debe irse, en lugar de indicar los pines en un array los indicamos en una variable de 8 bits, el pin a corresponde al bit 7, el pin b corresponde al bit 6, etc.\n abcdefg. 0b76543210 en una nueva tabla guardamos los bits adecuados para cada n√∫mero.\nuint8_t bits_table[] = { 0b11111100, //0 	0b01100000, //1 	0b11011010, //2 	0b11110010, //3 	0b01100110, //4 	0b10110110, //5 	0b10111110, //6 	0b11100000, //7 	0b11111110, //8 	0b11100110, //9 	0b00000010 //- 	}; con el compilador que usa Arduino la asignaci√≥n anterior es legar, sin embargo otros compiladores no aceptan la declaraci√≥n de binarios de esta forma, prefiero declarar los valores en forma hexadecimal,\nvoid display7_showNumber(short const number) { uint8_t bits_table[] = { 0xFC, //0 	0x60, //1 	0xDA, //2 	0xF2, //3 	0x66, //4 	0xB6, //5 	0xBE, //6 	0xE0, //7 	0xFE, //8 	0xE6, //9 	0x02 //- 	}; if( number == 0){ writeToDisplay(pins, bits_table[0]); }else if( number == 1){ writeToDisplay(pins, bits_table[1]); }else if( number == 2){ writeToDisplay(pins, bits_table[2]); }else if( number == 3){ writeToDisplay(pins, bits_table[3]); }else if( number == 4){ writeToDisplay(pins, bits_table[4]); }else if( number == 5){ writeToDisplay(pins, bits_table[5]); }else if( number == 6){ writeToDisplay(pins, bits_table[6]); }else if( number == 7){ writeToDisplay(pins, bits_table[7]); }else if( number == 8){ writeToDisplay(pins, bits_table[8]); }else if( number == 9){ writeToDisplay(pins, bits_table[9]); }else{ writeToDisplay(pins, bits_table[10]); } } ahora nos interesa modificar writeToDisplay para que acepte en su segundo argumento un entero de 8 bits en lugar de un arreglo de niveles, se propone lo siguiente:\nstatic void writeToDisplay(short const pins[], uint8_t const levels) { for(int i = 0; i \u0026lt; NUMBERDISPLAYPINS; i++){ LEVEL level; if(levels \u0026amp; (1\u0026lt;\u0026lt;(7-i))) level = HIGH; else level = LOW; gpio_setLevel(pins[i], level); } } recorremos cada uno de los bits de levels y determinamos si es alto o bajo con if(levels \u0026amp; (1\u0026laquo;(7-i))), despu√©s solo escribimos a gpio. Podemos reducir m√°s showNumber extrayendo esa horrible tabla de else if.\nvoid display7_showNumber(short const number) { uint8_t bits_table[] = { 0xFC, //0 	0x60, //1 	0xDA, //2 	0xF2, //3 	0x66, //4 	0xB6, //5 	0xBE, //6 	0xE0, //7 	0xFE, //8 	0xE6, //9 	0x02 //- 	}; if(number\u0026gt;= 0 \u0026amp;\u0026amp; number \u0026lt;=9) writeToDisplay(pins, bits_table[number]); else writeToDisplay(pins, bits_table[10]); } Mucho mejor, me gustan las funciones peque√±as m√°s que las grandes, saco la tabla de bits y la declaro est√°tica para mayor comodidad.\n//display7.c #include \u0026#34;display7.h\u0026#34;#include \u0026#34;gpio.h\u0026#34;#include \u0026lt;stdint.h\u0026gt; #define NUMBERDISPLAYPINS 8  static short pins[NUMBERDISPLAYPINS]; static uint8_t const bits_table[] = { 0xFC, //0 	0x60, //1 	0xDA, //2 	0xF2, //3 	0x66, //4 	0xB6, //5 	0xBE, //6 	0xE0, //7 	0xFE, //8 	0xE6, //9 	0x02 //- 	}; static void setPinOutputAndLow(short const pin); static void writeToDisplay(short const pins[], uint8_t const levels); void display7_init(short const pin_a, short const pin_b, short const pin_c, short const pin_d, short const pin_e, short const pin_f, short const pin_g, short const pin_dot) { pins[0] = pin_a; pins[1] = pin_b; pins[2] = pin_c; pins[3] = pin_d; pins[4] = pin_e; pins[5] = pin_f; pins[6] = pin_g; pins[7] = pin_dot; for(int i = 0; i \u0026lt; NUMBERDISPLAYPINS; i++){ setPinOutputAndLow(pins[i]); } } static void setPinOutputAndLow(short const pin) { gpio_setDirection(pin, OUTPUT); gpio_setLevel(pin, LOW); } void display7_showNumber(short const number) { if(number\u0026gt;= 0 \u0026amp;\u0026amp; number \u0026lt;=9) writeToDisplay(pins, bits_table[number]); else writeToDisplay(pins, bits_table[10]); } static void writeToDisplay(short const pins[], uint8_t const levels) { for(int i = 0; i \u0026lt; NUMBERDISPLAYPINS; i++){ LEVEL level; if( levels \u0026amp; (1\u0026lt;\u0026lt;(7-i))) level = HIGH; else level = LOW; gpio_setLevel(pins[i], level); } } Me siento satisfecho, se redujo la memoria ram ocupada de 10% a solo 4%, veamos como reducirla aun m√°s, pero antes hay algo que me hace ruido otra vez.\nGuardianes #  ¬øQu√© pasa si el usuario introduce un pin invalido?, por ejemplo el pin 7 pertenece a Vcc, ¬øel programa deber√≠a detenerse? o ¬øsolo ignorar ese pin?, yo prefiero solo ignorarlo, veamos la implementaci√≥n de gpio\n//gpio.c #include \u0026#34;gpio.h\u0026#34;#include \u0026lt;avr/io.h\u0026gt; static short const pin_table[28] = { PC6, PD0, PD1, PD2, PD3, PD4, -1, -1, PB6, PB7, PD5, PD6, PD7, PB0, PB1, PB2, PB3, PB4, PB5, -1, -1, -1, PC0, PC1, PC2, PC3, PC4, PC5 }; typedef enum {DIRECTION_TYPE, LEVEL_TYPE} REGISTER_TYPE; static char portOfPin(short const pin); static volatile uint8_t *registerOfPort(char const port, REGISTER_TYPE); void gpio_setDirection(short const pin, DIRECTION direction) { char port = portOfPin(pin); volatile uint8_t *register_ = registerOfPort(port, DIRECTION_TYPE); if(direction == OUTPUT){ *register_ |= 1\u0026lt;\u0026lt;pin_table[pin-1]; }else if(direction == INPUT){ *register_ \u0026amp;=~(1\u0026lt;\u0026lt;pin_table[pin-1]); } } static char portOfPin(short const pin) { if((pin \u0026gt;= 2 \u0026amp;\u0026amp; pin \u0026lt;= 6) || pin \u0026gt;= 11 \u0026amp;\u0026amp; pin \u0026lt;= 13){ return \u0026#39;d\u0026#39;; }else if(pin == 8 || pin == 9 || (pin \u0026gt;= 14 \u0026amp;\u0026amp; pin \u0026lt;= 19)){ return \u0026#39;b\u0026#39;; }else if(pin == 1 || (pin \u0026gt;= 23 \u0026amp;\u0026amp; pin \u0026lt;= 28)){ return \u0026#39;c\u0026#39;; } } static volatile uint8_t * registerOfPort(char const port, REGISTER_TYPE type) { if(type == DIRECTION_TYPE){ if(port == \u0026#39;d\u0026#39;) return \u0026amp;DDRD; else if(port == \u0026#39;b\u0026#39;) return \u0026amp;DDRB; else if(port == \u0026#39;c\u0026#39;) return \u0026amp;DDRC; }else if(type == LEVEL_TYPE){ if(port == \u0026#39;d\u0026#39;) return \u0026amp;PORTD; else if(port == \u0026#39;b\u0026#39;) return \u0026amp;PORTB; else if(port == \u0026#39;c\u0026#39;) return \u0026amp;PORTC; } } void gpio_setLevel(short const pin, LEVEL level) { char port = portOfPin(pin); volatile uint8_t *register_ = registerOfPort(port, LEVEL_TYPE); if(level == HIGH){ *register_ |= 1\u0026lt;\u0026lt;pin_table[pin-1]; }else if(level == LOW){ *register_ \u0026amp;=~(1\u0026lt;\u0026lt;pin_table[pin-1]); } } Aprovechamos la funci√≥n portOfPin, hace un an√°lisis de todos los pines y retorna un car√°cter para identificar el puerto, basta con agregar un else al final y retornar un car√°cter que identifique un puerto invalido derivado de un pin invalido.\nstatic char portOfPin(short const pin) { if((pin \u0026gt;= 2 \u0026amp;\u0026amp; pin \u0026lt;= 6) || pin \u0026gt;= 11 \u0026amp;\u0026amp; pin \u0026lt;= 13){ return \u0026#39;d\u0026#39;; }else if(pin == 8 || pin == 9 || (pin \u0026gt;= 14 \u0026amp;\u0026amp; pin \u0026lt;= 19)){ return \u0026#39;b\u0026#39;; }else if(pin == 1 || (pin \u0026gt;= 23 \u0026amp;\u0026amp; pin \u0026lt;= 28)){ return \u0026#39;c\u0026#39;; }else return \u0026#39;0\u0026#39;; //Cero, puerto invalido } finalmente agregamos la condici√≥n de retorno en las funciones setLevel y setDirection.\nchar port = portOfPin(pin); if(port == \u0026#39;0\u0026#39;) return; volatile uint8_t *register_ = registerOfPort(port, DIRECTION_TYPE); Fin #  La biblioteca funciona muy bien, es posible que este omitiendo algo, la √∫nica forma de saberlo es creando una serie de pruebas exhaustivas o mejor aun usando la biblioteca exhaustivamente e ir modificando y adapt√°ndola, ni modo. Este es el c√≥digo final.\n//proyecto.ino #define F_CPU 16000000UL #include\u0026lt;util/delay.h\u0026gt;#include\u0026#34;display7.h\u0026#34; int main(void) { display7_init(4, 5, 6, 11, 12, 13, 14, 15); while(1){ for(int i = 0; i\u0026lt;11; i++){ display7_showNumber(i); _delay_ms(1000); } } } #ifndef DISPLAY7_H #define DISPLAY7_H  #ifdef __cplusplus extern \u0026#34;C\u0026#34; { #endif  void display7_init(	short const pin_a, short const pin_b, short const pin_c, short const pin_d, short const pin_e, short const pin_f, short const pin_g, short const pin_dot ); void display7_showNumber(short const number); #ifdef __cplusplus } #endif #endif//DISPLAY7_H  //display7.c #include \u0026#34;display7.h\u0026#34;#include \u0026#34;gpio.h\u0026#34;#include \u0026lt;stdint.h\u0026gt; #define NUMBERDISPLAYPINS 8  static short pins[NUMBERDISPLAYPINS]; static uint8_t const bits_table[] = { 0xFC, //0 	0x60, //1 	0xDA, //2 	0xF2, //3 	0x66, //4 	0xB6, //5 	0xBE, //6 	0xE0, //7 	0xFE, //8 	0xE6, //9 	0x02 //- 	}; static void setPinOutputAndLow(short const pin); static void writeToDisplay(short const pins[], uint8_t const levels); void display7_init(short const pin_a, short const pin_b, short const pin_c, short const pin_d, short const pin_e, short const pin_f, short const pin_g, short const pin_dot) { pins[0] = pin_a; pins[1] = pin_b; pins[2] = pin_c; pins[3] = pin_d; pins[4] = pin_e; pins[5] = pin_f; pins[6] = pin_g; pins[7] = pin_dot; for(int i = 0; i \u0026lt; NUMBERDISPLAYPINS; i++){ setPinOutputAndLow(pins[i]); } } static void setPinOutputAndLow(short const pin) { gpio_setDirection(pin, OUTPUT); gpio_setLevel(pin, LOW); } void display7_showNumber(short const number) { if(number\u0026gt;= 0 \u0026amp;\u0026amp; number \u0026lt;=9) writeToDisplay(pins, bits_table[number]); else writeToDisplay(pins, bits_table[10]); } static void writeToDisplay(short const pins[], uint8_t const levels) { for(int i = 0; i \u0026lt; NUMBERDISPLAYPINS; i++){ LEVEL level; if( levels \u0026amp; (1\u0026lt;\u0026lt;(7-i))) level = HIGH; else level = LOW; gpio_setLevel(pins[i], level); } } //gpio.h #ifndef GPIO_H #define GPIO_H  #ifdef __cplusplus extern \u0026#34;C\u0026#34; { #endif  typedef enum {INPUT, OUTPUT} DIRECTION; typedef enum {LOW, HIGH} LEVEL; void gpio_setDirection(short const pin, DIRECTION); void gpio_setLevel(short const pin, LEVEL); #ifdef __cplusplus } #endif  #endif // GPIO_H //gpio.c #include \u0026#34;gpio.h\u0026#34;#include \u0026lt;avr/io.h\u0026gt; static short const pin_table[28] = { PC6, PD0, PD1, PD2, PD3, PD4, -1, -1, PB6, PB7, PD5, PD6, PD7, PB0, PB1, PB2, PB3, PB4, PB5, -1, -1, -1, PC0, PC1, PC2, PC3, PC4, PC5 }; typedef enum {DIRECTION_TYPE, LEVEL_TYPE} REGISTER_TYPE; static char portOfPin(short const pin); static volatile uint8_t *registerOfPort(char const port, REGISTER_TYPE); void gpio_setDirection(short const pin, DIRECTION direction) { char port = portOfPin(pin); if(port == \u0026#39;0\u0026#39;) return; volatile uint8_t *register_ = registerOfPort(port, DIRECTION_TYPE); if(direction == OUTPUT){ *register_ |= 1\u0026lt;\u0026lt;pin_table[pin-1]; }else if(direction == INPUT){ *register_ \u0026amp;=~(1\u0026lt;\u0026lt;pin_table[pin-1]); } } static char portOfPin(short const pin) { if((pin \u0026gt;= 2 \u0026amp;\u0026amp; pin \u0026lt;= 6) || pin \u0026gt;= 11 \u0026amp;\u0026amp; pin \u0026lt;= 13){ return \u0026#39;d\u0026#39;; }else if(pin == 8 || pin == 9 || (pin \u0026gt;= 14 \u0026amp;\u0026amp; pin \u0026lt;= 19)){ return \u0026#39;b\u0026#39;; }else if(pin == 1 || (pin \u0026gt;= 23 \u0026amp;\u0026amp; pin \u0026lt;= 28)){ return \u0026#39;c\u0026#39;; }else return \u0026#39;0\u0026#39;; } static volatile uint8_t * registerOfPort(char const port, REGISTER_TYPE type) { if(type == DIRECTION_TYPE){ if(port == \u0026#39;d\u0026#39;) return \u0026amp;DDRD; else if(port == \u0026#39;b\u0026#39;) return \u0026amp;DDRB; else if(port == \u0026#39;c\u0026#39;) return \u0026amp;DDRC; }else if(type == LEVEL_TYPE){ if(port == \u0026#39;d\u0026#39;) return \u0026amp;PORTD; else if(port == \u0026#39;b\u0026#39;) return \u0026amp;PORTB; else if(port == \u0026#39;c\u0026#39;) return \u0026amp;PORTC; } } void gpio_setLevel(short const pin, LEVEL level) { char port = portOfPin(pin); if(port == \u0026#39;0\u0026#39;) return; volatile uint8_t *register_ = registerOfPort(port, LEVEL_TYPE); if(level == HIGH){ *register_ |= 1\u0026lt;\u0026lt;pin_table[pin-1]; }else if(level == LOW){ *register_ \u0026amp;=~(1\u0026lt;\u0026lt;pin_table[pin-1]); } } "}),a.add({id:16,href:'/eleckia/posts/electronica-basica-display-de-7-segmentos/',title:"Electr√≥nica b√°sica.- Display de 7 segmentos.",section:"Posts",content:"Un display de 7 segmentos es un arreglo de leds distribuidos de una manera determinada, 8 leds en total, el display de 7 segmentos tiene el prop√≥sito de mostrar caracteres, usualmente n√∫meros pero tambi√©n puede mostrar letras.\nDisplay 7 segmentos\nel circuito equivalente es muy sencillo,\nC√°todo com√∫n\nesta configuraci√≥n es llamada c√°todo com√∫n, puesto que el c√°todo de todos los diodos est√° en corto circuito, es una buena caracter√≠stica pues tenemos un solo pin para todos los c√°todos y podemos usar un solo cable para la conexi√≥n en lugar de ocho.\n√Ånodo com√∫n\nLa configuraci√≥n de √°nodo com√∫n es similar a la de c√°todo com√∫n salvo que los √°nodos son los que est√°n conectados en corto.\nEl dispositivo cuenta con nueve terminales (aveces diez, dos dedicadas para el com√∫n) una para el com√∫n y el resto para los ocho leds, para el c√°todo com√∫n; la terminal com√∫n se conecta a tierra y los leds se encienden con voltaje alto, por el contrario para el √°nodo com√∫n; la terminal com√∫n se conecta a Vcc y los leds se encienden con voltaje bajo.\nCada terminal es simplemente un led, por lo tanto para usarlo debemos agregar una resistencia para limitar la corriente, para nuestro atmega328p; resistencias para cada led de 330 $latex \\Omega$ o un poco mayores son suficientes. Cada led sera alimentado por 10[mA], si todos los leds se encienden al mismo tiempo, en total tenemos 80[mA], por lo que nuestro microcontrolador puede manejarlos sin problema, recordemos que la corriente m√°xima provista por el microcontrolador es de 200[mA] por todos los pines y 40[mA] en cada pin.\n"}),a.add({id:17,href:'/eleckia/posts/electronica-basica-led-y-su-resistencia/',title:"Electr√≥nica b√°sica.- Led y su resistencia.",section:"Posts",content:"La ley de Ohm es una herramienta fundamental en la electr√≥nica, en esta ocasi√≥n vamos a calcular la resistencia adecuada para que un diodo pueda operar de forma segura.\nAntes que nada definamos que es un diodo, sin entrar en detalles, un diodo es un dispositivo que permite el flujo de corriente en una sola direcci√≥n, cuenta con dos terminales, el √°nodo y el c√°todo, la regla es que si se conecta un voltaje alto al √°nodo y uno bajo al c√°todo, entonces fluye corriente, esta operaci√≥n del diodo se conoce como polarizaci√≥n directa, si se invierten las conexiones se dice que el diodo esta polarizado en inversa y no fluye corriente. Un circuito simple se muestra en la figura,\nCircuito con Diodo\nAhora reemplazamos el diodo por su circuito equivalente,\nDiodo en Directa\nLa resistencia \u0026ldquo;interna\u0026rdquo; del diodo es muy peque√±a por lo que podemos despreciarla, no debemos olvidar que este circuito es un modelo, el modelo funciona bien porque representa el comportamiento del diodo, no significa que dentro del diodo exista una resistencia y una fuente de voltaje, el valor de la fuente de voltaje varia de diodo a diodo, debemos verificar la hoja de datos para ver que voltaje tiene el diodo en cuesti√≥n, en algunos casos el voltaje es peque√±o comparado con el resto de voltajes y simplemente se desprecia, modelandolo como un simple corto circuito.\nEn el caso de la polarizaci√≥n inversa el circuito es aun m√°s simple\nDiodo en Inversa\nes un circuito abierto y no hay circulaci√≥n de corriente.\nLed. #  Un led es un diodo que tiene la capacidad de emitir luz, el voltaje del diodo led es mayor que el voltaje de otro tipo de diodos, siendo el rojo el mas peque√±o alrededor de 1.8 [V] y el azul el m√°s grande alrededor de 4.8 [V], esto para leds de 5mm, sin embargo esto valores cambian seg√∫n el tama√±o del led, lo mejor es revisar en la hoja de datos del diodo en cuesti√≥n.\nUn led generalmente se acompa√±a de una resistencia conectada en serie, ¬øpara qu√©?, la respuesta es simple, para limitar su corriente, entendamos que es un corto circuito.\nPartiendo del circuito anterior, tenemos una fuente en serie con una resistencia, recordemos que la corriente es\n$latex i = \\frac{V}{R}$\nun corto se entiende como una conexi√≥n el√©ctrica de cero resistencia entre dos terminales. De esta forma los puntos A y B en el esquema est√°n en corto, dicho de otra manera no hay resistencia entre ellos, esto implica que la corriente puede fluir totalmente entre estos dos puntos, Las terminales C y D no est√°n en corto pues hay una resistencia entre ellas, ¬øque pasar√≠a si quitamos la resistencia?, pues tendr√≠amos a las terminales C y D en corto y las consecuencias serian desastrosas. de la ley de Ohm tenemos $latex i = \\frac{V}{0} = \\infty$, las fuentes no pueden otorgar energ√≠a infinita, est√°n dise√±ada para dar una corriente especifica, si se sobrepasa el limite se da√±aran, es por eso que nunca debes juntar las terminales de una fuente.\nRegresando a nuestro diodo led, ¬øqu√© pasar√≠a si no colocamos una resistencia entre el diodo y la fuente?,\nDiodo en corto\ncomo dijimos la resistencia del modelo del diodo es muy peque√±a por lo tanto la fuente y el diodo est√°n pr√°cticamente en corto, es decir fluir√° una gran cantidad de corriente desde la fuente hacia el diodo, si se tiene suerte el diodo se quemara y se abrir√° el circuito, si tienes un mal d√≠a tu fuente se da√±ara tambi√©n, los diodos est√°n fabricados para trabajar a un cierta corriente, en el caso de los diodos peque√±os de 5mm la corriente suele estar alrededor de los 10[mA], en el caso de los diodos led de iluminaci√≥n es com√∫n encontrar corrientes de 300[mA]. Calculemos r√°pidamente la resistencia de un led de 5mm rojo de 1.8[V] y 10[mA], que se desea conectar a una fuente de 5[V]. El circuito es el siguiente.\nde la ley de Ohm\n$latex V = Ri$\ndividiendo ambos lados entre la corriente\n$latex \\frac{V}{i} = R \\frac{i}{i} = R$\npara la resistencia R\n$latex R = \\frac{V_R}{i}$\ny la aplicamos a la resistencia R, recordemos que la corriente es un flujo, por lo tanto la corriente que pasa por la resistencia es la misma que pasa por el led, sabemos que el voltaje en la terminal positiva de la resistencia es 5V y el voltaje en la terminal negativa de la resistencia es 1.8V (estamos despreciando la resistencia interna del diodo), por lo tanto el voltaje que hay entre las terminales de la resistencia R es\n$latex V_R = (5 - 1.8) [V] = 3.2[V]$\nsabemos que la corriente de operaci√≥n del led es de 10[mA], por lo tanto la resistencia adecuada debe ser\n$latex R = \\frac{3.2[V]}{10[mA]} = \\frac{3.2[V]}{0.010[A]} = 320 \\Omega$\nla resistencia comercial m√°s cercana es de 330 Ohms, usaremos esa, la corriente disminuir√° una cantidad marginal.\n¬øY si quiero a√±adir un led adicional a la misma fuente?, podemos a√±adir el led de forma paralela al led ya existen y recalcular la resistencia.\nLeds en paralelo\nEl c√°lculo es id√©ntico salvo que ahora la corriente es el doble, pues se requiere satisfacer la corriente de cada diodo $latex i = i_{D1} + i_{D2} = 20[mA]$, la resistencia necesaria es $latex R = 160 \\Omega$, el problema es que la resistencia disipara m√°s potencia, que significa que se calentara m√°s. Un m√©todo m√°s recomendado es conectar una segunda rama (con diodo y resistencia incluidos), en paralelo a la fuente,\nDiodos con resistencia en paralelo\nde esta forma las dos resistencias son iguales a 330 Ohms. Podemos conectar tantas ramas en paralelo como deseemos, el limite es la capacidad de corriente de nuestra fuente, hay que recordar que el limite de un pin del atmega328p es de 40[mA].\n"}),a.add({id:18,href:'/eleckia/posts/bloque-reutilizable-sin-titulo-2/',title:"res",section:"Posts",content:"La ley de Ohm es una herramienta fundamental en la electr√≥nica, en esta ocasi√≥n vamos a calcular la resistencia adecuada para que un diodo pueda operar de forma segura.\nAntes que nada definamos que es un diodo, sin entrar en detalles, un diodo es un dispositivo que permite el flujo de corriente en una sola direcci√≥n, cuenta con dos terminales, el √°nodo y c√°todo, la regla es que si se conecta un voltaje alto al √°nodo y uno bajo al c√°todo, entonces fluye corriente, esta operaci√≥n del diodo se conoce como polarizaci√≥n directa, si se invierten las conexiones se dice que el diodo esta polarizado en inversa y no fluye corriente. Un circuito simple se muestra en la figura,\nCircuito con Diodo\nAhora reemplazamos el diodo por su circuito equivalente,\nDiodo en Directa\nLa resistencia \u0026ldquo;interna\u0026rdquo; del diodo es muy peque√±a por lo que podemos despreciarla, no debemos olvidar que este circuito es un modelo, este modelo funciona bien porque representa el comportamiento del diodo, no significa que dentro del diodo exista una resistencia y una fuente de voltaje, el valor de la fuente de voltaje varia de diodo a diodo, debemos verificar la hoja de datos para ver que voltaje tiene el diodo en cuesti√≥n, en algunos casos el voltaje es peque√±o comparado con el resto de voltajes y simplemente se desprecia, modelando el diodo como un simple corto circuito.\nEn el caso de la polarizaci√≥n inversa el circuito es aun m√°s simple\nDiodo en Inversa\nes un circuito y no hay circulaci√≥n de corriente.\nLed. #  Un led es un diodo que tiene la capacidad de emitir luz, el voltaje del diodo led es mayor que el voltaje de otro tipo de diodos, siendo el rojo el mas peque√±o alrededor de 1.8 [V] y el azul el m√°s grande alrededor de 4.8 [V], esto para leds de 5mm, sin embargo esto valores cambian seg√∫n el tama√±o del led, lo mejor es revisar en la hoja de datos del diodo en cuesti√≥n.\nUn led generalmente se acompa√±a de una resistencia conectada en serie, ¬øpara qu√©?, la respuesta es simple, para limitar su corriente, entendamos que es un corto circuito.\nPartiendo del circuito anterior, tenemos una fuente en serie con una resistencia, recordemos que la corriente es\n$latex i = \\frac{V}{R}$\nun corto se entiende como una conexi√≥n el√©ctrica de cero resistencia entre dos terminales. De esta forma los puntos A y B en el esquema est√°n en corto, dicho de otra manera no hay resistencia entre ellos, esto implica que la corriente puede fluir totalmente entre estos dos puntos, Las terminales C y D no est√°n en corto pues hay una resistencia entre ellas, ¬øque pasar√≠a si quitamos la resistencia?, pues tendr√≠amos a las terminales C y D en corto y las consecuencias serian desastrosas. de la ley de Ohm tenemos $latex i = \\frac{V}{0} = \\infty$, las fuentes no pueden otorgar energ√≠a infinita, est√°n dise√±ada para dar una corriente establecida de corriente, si se sobrepasa el limite se da√±aran, es por eso que nunca debes juntar las terminales de una fuente.\nRegresando a nuestro diodo led, ¬øqu√© pasar√≠a si no colocamos una resistencia entre el diodo y la fuente?,\nDiodo en corto\ncomo dijimos la resistencia del modelo del diodo es muy peque√±a por lo tanto la fuente y el diodo est√°n en corto, es decir fluir√° una gran cantidad de corriente desde la fuente hacia el diodo, si se tiene suerte el diodo se quemara y se abrir√° el circuito, si tienes un mal d√≠a tu fuente se da√±ara tambi√©n, los diodos est√°n fabricados para trabajar a un cierta corriente, en el caso de los diodos peque√±os de 5mm la corriente suele estar alrededor de los 10[mA], en el caso de los diodos led de iluminaci√≥n es com√∫n encontrar corrientes de 300[mA]. Calculemos r√°pidamente la resistencia de un led de 5mm rojo de 1.8[V] y 10[mA], que se desea conectar a una fuente de 5[V]. El circuito es el siguiente.\nde la ley de Ohm despejando la resistencia se tiene\n$latex R = \\frac{V_R}{i}$\ny la aplicamos a la resistencia R, recordemos que la corriente es un flujo, por lo tanto la corriente que pasa por la resistencia es la misma que pasa por el led, sabemos que el voltaje en la terminal positiva de la resistencia es 5V y el voltaje en la terminal negativa de la resistencia es 1.8V (estamos despreciando la resistencia interna del diodo), por lo tanto el voltaje que hay entre las terminales de la resistencia R es\n$latex V_R = (5 - 1.8) [V] = 3.2[V]$\nsabemos que la corriente de operaci√≥n del led es de 10mA, por lo tanto la resistencia adecuada debe ser\n$latex R = \\frac{3.2[V]}{10[mA]} = \\frac{3.2[V]}{0.010[A]} = 320 \\Omega$\nla resistencia comercial m√°s cercana es de 330 Ohms, usaremos esa, la corriente disminuir√° una cantidad marginal.\n¬øY si quiero a√±adir un led adicional a la misma fuente?, podemos a√±adir el led de forma paralela al led ya existen y recalcular la resistencia.\nLeds en paralelo\nEl c√°lculo es id√©ntico salvo que ahora la corriente es el doble, pues se requiere satisfacer la corriente de cada diodo $latex i = i_{D1} + i_{D2} = 20[mA]$, la resistencia necesaria es $latex R = 160 \\Omega$, el problema es que la resistencia disipara m√°s potencia, que significa que se calentara m√°s. Un m√©todo m√°s recomendado es conectar una segunda rama con diodo y resistencia incluidos en paralelo a la fuente,\nDiodos con resistencia en paralelo\nde esta forma las dos resistencias son iguales a 330 Ohms. Podemos conectar tantas ramas en paralelo que deseemos, el limite es la capacidad de corriente de nuestra fuente, hay que recordar que el limite de un pin del atmega328p es de 40[mA].\n"}),a.add({id:19,href:'/eleckia/docs/avr/programando-avr-en-c-variables-y-tipos-caracteres/',title:"Programando Avr en C.- Variables y tipos, caracteres.",section:"Programaci√≥n Avr en C.",content:"El tipo de variable char, sirve para guardar caracteres, generalmente el tama√±o de este tipo es de 8 bits, por ello es com√∫n encontrar este tipo de dato en una gran cantidad de programas de 8 bits para almacenar resultados de operaciones con registros, sin embargo es preferible usar uint8_t, para un c√≥digo consistente. El tipo char lo usaremos √∫nicamente para lo que es, es decir para guardar un car√°cter, por ejemplo;\nchar letra = 'A'; char numero = '1'; //Ambas variables guardan caracteres, uint8\\_t resultado = numero + numero; //Esto dar√° resultados err√≥neos, pues estamos sumando dos //caracteres y nos dos n√∫meros. Para representar una palabra utilizaremos arreglos de caracteres, un arreglo es un conjunto contiguo de variables, los arreglos ser√°n analizados a detalle en otra entrada.\nEl tipo char puede almacenar los caracteres descritos por el c√≥digo ASCII, incluidos los de control, por ejemplo el car√°cter nulo \u0026lsquo;\\0\u0026rsquo;, o el tabulador \u0026lsquo;\\t\u0026rsquo;, el uso de caracteres suele estar limitado a los dispositivos capaces de mostrarlos, como pantallas por ejemplo.\nAlgunas personas utilizan el puerto serial para enviar comandos por medio de caracteres, sin embargo es un m√©todo ineficiente, imagina que queremos enviar el n√∫mero 200 desde un microcontrolador a una PC, podr√≠as usar el puerto serial y enviar un \u0026lsquo;2\u0026rsquo;, \u0026lsquo;0\u0026rsquo; y \u0026lsquo;0\u0026rsquo;, cada uno es un car√°cter y tiene un tama√±o de 8 bits, en total son 3x8 bits, sin embargo el n√∫mero 200 puede almacenarse sin problemas en solo 8 bits, ahora supongamos que queremos enviar el n√∫mero 2,000,000,000, enviarlo car√°cter por car√°cter requerir√≠a 8x10 bits, 80 bits, cuando perfectamente ese n√∫mero puede ser almacenado en un entero de 32 bits, cuando comentemos el perif√©rico UART esto tomara sentido.\n"}),a.add({id:20,href:'/eleckia/docs/avr/programando-avr-en-c-variables-y-tipos-enteros/',title:"Programando Avr en C.- Variables y tipos.- Enteros.",section:"Programaci√≥n Avr en C.",content:"El lenguaje de programaci√≥n C, es un lenguaje de tipo; tipado est√°tico, esto quiere decir que nosotros debemos indicar el tipo de dato que guarda una variable. ¬øQu√© es una variable?, puede decirse que una variable es un espacio en memoria que guarda un valor determinado, y ¬øqu√© es un tipo', en C los tipos de variables b√°sicos (mejor llamados primitivos) son,\n Enteros, almacenan valores enteros, como: 1, 2, -100, 0b11111, 0x32, \u0026hellip; De punto Flotante, cantidades con decimales como: 1.111, 3.141598, -1.4142, \u0026hellip; Caracter. \u0026lsquo;a\u0026rsquo;, \u0026lsquo;y\u0026rsquo;, ' \u0026lsquo;, \u0026lsquo;\\n\u0026rsquo;, \u0026hellip; Boleanos, true, false.  Existen tipos adicionales pero son variantes de las anteriores, como dijimos para declarar una variable debemos especificar su tipo, esto se hace con la siguiente sintaxis,\ntipo nombre\\_de\\_variable; //Una variable entera llamado numero int numero; //Una variable de tipo car√°cter llamada letra char letra; //Una variable de tipo punto flotante llamada cantidad double cantidad; //Una variable boleana llamada condicion bool condicion; ¬øF√°cil no?, pero en la vida nada es f√°cil :D, pero si sencilla, existen modificadores que nos permiten agregar o mejor dicho establecer propiedades a las variables.\nSigned y Unsigned #  Por defecto las variables de tipo entero pueden guardar enteros positivos y negativos, a costa de utilizar un bit para guardar el signo, de manera que si declaramos una variable como unsigned (sin signo), podemos utilizar ese bit para guardar informaci√≥n adicional, pero perdemos la capacidad de almacenar n√∫meros negativos.\n//Suponiendo que los enteros son binarios de 8 bits int numero1; //Puede guardar valores desde -128 a 127 //Por defecto las variables son de tipo signed signed int numero1; //Puede guardar valores desde -128 a 127 unsigned int numero2; //Puede guardar valores de 0 a 255 Al final la cantidad de informaci√≥n guardada no cambia, tan solo cambiamos la forma en como se interpreta, sin embargo el utilizar unsigned generalmente lleva a un camino lleno de dolor, pues es una fuente de errores aritm√©ticos, as√≠ que utilizaremos este modificador en situaciones bien definidas. El resto de tipos de variables limitaremos el uso de unsigned a las variables de tipo entero(int).\nEl tama√±o de los enteros, stdint.h #  En el ejemplo anterior asumimos que un entero guarda n√∫meros de 8 bits, esto es poco probable, realmente a priori no sabemos que tama√±o tiene un entero(el n√∫mero de bits), el tama√±o es determinado por el compilador y es dependiente de la arquitectura, muy probablemente un entero en Arduino sea de 16 bits pero en un cortex-m tal vez sera de 32, y una PC sea de 64 y puede variar entre compiladores en la misma plataforma, ser√≠a muy riesgoso asumir un tama√±o por defecto, afortunadamente existe una biblioteca que nos permite declarar variables con el tama√±o que nosotros indiquemos, basta con incluir la biblioteca,\n#include\u0026lt;stdint.h\u0026gt; es importante declarar las variables con un tama√±o predeterminado cuando de operaciones con registros se trate, con aras de mejorar la portabilidad de nuestro c√≥digo. ¬øComo declaramos un entero con la anterior biblioteca?,\n#include\u0026lt;stdint.h\u0026gt; // Standard Int int8\\_t numero; //Variable entera de 8 bits //Podemos cambiar el 8 por 16, 32 o 64 siendo esto el //numero de bits uint8\\_t numero; //variable entera de 8 bits unsigned de esta forma nos aseguramos que la variable numero sera una variable entera de 8 bits en cualquier ambiente donde nuestro c√≥digo se compile y ejecute, a manera de resumen\n8 bits pueden almacenar desde **\\-128 a 127** 16 bits pueden almacenar desde **\\-32768 a 32767** 32 bits pueden almacenar desde **\\-2147483648 a 2147483647** 64 bits pueden almacenar desde ‚àí9,223,372,036,854,775,808 a 9,223,372,036,854,775,807 nosotros evitaremos utilizar la declaraci√≥n com√∫n en favor de la declaraci√≥n provista por la biblioteca stdint.h cuando de manipulaci√≥n de registros se trate.\n"}),a.add({id:21,href:'/eleckia/docs/perifericos/gpio/perifericos-atmega328p-puertos-de-entrada-salida-de-proposito-general-gpio/',title:"Perif√©ricos atmega328p.- Puertos de entrada/salida de prop√≥sito general (GPIO)",section:"GPIO",content:"Puertos de entrada/salida de prop√≥sito general. #  Cando pensamos en programar microcontroladores, lo que queremos es hacer que el mundo se mueva, controlar un motor, un relevador, una lampara, altavoz, etc. Para ello los microcontroladores cuentan con una serie de perif√©ricos. A grandes rasgos un perif√©rico puede definirse como: una interfaz que permite al microcontrolador comunicarse con el exterior, en esta entrada describiremos los puertos de entrada/salida de prop√≥sito general; GPIOx.\nSeg√∫n la hoja de datos el atmega328p tiene hasta 23 pines programables, cada uno con la posibilidad de ser programado individualmente, Arduino Uno tiene 20 pines disponibles, pues 2 est√°n destinados al reloj y el otro est√° destinado al pin de reset.\nLos pines est√°n agrupados en puertos, en el atmega328 contamos con tres puertos disponibles, PORTB, PORTC, PORTD, de manera gen√©rica los llamamos PORTx, cada uno de estos puertos cuentan con tres registros asociados, DDRx, PORTx, PINx, donde \u0026ldquo;x\u0026rdquo; es el puerto(B, C, D), estos nueve registros nos permiten configurar y acceder a los valores de cada uno de los pines pertenecientes al microcontrolador.\nLos pines en el microcontrolador tienen un nombre del tipo Pxn, donde x es el puerto y n es √©l n√∫mero de pin, el pin PB0 y el pin PD7, son el pin 0 y el pin 7 del puerto B y del puerto D respectivamente.\nConfigurar un Pin como Salida. #  El acceso a los pines individuales no es posible, estamos limitados a a operaciones que involucran 8 bits como m√≠nimo, pues este es el tama√±o del bus de datos y de los registros. Por lo tanto si requerimos escribir el estado del pin PB3, necesariamente debemos escribir todo el puerto B, desde PB0 hasta PB7 (el atmega328p no tiene disponibles todos lo pines PBn).\nSuponiendo que requerimos encender un led que esta conectado al pin PB4, podemos hacer una asignaci√≥n al registro DDRB (Direction Data Register) como la siguiente\nDDRB = (1\u0026lt;\u0026lt;PB4); //En binario es igual a DDRB = 0b00010000; Esto efectivamente coloca al pin 4 como salida, sin embargo coloca al resto de los pines como entrada, para resolver este problema haremos uso del operador binario or. El operador or compara bit a bit y posici√≥n por posici√≥n con la regla,\n0 or 0 = 0 1 or 0 = 1 0 or 1 = 1 1 or 1 = 1 Por ejemplo, para los n√∫meros binarios, 100 y 010, el resultado de hacer un or bit a bit es\nbit2 bit1 bit0 1 0 0 or or or 0 1 0 -------------- 1 1 0 Resultado Asumiendo que el registro DDRB contiene el valor 0000 0111, es decir los 3 primeros bits est√°n configurados como salidas, requerimos hacer que el bit correspondiente a PB4 sea 1, sin modificar el resto, para ello usamos la sintaxis,\nDDRB = DDRB | (1\u0026lt;\u0026lt;PB4); El s√≠mbolo |, es el operador binario or, significa: or binario entre DDRB y el resultado de la operaci√≥n (1\u0026lt;\u0026lt;PB4),\nDDRB = DDRB | (1\u0026lt;\u0026lt;PB4); //Es igual a DDRB = 0b00000111 | 0b00010000; //Ahora se hacer or, resulta DDRB = 0b00010111; //DDRB queda con el bit 5 en 1 y el resto sin modificar Configurar un Pin como Entrada. #  Para poder hacer acciones m√°s complejas requerimos que nuestro microcontrolador pueda \u0026ldquo;sentir\u0026rdquo; el mundo, los pines de nuestro microcontrolador pueden configurarse para que se pueda interpretar el estado de un pin, establecido por un elemento externo (como un bot√≥n pulsador). Para ello tambi√©n se utiliza el registro DDRx, pero en esta ocasi√≥n el pin a ser configurado se establece como un cero.\nEl operador binario and \u0026amp;, similar al operador or realiza la operaci√≥n and bit a bit, con la siguiente regla,\n0 and 0 = 0 0 and 1 = 0 1 and 0 = 0 1 and 1 = 1 Por ejemplo en los siguientes n√∫meros binarios el resultado es,\nbit2 bit1 bit0 1 0 0 and 0 1 0 -------------- 0 0 0 Otro operador (en este caso unario) importante es el complemento a uno ~, cambia el valor de 1 a 0 y de 0 a 1, por ejemplo:\n1010 ~ ----- 0101 Asumiendo que el registro DDRC contiene el n√∫mero 010 0011, requerimos configurar el pin PC0 como entrada, asignar DDRC = 0 no es aceptable (colocar√≠a todos los pines como entrada), en su lugar usaremos el siguiente c√≥digo\nDDRC = DDRC \u0026amp; ~(1\u0026lt;\u0026lt;PC0); //Primero se realiza (1\u0026lt;\u0026lt;PC0), resulta DDRC = DDRC \u0026amp; ~0b00000001; //Ahora se aplica el operador complemento, resulta DDRC = DDRC \u0026amp; 0b11111110; //Operador And bit a bit, DDRC = 0b00100011 \u0026amp; 0b11111110; //Resulta DDRC = 0b00100010; De esta forma logramos establecer el pin requerido sin afectar el resto.\nEstablecer el estado cuando el pin es una salida. #  Cuando un pin es configurado como salida, puede entregar/recibir potencia, poquita, pero suficiente para mover al mundo, para ello se requiere establecer el estado del pin, asumiendo que tenemos conectado un led al pin PB4 y que dicho pin esta configurado como salida en el registro DDRB, entonces podemos establecer el estado del pin en el registro PORTB, donde un cero es nivel bajo(0 V) y un uno es nivel alto (5 V).\n//Led encendido PORTB = PORTB | (1\u0026lt;\u0026lt;PB4); //Led apagado PORTB = PORTB \u0026amp; ~(1\u0026lt;\u0026lt;PB4); Por supuesto lo mismo aplica para los otros puertos.\nResistencia de Pull up. #  ¬øQu√© pasa cuando escribimos los registros PORTx cuando DDRx es configurado como entrada?, la respuesta es que con un uno se conecta una resistencia interna llamada de Pull Up, mientras que con un cero se desconecta, la resistencia de pull up es de gran utilidad cuando se censan entradas, un pin configurado como entra, tiene la caracter√≠stica de ser sensible al ruido electromagn√©tico del ambiente, cuando se activa la resistencia de pull up se produce una corriente que pasa por el pin, disminuyendo la sensibilidad al ruido y obligando una tensi√≥n en el pin en nivel alto (5 Volts).\nLeer el estado de un pin. #  Cuando requerimos leer el estado del pin, utilizamos el registro PINx, es un registro de 8 bits, contiene el estado de cada unos de los pines del puerto, Para censar al pin, debemos configurarlo como entrada en el registro DDRx.\nPara leer el estado del pin PC0, asumiendo que PC0 esta conectado a 5V y que PC0 esta configurado como entrada en DDRC (con un cero),\n//suponiendo que declaramos una variable adecuada llamada //entrada entrada = PINC \u0026amp; (1\u0026lt;\u0026lt;PC0); //Es igual a entrada = 0bxxxxxxx1 \u0026amp; 0b00000001; //donde las x pueden ser 0 o 1 //aplicando and bit a bit resulta en entrada = 0b00000001; //entrada es exactamente igual a entrada = 1; //si PC0 estuvera conectado a tierra, //entrada resultar√≠a en entrada = 0bxxxxxxx0 \u0026amp; 0b00000001; //aplicando and bit a bit resulta en entrada =0b00000000; //o entrada = 0; Operadores de asignaci√≥n. #  Para evitar verbosidad podemos usar operadores de asignaci√≥n m√°s complejos, por ahora presento dos adicionales, |= y \u0026amp;=, su utilidad es obvia\n//en lugar de PORTx = PORTx | (1\u0026lt;\u0026lt;Pxn); DDRx = DDRx \u0026amp; ~(1\u0026lt;\u0026lt;Pxn); //podemos usar PORTx |= 1\u0026lt;\u0026lt;Pxn; DDRx \u0026amp;= ~(1\u0026lt;\u0026lt;Pxn); //ambas expresiones producen resultados //identicos "}),a.add({id:22,href:'/eleckia/posts/electronica-basica-voltaje-corriente-resistencia-y-ley-de-ohm/',title:"Electr√≥nica B√°sica.- Voltaje, Corriente, resistencia y ley de Ohm.",section:"Posts",content:"Cuando la gente de computaci√≥n escucha las palabras en el titulo de esta entrada, suele entrar en p√°nico y no es para menos, el an√°lisis de circuitos el√©ctricos puede llegar a ser muy complejo; sin embargo la electr√≥nica descansa sobre una ley simple, la ley de Ohm,\n$latex V = iR$\nla ley de Ohm relaciona el voltaje con la corriente y la resistencia; pero esto no nos dice nada si no entendemos estos t√©rminos, comencemos con el voltaje, tambi√©n llamado tensi√≥n o potencial el√©ctrico, en la f√≠sica,\nE_l voltaje se define como la cantidad de trabajo necesaria para mover una carga desde el infinito hasta un punto determinado_.\nAhora que ya sabes y entendiste claramente el voltaje pasemos con lo siguiente (es broma obviamente), la definici√≥n no nos sirve pues se aleja demasiado de la parte pr√°ctica, una forma m√°s laxa y √∫til de interpretarlo es;\nEl voltaje es una fuente de energ√≠a el√©ctrica que impulsa a la corriente el√©ctrica a fluir a trav√©s de un circuito el√©ctrico.\nEsta definici√≥n no rigurosa pero nos es de gran utilidad, por la definici√≥n y por la ley de Ohm, su unidad de medida es el Volt [V], si el voltaje es muy grande la corriente que puede proveer la fuente es de mayor intensidad, por el contrario si el voltaje es negativo, \u0026ldquo;absorbe\u0026rdquo; corriente el√©ctrica.\n¬øPero qu√© es la corriente el√©ctrica?, pues no es m√°s que un flujo de cargas el√©ctricas, flujo de electrones a trav√©s de un medio, usualmente un conductor, pero puede ser incluso a trav√©s del aire form√°ndose un arco el√©ctrico cuando hay voltaje muy alto, su unidad de medida es el Ampere [A], se le representa con un s√≠mbolo \u0026ldquo;i\u0026rdquo; en el esquema a continuaci√≥n, la direcci√≥n de la corriente va de voltaje alto a voltaje bajo; o si solo hay una fuente va de la terminal positiva a tierra (una forma com√∫n de referirse al voltaje o potencial 0[V]).\nDirecci√≥n de la corriente\nUna resistencia es un elemento que se opone a el paso de la corriente, si colocamos en un circuito el√©ctrico un resistencia de 10 Ohms, la corriente que pasa por ella seria mucho mayor que si coloc√°ramos una resistencia de 1000 Ohms.\nPor ejemplo, tenemos una fuente de 5V, una resistencia de 330 Ohms conectada entre sus terminales, ¬øQu√© corriente pasa por la resistencia?\nsabemos que $latex V = i R$, dividiendo ambos lados entre la resistencia\n$latex \\frac{V}{R} = \\frac{iR}{R}$\npor lo tanto, la corriente es\n$latex i = \\frac{V}{R}$\n$latex = \\frac{5}{330}=0.015 [A] = 15 [mA]$\n¬øPor qu√© es importante conocer la corriente?, debido a que cada pin de nuestro microcontrolador tiene poca capacidad de entregar o recibir potencia, dicho de otra forma la corriente que sale de cada pin est√° limitada, para el atmega328p la corriente m√°xima de cada pin es de 40mA y la corriente entre todos los pines no debe ser superior a 200mA, sobrepasar este limite implica da√±ar el microcontrolador, para manejar corrientes grandes mayores a 10[mA] utilizaremos componentes externos.\n"}),a.add({id:23,href:'/eleckia/posts/que-son-los-registros-en-un-microcontrolador/',title:"¬øQu√© son los registros en un microcontrolador?",section:"Posts",content:"Hemos hablado acerca de los registros en anteriores entradas, vamos a profundizar un poco en el tema.\nPara entender un registro, definamos que es un bit, la palabra tiene varias acepciones, para nuestro prop√≥sito un bit es la representaci√≥n de un valor binario, este puede ser 1 o 0. Entonces un registro es sencillamente un conjunto de bits, en nuestro microcontrolador atmega328p, existen registros de 8bits, en otras arquitecturas como los cortex-m los registros son de 32 bits, algunos como el msp de texas instruments, tienen registros de 16 bits.\n¬øEs mejor 32 que 8 bits?, no realmente, la diferencia radica en que un sistema de 32 bits requiere un bus de 32 bits, un bus podr√≠a definirse como un conjunto paralelo de cables que comunica los registros con alg√∫n otro elemento, en otras palabras un bus de 32 bits comunica mayor informaci√≥n por cada ciclo, a priori esto es bueno, sin embargo las instrucciones que tambi√©n viajan por este bus, no necesariamente ocupan los 32 bits, esto deriva en programas m√°s grandes para las arquitecturas de 32 bits. Hoy por hoy las arquitecturas de 32 bits son muy populares, siendo incluso m√°s baratas y eficientes que sus contrapartes de 8 bits, la gran ventaja de los 8 bits radica en su facilidad y simpleza.\nSiguiendo con los registros, programar un microcontrolador se resume a modificar los registros, ya comentamos el registro DDRx, donde x es un puerto determinado (haremos una serie especifica sobre puertos), modificar dicho registro nos permite establecer el comportamiento de cada uno de los pines pertenecientes a dicho puerto. A lo largo de las entradas iremos revisando varios de los registros y explicaremos las implicaciones que se tienen al modificarlos. En realidad DDRx es un nemot√©cnico no un registro, cuando escribimos DDRB, realmente estamos escribiendo algo similar a *(0xfa020121029120), una vez que estudiemos los apuntadores detallaremos que es lo anterior, adelanto que el n√∫mero entre par√©ntesis es la direcci√≥n del registro).\nEl tema de los registros tiene una gran exposici√≥n cuando se programa en ensamblador, el ensamblador es un lenguaje muy estimulante de aprender y el ensamblador de avr es muy limpio y sencillo, quiz√° en el futuro expliquemos un poco.\n"}),a.add({id:24,href:'/eleckia/docs/avr/programando-avr-en-c-hola-mundo/',title:"Programando Avr en C.- Hola mundo",section:"Programaci√≥n Avr en C.",content:"Hola mundo #  Antes de analizar el c√≥digo Blink en C, explicaremos la estructura b√°sica de un programa en C, el siguiente c√≥digo muestra un programa m√≠nimo\n#include\u0026lt;bibliotecas.h\u0026gt; int main(void) { tipo1 variable1; tipo_n variable_n; while(1){ hacer_cosas(var1, var2, varn); } return 0; } Al inicio de este listado tenemos una directiva del preprocesador, las directivas comienzan con un #, en este caso tenemos una directiva include, que le indica al compilador que copie el contenido del fichero bibliotecas.h en nuestro c√≥digo, esto nos habilita a usar los objetos y funciones que hay dentro de bibliotecas.h, existen diferentes directivas que nos ayudaran a tener un c√≥digo m√°s limpio, es importante no subestimar al preprocesador, pues nos ayudara a hacer cosas que no pueden hacerse de otra forma.\nPosteriormente tenemos la funci√≥n main, la funci√≥n main es un ente importante, cuando el programa se ejecuta, la funci√≥n main es llamada autom√°ticamente, es decir el c√≥digo dentro de las llaves se ejecutara l√≠nea por l√≠nea, lo que est√© fuera de dicha funci√≥n deber√° ser llamado expl√≠citamente para poder ejecutarse. Por definici√≥n la funci√≥n main retorna un entero al finalizar y en el caso de microcontroladores no suele recibir argumentos por eso la palabra void (m√°s adelante analizaremos la estructura de las funciones), una vez llamada la funci√≥n main, se comienzan a ejecutar cada uno de las l√≠neas dentro de ella en orden descendente, en este caso declaramos dos variables de cierto tipo, variable_1 y variable_n.\nPosteriormente hay una parte importante una estructura de flujo while, mantiene en ejecuci√≥n el c√≥digo que contiene mientras la condici√≥n que esta entre par√©ntesis se mantenga verdadera, un 1 siempre es verdadero por lo tanto esto se considera un ciclo infinito, es decir el c√≥digo dentro del while se ejecutara constantemente, cuando llegue a la √∫ltima l√≠nea saltara a la primera dentro sus llaves.\nFinalmente tenemos un retorno, como nuestro programa se queda \u0026ldquo;ciclado\u0026rdquo; dentro del while, nunca alcanzaremos esta l√≠nea, sin embargo es conveniente poner esta l√≠nea o el compilador nos dar√° un warning o advertencia.\nYa estamos un poco m√°s familiarizados con la estructura del programa, ahora si analicemos el programa Blink,\n#include\u0026lt;avr/io.h\u0026gt; #include\u0026lt;util/delay.h\u0026gt; int main(void) { DDRB = 1 \u0026lt;\u0026lt; PB5; PORTB = 0; while(1){ PORTB = 1 \u0026lt;\u0026lt; PB5; \\_delay\\_ms(1000); PORTB = 0; \\_delay\\_ms(1000); } return 0; } Al inicio tenemos dos directivas include, la primera io.h, nos permite acceder a los registros de los puertos de nuestro microcontrolador, en este caso el puerto B, har√© una entrada especifica para este tema, la segunda delay.h nos permite usar la funci√≥n _delay_ms, que como deducir√°s nos permite crear un tiempo muerto.\nIniciamos con la funci√≥n main y lo primero que tenemos es una asignaci√≥n, te preguntaras que es DDRB, para entenderlo primero debo explicar que es un registro y lo explicare en una entrada dedicada, por ahora vamos a decir que DDRB es una variable a secas, a esta variable le asignamos el resultado de una operaci√≥n 1\u0026laquo;PB5, el s√≠mbolo \u0026ldquo;\u0026laquo;\u0026rdquo; es un operado binario llamado left shift o corrimiento a la izquierda, indica que el n√∫mero a la izquierda sera recorrido el n√∫mero de veces que tiene a la derecha en binario, por ejemplo\n3 en binario es 0b0011 3\u0026lt;\u0026lt;1 es en binario 0b0011\u0026lt;\u0026lt;1 y da como resultado 0b0 0110 en decimal 6 3\u0026lt;\u0026lt;2 es en binario 0b0011\u0026lt;\u0026lt;2 y da como resultado 0b0 1100 en decimal 12 3\u0026lt;\u0026lt;3 es en binario 0b0011\u0026lt;\u0026lt;3 y da como resultado 0b1 1000 en decimal 24 en nuestro caso casi siempre, solo usaremos un 1 a la izquierda del operador, por lo tanto\n1 en binario es 0b1 1\u0026lt;\u0026lt;1 da como resultado 0b10 1\u0026lt;\u0026lt;2 da como resultado 0b100 1\u0026lt;\u0026lt;3 da como resultado 0b1000 1\u0026lt;\u0026lt;7 da como result. 0b10000000 //bit 76543210 //Posici√≥n 87654321 realmente no nos interesa el valor en decimal, lo que nos interesa es donde queda posicionado el 1, al final de la operaci√≥n con 1\u0026laquo;2, el 1 queda posicionado en la tercera de derecha a izquierda, con 1\u0026laquo;7, queda en la octava de derecha a izquierda.\n¬øPara que es esto?, DDRB es una \u0026ldquo;variable\u0026rdquo; que le indica al microcontrolador si el pin es de entrada o de salida, si el bit es cero el pin operara como entrada, de lo contrario opera como salida. DDRB contiene 8 bits y cada bit corresponde a un pin de nuestro microcontrolador, al inicio contiene el valor binario 0b0000 0000, cuando revisas la hoja de datos de tu microcontrolador te dar√°s cuenta que los pines est√°n rotulados con las leyendas PA0, PB0, PC0, PA1, etc, estos son los \u0026ldquo;nombres\u0026rdquo; de los pines, A,B,C, es el puerto al que pertenecen, por lo tanto el pin 5 del puerto B es PB5.\nEl pin PB5 esta conectado al led de nuestra tarjeta, hay que decirle a DDRB que ponga el pin 5 como salida, tan f√°cil como\nDDRB = 1\u0026lt;\u0026lt;PB5; //que es exactamente igual a DDRB = 0b00100000; //bit 76543210 Seguimos adelante y tenemos otra asignaci√≥n, PORTB es otro registro, de igual forma asumiremos por ahora que es una variable, controla el estado del pin, el estado puede ser 0 para bajo o 1 para alto, en s√≠ntesis cuando el pin se configura en alto tendr√° 5 volts y cuando se configura en bajo tendr√° 0 volts, cuando necesitemos encender el led lo configuramos como alto con\nPORTB = 1\u0026lt;\u0026lt;PB5; //que es exactamente igual a PORTB = 0b00100000; ¬øy si queremos ponerlo en bajo?, por ahora solo esto,\nPORTB = 0; //que es id√©ntico a PORTB = 0b00000000; esto tiene el peque√±o inconveniente de poner el resto de pines en bajo y es muy probable que nuestro colega que este us√°ndolos se enoje con nosotros, m√°s adelante encontraremos una mejor manera.\nSiguiendo con el programa, entramos al ciclo infinito en donde la parte interesante es la funci√≥n _delay_ms(), la funci√≥n se explica por si misma, cuando se llama toma el control de la ejecuci√≥n del programa y espera la cantidad de tiempo indicada en milisegundos, en este caso 1000 que equivale a un segundo.\nEl programa se queda en este bucle encendiendo y apagando el led cada dos segundos. La √∫ltima l√≠nea no se ejecuta pues el ciclo no se interrumpe.\n"}),a.add({id:25,href:'/eleckia/docs/workstation/arduino-basico-iii/',title:"Arduino B√°sico III",section:"Estaci√≥n de trabajo",content:"Arduino B√°sico III #  El siguiente paso obvio es analizar el programa Blink, sin embargo aqu√≠ no usaremos las bibliotecas de Arduino, usaremos c√≥digo c para dispositivos AVR, entonces ¬øpara que tanto problema instalando la maquina virtual y Arduino?, simplemente porque utilizaremos la infraestructura ya hecha para nuestro prop√≥sito, abrimos el ejemplo Blink y reemplazamos el c√≥digo por:\n#include\u0026lt;avr/io.h\u0026gt;#include\u0026lt;util/delay.h\u0026gt; int main(void) { DDRB = 1 \u0026lt;\u0026lt; PB5; PORTB = 0; while(1){ PORTB = 1 \u0026lt;\u0026lt; PB5; _delay_ms(1000); PORTB = 0; _delay_ms(1000); } return 0; } compilamos y subimos el c√≥digo, el comportamiento es exactamente el mismo, pero el c√≥digo es totalmente C y no C++, tambi√©n evitamos el uso de las bibliotecas de Arduino en favor de las avr. Esto se nota de inmediato en el tama√±o del programa, mientras que nuestro c√≥digo usa 108 Bytes, el c√≥digo de Arduino usa 924 Bytes, esto realmente no es determinante, en un proyecto complejo y grande usar una biblioteca u otra no tendr√° gran impacto en el tama√±o final. En realidad las Arduino usan como base las bibliotecas avr. Este peque√±o hola mundo, da para comentar muchas cosas, no te preocupes por no entender el c√≥digo, iremos desglos√°ndolo en las siguientes entradas, tambi√©n mostrare como liberarnos del IDE y por si fuera poco como liberarnos de la tarjeta.\n¬øPor qu√© no usar √∫nicamente Arduino para todo?, la verdad es que la √∫nica raz√≥n verdadera y valida es que no me gusta, otras razones menos validas son:\n Te limita a un pu√±ado de microcontroladores.- Dentro de la familia de los microcontroladores avr apenas unos cuantos son utilizados para las tarjetas Arduino, existen ports a otras arquitecturas y micros, pero suelen ser limitadas, quiz√° lo que requieres realizar sea un programa muy sencillo, quiz√° no necesites toda la potencia que te ofrece un atmega328p, tal vez lo que necesites sea un attiny13(hiper barato y peque√±o), por el contrario tal vez requieres algo muy r√°pido y potente como un amr cortex m7, o un risc V, no siempre tenemos a disponibilidad las bibliotecas de Arduino, pienso que es importante saber hacer tus propias bibliotecas y adaptarlas a un hardware cambiante. Te obliga a usar C++, aunque es posible enlazar bibliotecas de C++ en C, es un proceso un poco traum√°tico, el problema de C++ es que es dif√≠cil de leer, el ejemplo cl√°sico es el siguiente  struct unaEstructura primero = nuevoNumero(); struct unaEstructura segundo = nuevoNumero(); // C a = primero.num + segundo.num; //En C esto tiene un significado obvio // C++ a = primero + segundo; //A priori no sabemos que esta pasando aqu√≠ pudiera parecer una trivialidad, pero de igual forma sucede con varias otras situaciones, realmente es una cuesti√≥n de simple gusto, C++ es un lenguaje muy potente, si te sientes c√≥modo con √©l √∫salo y expl√≥talo al m√°ximo.\n El entorno en general es precario. No se puede tener todo, si es f√°cil tiene que haber un costo, el costo es que no tenemos herramientas de debugging, el editor es horrible, no se adapta muy bien a los proyectos colaborativos, no hay control de versiones.  Sin embargo hay muchas cosas buenas que no se encuentran en ning√∫n otro ambiente, por lo tanto debemos equilibrar nuestras preferencias en aras de obtener el mejor rendimiento y calidad.\n"}),a.add({id:26,href:'/eleckia/posts/bloque-reutilizable-sin-titulo/',title:"save",section:"Posts",content:"El siguiente paso obvio es analizar el programa Blink, sin embargo aqu√≠ no usaremos las bibliotecas de Arduino, usaremos c√≥digo c para dispositivos AVR, entonces ¬øpara que tanto problema instalando la maquina virtual y Arduino?, simplemente porque utilizaremos la infraestructura ya hecha para nuestro prop√≥sito, abrimos el ejemplo Blink y reemplazamos el c√≥digo por:\n#include\u0026lt;avr/io.h\u0026gt; #include\u0026lt;util/delay.h\u0026gt; int main(void) { DDRB = 1 \u0026lt;\u0026lt; PB5; PORTB = 0; while(1){ PORTB |= 1 \u0026lt;\u0026lt; PB5; \\_delay\\_ms(1000); PORTB \u0026amp;= ~(1\u0026lt;\u0026lt;PB5); \\_delay\\_ms(1000); } } compilamos y subimos el c√≥digo, el comportamiento es exactamente el mismo, pero el c√≥digo es totalmente C y no C++, tambi√©n evitamos el uso de las bibliotecas de Arduino en favor de las avr. Esto se nota de inmediato en el tama√±o del programa, mientras que nuestro c√≥digo usa 108 Bytes, el c√≥digo de Arduino usa 924 Bytes, esto realmente no es determinante, en un proyecto complejo y grande usar una biblioteca u otra no tendr√° gran impacto en el tama√±o final. En realidad las Arduino usa como base las bibliotecas avr. Este peque√±o hola mundo, da para comentar muchas cosas, no te preocupes por no entender el c√≥digo iremos desglos√°ndolo en las siguientes entradas, tambi√©n mostrare como liberarnos del IDE y por si fuera poco como liberarnos de la tarjeta.\n¬øPor qu√© no usar unicamente Arduino para todo?, la verdad es que la √∫nica raz√≥n verdadera y valida es que no me gusta, otras razones menos validas son:\n Te limita a un pu√±ado de microcontroladores.- Dentro de la familia de los microcontroladores avr apenas unos cuantos son utilizados para las tarjetas Arduino, existen ports a otras arquitecturas y micros, pero suelen ser limitadas, quiz√° lo que requieres realizar sea un programa muy sencillo, quiz√° no necesites toda la potencia que te ofrece un atmega328p, tal vez lo que necesites sea un attiny13(hiper barato y peque√±o), por el contrario tal vez requieres algo muy r√°pido y potente como un amr cortex m7, o un risc V, no siempre tenemos a disponibilidad las bibliotecas de Arduino, pienso que es importante saber hacer tus propias bibliotecas y adaptarlas a un hardware cambiante. Te obliga a usar C++, aunque es posible enlazar bibliotecas de C++ en C, es un proceso un poco traum√°tico, el problema de C++ es que es muy dif√≠cil de leer, el ejemplo cl√°sico es el siguiente  struct unaEstructura primero = nuevoNumero(); struct unaEstructura segundo = nuevoNumero(); // C a = primero.num + segundo.num; //En C esto tiene un significado obvio // C++ a = primero + segundo; //A priori no sabemos que esta pasando aqu√≠ pudiera parecer una trivialidad, pero de igual forma sucede con varias otras situaciones, realmente es una cuesti√≥n de simple gusto, C++ es un lenguaje muy potente, si te sientes c√≥modo con √©l √∫salo y expl√≥talo al m√°ximo.\n El entorno en general es precario. No se puede tener todo, si es f√°cil tiene que haber un costo, el costo es que no tenemos herramientas de debugging, el editor es horrible, no se adapta muy bien a los proyectos colaborativos, no hay control de versiones.  Sin embargo hay muchas cosas buenas que no se encuentran en ning√∫n otro ambiente, por lo tanto debemos equilibrar nuestras preferencias en aras de obtener el mejor rendimiento y calidad.\n"}),a.add({id:27,href:'/eleckia/docs/workstation/arduino-basico-ii-hola-mundo/',title:"Arduino B√°sico II.- Hola Mundo",section:"Estaci√≥n de trabajo",content:"Hola Mundo #  Conectamos nuestro Arduino a nuestra PC por medio del cable USB, si estas utilizando Virtual Box, es necesario que le des permiso al \u0026ldquo;invitado\u0026rdquo; para que use el puerto USB, esto se hace en el men√∫ de Virtual Box, devices-\u0026gt;USB-\u0026gt; dispositivo correspondiente a Arduino(probablemente FTDI). Para verificar que nuestro Arduino esta conectado y lo reconoce el sistema, abrimos una terminal y tecleamos\n[eleckia@tuxin-lp ~]$ dmesg si el dispositivo esta conectado obtendremos una salida similar a esta:\n[26227.988155] usb 2-1: new full-speed USB device number 3 using ohci-pci [26228.164271] usb 2-1: New USB device found, idVendor=2341, idProduct=0043, bcdDevice= 0.01 [26228.164279] usb 2-1: New USB device strings: Mfr=1, Product=2, SerialNumber=220 [26228.164284] usb 2-1: Manufacturer: Arduino (www.arduino.cc) [26228.164287] usb 2-1: SerialNumber: 7553334343635121A191 [26228.282966] cdc_acm 2-1:1.0: ttyACM0: USB ACM device [26228.287986] usbcore: registered new interface driver cdc_acm [26228.287989] cdc_acm: USB Abstract Control Model driver for USB modems and ISDN adapters Esto implica que nuestro Arduino esta conectado y la PC lo reconoce como un dispositivo ACM, ahora abrimos el IDE de Arduino, la primera vez que lo abrimos nos aparecer√° algo como esto. (Si no aparece la salida anterior, probablemente no seleccionaste el dispositivo correcto en virtual box, prueba con otro.)\nhacemos click en herramientas-\u0026gt;Puerto y seleccionamos el puerto al que est√© conectado el Arduino, probablemente solo haya uno disponible, en mi caso /dev/ttyACM0, en el caso de que no apareciera ning√∫n puerto disponible, lo m√°s probable es que te falte agregar tu usuario a los grupos lock y dialout simplemente,\n[eleckia@tuxin-lp ~]$ sudo gpasswd -a $USER lock [eleckia@tuxin-lp ~]$ sudo gpasswd -a $USER dialout debes salir de la sesi√≥n o en su defecto reiniciar tu sistema.\nContinuamos, el \u0026ldquo;Hola Mundo\u0026rdquo; es un programa tradicional en el mundo de la programaci√≥n, consiste en mostrar la frase \u0026ldquo;Hola mundo\u0026rdquo; en la pantalla, traducida a los sistemas embebidos consiste en hacer parpadear un led. El entorno de desarrollo trae el c√≥digo ya escrito, vamos a Archivo-\u0026gt;Ejemplos-\u0026gt;Basic-\u0026gt;Blink nos abrir√° una ventana con el siguiente c√≥digo:\n// the setup function runs once when you press reset or power the board void setup() { // initialize digital pin LED\\_BUILTIN as an output.  pinMode(LED\\_BUILTIN, OUTPUT); } // the loop function runs over and over again forever void loop() { digitalWrite(LED\\_BUILTIN, HIGH); // turn the LED on (HIGH is the voltage level)  delay(1000); // wait for a second  digitalWrite(LED\\_BUILTIN, LOW); // turn the LED off by making the voltage LOW  delay(1000); // wait for a second } Sin modificar nada, vamos a subir este programa a la tarjeta, tan solo hacemos click en el icono de la palomita para compilar y despu√©s en el icono de la flecha para subir, o con las teclas ctrl+R y ctrl+U respectivamente. Si todo esta correcto veremos que el led de nuestro Arduino comienza a parpadear cada segundo aproximadamente.\n"}),a.add({id:28,href:'/eleckia/docs/workstation/arduino-basico-i/',title:"Arduino B√°sico I.",section:"Estaci√≥n de trabajo",content:"Arduino #  Comenzamos formalmente nuestro estudio, como se menciono anteriormente, Arduino se compone tanto de software como de hardware, miremos un poco el hardware.\nEl Arduino Uno (placa de desarrollo), cuenta con un puerto usb, por el que se alimenta la placa; enviamos y recibimos datos, este puerto esta conectado a un circuito integrado que no es m√°s que un convertidor serial-usb, al mismo tiempo este convertidor se conecta a unos pines espec√≠ficos del microcontrolador. Lo importante a destacar es que esta conexi√≥n ya esta hecha y es perfectamente funcional, sino fuera as√≠ tendr√≠amos que dise√±ar un circuito para poder conectar el microcontrolador con la PC, esta es sin duda la gran caracter√≠stica que dio paso al √©xito, una plataforma lista para usarse sin necesidad de componentes adicionales.\nEl convertidor serial varia dependiendo de la versi√≥n de tu tarjeta, pero su comportamiento es similar en todas las versiones, por ahora nos enfocamos en conocer el microcontrolador,\nEl atmega328p es un microcontrolador RISC de 8 bits, no entraremos en detalles de la arquitectura pero si en sus caracter√≠sticas, quiz√° el par√°metro m√°s importante es la capacidad de memoria con la que cuenta, la asombrosa cantidad de 32KB de flash o memoria de programa y 2KB de ram, teniendo en cuenta que en este momento contamos con PCs regularmente de 8GB de ram y mayores de 1TB de almacenamiento, la memoria del atmega328p parecer√≠a poco, sin embargo se pueden hacer muchas cosas con ella y cuando digo muchas es muchas, adicionalmente cuenta con 1KB de memoria eeprom, en la cual podemos guardar datos y evitar que se pierdan cuando se corta la alimentaci√≥n.\nOtro par√°metro importante es la frecuencia a la que trabaja, siendo hasta 20MHz el m√°ximo posible, internamente cuenta con un oscilador que puede ser configurado hasta 8MHz, si queremos frecuencias mayores podemos conseguirlas conectado un oscilador externo, usualmente un reloj de cuarzo, la regla es que a mayor frecuencia mayor capacidad de procesamiento, pero mayor gasto de energ√≠a. En el caso del Arduino(tarjeta), tiene un reloj de 16MHz ya conectado, por lo que el entorno esta desarrollado con este reloj en mente.\nCuenta con 23 pines programables en la versi√≥n DIP y hasta 32 en la versi√≥n de montaje superficial.\nLos perif√©ricos con los que cuenta\n Tiimer con output compare ADC USART SPI I2C Y varias fuentes de interrupciones  Describir√© con mucho detalle los perif√©ricos en posteriores entradas.\nAunque suene trillado, este es el coraz√≥n de Arduino. Mi objetivo es exponer al microcontrolador per se m√°s que al ambiente Arduino en general.\nAdicionalmente la tarjeta cuenta con un par de hileras de pines donde podemos conectar componentes externos, un jack de alimentaci√≥n por el cual podemos conectar hasta 9V, recomiendo no conectar USB y jack al mismo tiempo, finalmente un LED conectado al pin 13.\n"}),a.add({id:29,href:'/eleckia/docs/workstation/estacion-de-trabajo/',title:"Estaci√≥n de trabajo",section:"Estaci√≥n de trabajo",content:"Estaci√≥n de trabajo #  No es obligatorio instalar Fedora, pero todos los ejemplos se har√°n desde este sistema operativo, eres libre de adaptar lo que aqu√≠ se mencione a tus circunstancias.\nPara poder trabajar a gusto es necesario disponer de un conjunto de herramientas adecuado, dejando de lado el tipo de computadora con la que se cuenta, lo importante es el sistema operativo, utilizaremos software libre, nuestro sistema operativo sera linux, concretamente Fedora, esta distribuci√≥n cuenta con los paquetes necesarios para desarrollar software c√≥modamente, as√≠ que si utilizas algo diferente comienza borrado tu disco duro e instala Fedora (obviamente esto es broma :D).\nLa manera m√°s sencilla de comenzar en este mundo (y la que seguiremos aqu√≠) es con linux + arduino, hablemos r√°pida y brevemente de ellos.\nLinux es una pieza de software que funciona como interfaz entre el hardware de una computadora (memoria, procesador, perif√©ricos, etc), en pocas palabras y de manera muy general, linux se encarga de administrar el hardware de una PC, por otro lado existe software (GNU y otros) que se comunica con linux para formar un sistema operativo, de ah√≠ surgen los sistemas GNU/Linux, a grandes rasgos el software GNU se encarga de administrar el sistema, envi√°ndole instrucciones a Linux (com√∫nmente llamado kernel o n√∫cleo) y este √∫ltimo las ejecuta en el hardware. Para el que este interesado en entender un poco m√°s sobre el origen y filosof√≠a de GNU/linux y el software libre, les recomiendo ver el documental \u0026ldquo;C√≥digo linux\u0026rdquo;, disponible en youtube en espa√±ol. Compa√±√≠as aprovechan este conjunto de software para crear distribuciones, en nuestro caso trabajaremos con la distribuci√≥n Fedora, patrocinada por Red Hat, disponible para su descarga gratuitamente.\nArduino es una plataforma de desarrollo, contiene tanto software como hardware, sera com√∫n referirnos de manera indistinta al software o hardware con la palabra Arduino, con respecto al hardware hay muchas versiones, siendo el \u0026ldquo;Arduino uno\u0026rdquo; el m√°s com√∫n y el que utilizaremos, este Arduino cuenta con un microcontrolador atmega328p, es un microcontrolador de la empresa Microchip, anteriormente le pertenec√≠a a Atmel, pero fue comprada por la anterior mencionada, el microcontrolador es de 8 bits y contiene numerosos perif√©ricos. Arduino es software libre pero tambi√©n hardware libre, esto implica que los clones funcionen de manera id√©ntica a el hardware original, aunque si puedes comprarlo original siempre es bueno apoyar a los creadores. En la parte de software Arduino cuenta con su propio entorno de desarrollo (aunque a mi me parece horrible) y cuenta con miles de bibliotecas listas para ser usadas en nuestros proyectos.\nLo que requerimos:\n-Instalar Fedora\n-Adquirir un Arduino\n-Instalar Arduino dentro de Fedora\nComencemos instalando Fedora, como mencionamos Fedora es un sistema operativo, por lo tanto requerimos instalarlo en nuestra PC, podemos instalar junto a nuestro sistema operativo actual, podemos reemplazar nuestro sistema operativo actual por Fedora o si ya utilizamos Fedora como sistema operativo principal no hay necesidad de reinstalarlo, la √∫ltima opci√≥n es instalarlo en una maquina virtual, si eres usuario windows probablemente esta opci√≥n es la m√°s adecuada para ti.\nUna maquina virtual es un entorno que permite ejecutar un sistema operativo adicional sobre uno ya en ejecuci√≥n, el sistema adicional se conoce como \u0026ldquo;huesped\u0026rdquo;(guess) y el que ya esta en ejecuci√≥n se le denomina \u0026ldquo;anfitri√≥n\u0026rdquo;(host), de esta manera podemos instalar Fedora sin la necesidad de modificar nuestro sistema operativo actual.\nInstalando VirtualBox #  Procedemos a instalar la maquina virtual, para ello visitamos el enlace https://www.virtualbox.org/\ny descargamos la versi√≥n m√°s reciente para nuestro sistema operativo anfitrion(probablemente windows), no entrare en detalles sobre como instalar virtual box puesto que cada sistema es diferente, pero confi√≥ en que sabes como instalar programas en tu sistema, para instalarlo en windows doble click sobre el ejecutable descargado, si eres usuario linux seguramente viene en los repositorios oficiales de tu distribuci√≥n.\nCreando la maquina virtual #  Ahora descargaremos Fedora, accedemos al enlace\nhttps://getfedora.org/es/\nexisten varias ediciones, elegimos Workstation y la descargamos, la descarga es una imagen .iso de alrededor de 2GB, una vez descargado procedemos a instalar.\nAbrimos Virtualbox y seleccionamos \u0026ldquo;nueva\u0026rdquo;\nSe abrir√° una nueva ventana escribimos \u0026ldquo;Fedora\u0026rdquo; en nombre, carpeta la dejamos por defecto, seleccionamos, tipo \u0026ldquo;Linux\u0026rdquo; y Versi√≥n \u0026ldquo;Fedora (64-bit)\u0026rdquo;, click en siguiente.\nAhora nos pide configurar la memoria, aqui aparece un control de deslizamiento, selecciona por lo menos 2GB y da click en siguiente.\nAhora nos pide configurar un nuevo disco duro, seleccionamos \u0026ldquo;Crear un disco virtual Ahora\u0026rdquo; y damos click en siguiente.\nTipo de archivo de disco duro, VDI, siguiente.\nAlmacenamiento en unidad de disco duro f√≠sica, Reservado din√°micamente, siguiente.\nUbicaci√≥n del archivo y tama√±o, dejamos la ubicaci√≥n por defecto y seleccionamos un tama√±o de 20GB, siguiente.\nHemos finalizado la creaci√≥n de la maquina virtual, procedemos a instalar Fedora en el siguiente post.\nInstalando Fedora dentro de VirtualBox #  Abrimos VirtualBox y seleccionamos la maquina virtual Fedora que creamos anteriormente, ahora damos click en Configuraci√≥n, se nos abrir√° una nueva ventana, seleccionamos Almacenamiento y en controlador IDE, seleccionamos Vaci√≥, a la derecha de unidad √≥ptica damos click en el icono de un disco azul y seleccionamos el .iso de Fedora que descargamos anteriormente, finalmente damos click en aceptar.\nSi tienes anfitri√≥n linux, ah√≠ mismo en configuraci√≥n seleccionamos Pantalla y cambiamos Controlador Gr√°fico a VBoxVGA y aumenta la memoria de video a por lo menos 64MB.\nNuevamente en Configuraci√≥n, ahora seleccionamos Sistema y en la pesta√±a Procesador, seleccionamos el n√∫mero de procesadores que tenemos, damos click en aceptar.\nNuestra maquina virtual, esta lista para arrancar y ya tiene el \u0026ldquo;disco\u0026rdquo; de instalaci√≥n insertado, procedemos a iniciarla con el icono Iniciar.\nArrancamos y la primer pantalla de selecci√≥n nos da tres opciones, seleccionamos la primera, Start Fedora, cuidado por defecto esta seleccionada la segunda opci√≥n.\nEsperamos a que el sistema inicie y tenemos una versi√≥n live de Fedora funcionando,\nEsta versi√≥n de Fedora es totalmente funcional, podemos jugar con ella, revisar los programas y menus, cambiar la resoluci√≥n, etc, sabedores de que los cambios que hagamos no se guardaran, cuando estemos listos damos click en Install to Hard Drive. Se abrir√° el asistente de instalaci√≥n Anaconda (puede que tarde unos minutos), aqu√≠ elegimos el idioma y la regi√≥n y damos click en continuar,\nseleccionamos nuestra distribuci√≥n de teclado(probablemente espa√±ol latinoamericano) y la zona horaria, click en Destino de la Instalaci√≥n, sin modificar nada damos click en Hecho en la esquina superior izquierda y comenzamos la instalaci√≥n.\nEsperamos unos minutos a que termine la instalaci√≥n y damos click en salir.\nApagamos la maquina virtual y removemos la imagen .iso de Fedora.\nIniciamos nuevamente la maquina virtual esta vez iniciara Fedora instalado, todo lo que hagamos ahora si se guardara, nos dar√° la bienvenida un asistente de configuraci√≥n donde nos pedir√° algunos datos, de ellos lo importante es el usuario y la contrase√±a, los cuales debemos recordar o en su defecto anotar. Una vez ingresados nuestro sistema estar√° listo para poder instalar Arduino.\nInstalando Arduino #  Ya casi estamos listos, damos click en Actividades y abrimos una terminal, la terminal puede ser intimidante, pero creeme una vez te acostumbres a ella la amaras.\nEn los sistemas linux tenemos diferentes tipos de usuarios cada uno de ellos con diferentes privilegios, el usuario con m√°s privilegios es el usuario root, puede hacer y deshacer el sistema, nuestro usuario por defecto tiene pocos privilegios para evitar que el usuario pueda romper el sistema por accidente. Al abrir la terminal tendremos algo similar a esto\n[eleckia@tuxin-lp ~]$ donde eleckia es el nombre de usuario que se eligi√≥, y tuxin-lp es el nombre que se le dio a la pc, delante del signo $, podemos escribir.\nDNF es el manejador de paquetes de Fedora, es una herramienta que nos permite actualizar, instalar y remover los programas y/o bibliotecas instaladas en nuestro sistema, para utilizarlo simplemente tecleamos\n[eleckia@tuxin-lp ~]$ dnf nos desplegara una enorme lista de las opciones disponibles para este comando, el que nos interesa por ahora es update, esta opci√≥n nos actualiza todos los paquetes a la √∫ltima versi√≥n disponible, tecleamos\n[eleckia@tuxin-lp ~]$ dnf update Error: Este comando debe ejecutarse como usuario root. el error nos indica que requerimos privilegios altos, la forma de escapar de la tiran√≠a el usuario root, es anteponer la palabra sudo,\n[eleckia@tuxin-lp ~]$ sudo dnf update nos pedir√° introducir la contrase√±a que creamos al iniciar Fedora por primera vez, la introducimos y nos desplegar√° la lista de actualizaciones disponibles, nos pedir√° confirmaci√≥n a lo que responderemos s. La primera vez que actualicemos, habr√° muchas actualizaciones, por lo que se tardara un poco, al terminar de actualizar, reiniciaremos el sistema y abriremos nuevamente una terminal, una vez hecho esto instalaremos Arduino por fin. Para instalarlo tan f√°cil como escribir lo siguiente:\n[eleckia@tuxin-lp ~]$ sudo dnf install arduino terminada la descarga e instalaci√≥n, ya tenemos disponible el software Arduino, hacemos click en actividades y lo ejecutamos, nos indicara que debemos agregar nuestro usuario a los grupos dialout y lock, le decimos que si e introducimos la contrase√±a del sistema, tenemos finalmente todo listo para comenzar a programar, tan solo nos falta conectar nuestro Arduino a un puerto usb.\nAnteriormente mencione que trabajaremos con Arduino uno, sin embargo debo confesar que cualquier Arduino de 8 bits es valido, de hecho ni siquiera es necesario instalar Fedora, puedes instalar Arduino en casi cualquier sistema operativo, la raz√≥n de instalar Fedora es que nos ofrece todas las herramientas de manera simple e inmediata, al estar dentro de una m√°quina virtual no debemos preocuparnos de da√±ar el sistema accidentalmente, yo har√© todo desde Fedora, por que es mi sistema instalado, pero sientete libre de utilizar lo que m√°s te acomode, eso si, si tienes alg√∫n problema con tu sistema no podre ayudarte puesto que yo no lo uso (windows). Lo mismo va para la tarjeta Arduino que utilices, funciona cualquiera, pero los registros de cada microcontrolador varian mucho, sobre todo de una arquitectura a otra, los microcontroladores de 8 bits no tiene nada que ver con los micros de 32 o 16 bits.\nNo es de mi inter√©s centrarme en Arduino, pero es la opci√≥n de aprendizaje m√°s adecuada y ser√≠a tonto no empezar con ella.\nLos lugares m√°s comunes para adquirir la tarjeta es ebay, amazon y mercadolibre, es tu elecci√≥n, tambi√©n requerimos algunos dispositivos como leds, resistencias, transistores, capacitores, etc, en el siguiente post daremos algunos detalles adicionales.\nFin #  Finalizamos esta serie de post iniciales con una lista de materiales recomendada, en ebay existen una gran variedad de paquetes donde se incluyen Arduinos, resistencias, capacitores, transistores y algunos sensores, basta con ir a ebay o mercadolibre y buscar kit Arduino, adquirir uno de ellos es un buen comienzo.\nIgualmente puedes adquirir kits de resistencias, capacitores y leds, adem√°s de jumpers, cables y un par de atmega328p DIP adicionales.\nCon esto podemos comenzar nuestro estudio, m√°s adelante requeriremos m√°s componentes, pero se mencionar√°n con forme se requieran.\n"}),a.add({id:30,href:'/eleckia/posts/about/',title:"About",section:"Posts",content:"This is an example of a page. Unlike posts, which are displayed on your blog‚Äôs front page in the order they‚Äôre published, pages are better suited for more timeless content that you want to be easily accessible, like your About or Contact information. Click the Edit link to make changes to this page or add another page.\n"})})()