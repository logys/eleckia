<!DOCTYPE html>
<html lang="es" dir="ltr">

<head>
  <meta name="generator" content="Hugo 0.69.0" />
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Cando pensamos en programar microcontroladores, lo que queremos es hacer que el mundo se mueva, controlar un motor, un relevador, una lampara, altavoz, etc. Para ello los microcontroladores cuentan con una serie de periféricos.
A grandes rasgos un periférico puede definirse como: una interfaz que permite al microcontrolador comunicarse con el exterior, en esta entrada describiremos los puertos de entrada/salida de propósito general; GPIOx.
Según la hoja de datos el atmega328p tiene hasta 23 pines programables, cada uno con la posibilidad de ser programado individualmente, Arduino tiene 20 pines disponibles, pues 2 están destinados al reloj y el otro está destinado al pin de reset.">
<meta name="theme-color" content="#FFFFFF"><meta property="og:title" content="Periféricos atmega328p.- Puertos de entrada/salida de propósito general (GPIO) I." />
<meta property="og:description" content="Cando pensamos en programar microcontroladores, lo que queremos es hacer que el mundo se mueva, controlar un motor, un relevador, una lampara, altavoz, etc. Para ello los microcontroladores cuentan con una serie de periféricos.
A grandes rasgos un periférico puede definirse como: una interfaz que permite al microcontrolador comunicarse con el exterior, en esta entrada describiremos los puertos de entrada/salida de propósito general; GPIOx.
Según la hoja de datos el atmega328p tiene hasta 23 pines programables, cada uno con la posibilidad de ser programado individualmente, Arduino tiene 20 pines disponibles, pues 2 están destinados al reloj y el otro está destinado al pin de reset." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://eleckia.000webhostapp.com/posts/perifericos-atmega328p-puertos-de-entrada-salida-de-proposito-general-gpio/" />
<meta property="article:published_time" content="2019-06-13T19:18:09+00:00" />
<meta property="article:modified_time" content="2019-06-13T19:18:09+00:00" />
<title>Periféricos atmega328p.- Puertos de entrada/salida de propósito general (GPIO) I. | Blog sobre sistemas embebidos</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/book.min.9d432ddc1e6b98c4ea86ac0f88739bd2947349827b013c2fcfac5046b457837b.css" integrity="sha256-nUMt3B5rmMTqhqwPiHOb0pRzSYJ7ATwvz6xQRrRXg3s=">
<script defer src="/es.search.min.33b11ce7245a761e379816ebbaf45ab671a7d8229468aee216ef941430a31be7.js" integrity="sha256-M7Ec5yRadh43mBbruvRatnGn2CKUaK7iFu&#43;UFDCjG&#43;c="></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a href="/"><span>Blog sobre sistemas embebidos</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Buscar" aria-label="Buscar" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>











  



  
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-6f6f484549ce2d8602f7989616e2f29f" class="toggle"  />
    <label for="section-6f6f484549ce2d8602f7989616e2f29f" class="flex justify-between">
      <a href="https://eleckia.000webhostapp.com/docs/workstation/" class="">Estación de trabajo.</a>
      <span>▾</span>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://eleckia.000webhostapp.com/docs/workstation/arduino-2/" class="">Arduino</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://eleckia.000webhostapp.com/docs/workstation/arduino-basico-iii/" class="">Arduino Básico III</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://eleckia.000webhostapp.com/docs/workstation/arduino-basico-ii-hola-mundo/" class="">Arduino Básico II.- Hola Mundo</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://eleckia.000webhostapp.com/docs/workstation/arduino-basico-i/" class="">Arduino Básico I.</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-c5a8f28f5516b1587793df786fc2352d" class="toggle"  />
    <label for="section-c5a8f28f5516b1587793df786fc2352d" class="flex justify-between">
      <a href="https://eleckia.000webhostapp.com/docs/avr/" class="">Programación Avr en C.</a>
      <span>▾</span>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://eleckia.000webhostapp.com/docs/avr/programando-avr-en-c-arreglos/" class="">Programando Avr en C. Arreglos.</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://eleckia.000webhostapp.com/docs/avr/programando-avr-en-c-apuntadores-punteros-pointers-ii-apuntadores-dobles/" class="">Programando Avr en C.- Apuntadores, punteros, pointers III. Apuntadores Dobles.</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://eleckia.000webhostapp.com/docs/avr/programando-avr-en-c-apuntadores-punteros-pointers-ii-apuntadores-a-funciones/" class="">Programando Avr en C.- Apuntadores, punteros, pointers II. Apuntadores a funciones.</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://eleckia.000webhostapp.com/docs/avr/programando-avr-en-c-apuntadores-punteros-pointers/" class="">Programando Avr en C.- Apuntadores, punteros, pointers I.</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://eleckia.000webhostapp.com/docs/avr/programando-avr-en-c-el-flujo-del-programa-if-else-if-else/" class="">Programando Avr en C.- El flujo del programa, if, else, if else.</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://eleckia.000webhostapp.com/docs/avr/programando-avr-en-c-constantes/" class="">Programando Avr en C.- Constantes</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://eleckia.000webhostapp.com/docs/avr/programando-avr-en-c-tipo-de-dato-booleano-operadores-booleanos-y-de-comparacion/" class="">Programando Avr en C.- Tipo de dato Booleano, operadores booleanos y de comparación.</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://eleckia.000webhostapp.com/docs/avr/programando-avr-en-c-funciones/" class="">Programando Avr en C.- Funciones</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://eleckia.000webhostapp.com/docs/avr/programando-avr-en-c-variables-y-tipos-caracteres/" class="">Programando Avr en C.- Variables y tipos, caracteres.</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://eleckia.000webhostapp.com/docs/avr/programando-avr-en-c-variables-y-tipos-enteros/" class="">Programando Avr en C.- Variables y tipos.- Enteros.</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://eleckia.000webhostapp.com/docs/avr/programando-avr-en-c-hola-mundo/" class="">Programando Avr en C.- Hola mundo</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>















</nav>




  <script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>Periféricos atmega328p.- Puertos de entrada/salida de propósito general (GPIO) I.</strong>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#configurar-un-pin-como-salida">Configurar un Pin como Salida.</a></li>
    <li><a href="#configurar-un-pin-como-entrada">Configurar un Pin como Entrada.</a></li>
    <li><a href="#establecer-el-estado-cuando-el-pin-es-una-salida">Establecer el estado cuando el pin es una salida.</a></li>
    <li><a href="#leer-el-estado-de-un-pin">Leer el estado de un pin.</a></li>
    <li><a href="#operadores-de-asignación">Operadores de asignación.</a></li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
<article class="markdown">
  <h1>
    <a href="/posts/perifericos-atmega328p-puertos-de-entrada-salida-de-proposito-general-gpio/">Periféricos atmega328p.- Puertos de entrada/salida de propósito general (GPIO) I.</a>
  </h1>
  
  <h5>June 13, 2019</h5>



  

  
  <div>
    
      <a href="/tags/avr/">avr</a>, 
      <a href="/tags/programaci%C3%B3n/">Programación</a>, 
      <a href="/tags/atmega328p/">atmega328p</a>, 
      <a href="/tags/gpio/">GPIO</a>
  </div>
  


  <p><p>Cando pensamos en programar microcontroladores, lo que queremos es hacer que el mundo se mueva, controlar un motor, un relevador, una lampara, altavoz, etc. Para ello los microcontroladores cuentan con una serie de periféricos.</p>
<p>A grandes rasgos un periférico puede definirse como: una interfaz que permite al microcontrolador comunicarse con el exterior, en esta entrada describiremos los puertos de entrada/salida de propósito general; GPIOx.</p>
<p>Según la hoja de datos el atmega328p tiene hasta 23 pines programables, cada uno con la posibilidad de ser programado individualmente, Arduino tiene 20 pines disponibles, pues 2 están destinados al reloj y el otro está destinado al pin de reset.</p>
<p>Estos pines están agrupados en puertos, en el atmega328 contamos con tres puertos disponibles, PORTB, PORTC, PORTD, cada uno de estos puertos cuenta con tres registros asociados, DDRx, PORTx, PINx, donde &ldquo;x&rdquo; es el puerto(B, C, D), estos nueve registros nos permiten configurar y acceder a los valores de cada uno de los pines pertenecientes al microcontrolador.</p>
<p>Los pines en el microntrolador tienen un nombre del tipo PXn, donde X es el puerto y n es él número de pin, el pin PB0 y el pin PD7, son el pin 0 y el pin 7 del puerto B y del puerto D respectivamente.</p>
<h2 id="configurar-un-pin-como-salida">Configurar un Pin como Salida.</h2>
<p>El acceso a los pines individuales no es posible directamente, el acceso esta limitado a operaciones que involucran 8 bits como mínimo, pues este es el tamaño del bus de datos y de los registros. Por lo tanto si requerimos leer el pin PB3, necesariamente debemos leer todo el puerto, desde PB0 hasta PB7(el atmega328p no tiene disponibles todos lo pines PBn).</p>
<p>Suponiendo que requerimos encender un led que esta conectado al puerto PB4, podemos hacer una asignación al registro <strong>DDRB</strong>(Direction Data Register) como la siguiente</p>
<pre><code>DDRB = (1&lt;&lt;PB4);
//En binario es igual a
DDRB = 0b00010000;
</code></pre><p>esto efectivamente coloca al pin 4 como salida, sin embargo coloca al resto de los pines como entrada, para resolver este problema haremos uso del operador binario <strong>or</strong>. El operador or compara <strong>bit a bit</strong> <strong>posición por posición</strong>, con la regla,</p>
<pre><code>0 or 0 = 0
1 or 0 = 1
0 or 1 = 1
1 or 1 = 1
</code></pre><p>por ejemplo, para los números binarios, 100 y 010, el resultado de hacer un or bit a bit es</p>
<pre><code>bit2 bit1 bit0
   1    0    0
        or
   0    1    0
--------------
   1    1    0  Resultado
</code></pre><p>asumiendo que el registro DDRB contiene el valor 0000 0111, es decir los 3 primeros bits están configurados como salidas, requerimos hacer que el bit correspondiente a PB4 sea 1, sin modificar el resto, para ello usamos la sintaxis,</p>
<pre><code>DDRB = DDRB | (1&lt;&lt;PB4);
</code></pre><p>el símbolo <strong>|</strong>, es el operador binario or, significa: opera con or binario DDRB con el resultado de la operación (1&laquo;PB4),</p>
<pre><code>DDRB = DDRB | (1&lt;&lt;PB4);
//Primero se realiza (1&lt;&lt;PB4), resulta
DDRB = 0b00000111 | 0b00010000;
//Ahora se hacer or, resulta
DDRB = 0b00010111;
//DDRB queda con el bit 5 en 1 y el resto sin modificar
</code></pre><h2 id="configurar-un-pin-como-entrada">Configurar un Pin como Entrada.</h2>
<p>Para poder hacer acciones más complejas requerimos que nuestro microcontrolador pueda &ldquo;sentir&rdquo; el mundo, los pines de nuestro microcontrolador pueden configurarse para que se pueda interpretar el estado establecido por un elemento externo(Como entradas). Para ello también se utiliza el registro DDRx, pero en esta ocasión el pin a ser configurado se establece como un cero.</p>
<p>El operador binario and <strong>&amp;</strong>, similar al operador or realiza la operación and bit a bit, con la siguiente regla,</p>
<pre><code>0 and 0 = 0
0 and 1 = 0
1 and 0 = 0
1 and 1 = 1
</code></pre><p>por ejemplo en los siguientes números binarios el resultado es,</p>
<pre><code>bit2 bit1 bit0
   1    0    0
       and
   0    1    0
-------------- 
   0    0    0
</code></pre><p>Otro operador (en este caso unario) importante es el complemento a uno <strong>~</strong>, cambia el valor de 1 a 0 y de 0 a 1, por ejemplo:</p>
<pre><code>~1010
//Da como resultado
0101
</code></pre><p>Asumiendo que el registro DDRC contiene el número 010 0011, requerimos configurar el pin PC0 como entrada, asignar DDRC = 0 no es aceptable(colocaría todos los pines como entrada), en su lugar usaremos el siguiente código</p>
<pre><code>DDRC = DDRC &amp; ~(1&lt;&lt;PC0);
//Primero se realiza (1&lt;&lt;PC), resulta
DDRC = DDRC &amp; ~0b00000001;
//Ahora se aplica el operador complemento, resulta
DDRC = DDRC &amp; 0b11111110;
//Operador And bit a bit,
DDRC = 0b00100011 &amp; 0b11111110;
//Resulta
DDRC = 0b00100010;
</code></pre><p>de esta forma logramos establecer el pin requerido sin afectar el resto.</p>
<h2 id="establecer-el-estado-cuando-el-pin-es-una-salida">Establecer el estado cuando el pin es una salida.</h2>
<p>Cuando un pin es configurado como salida, puede entregar potencia, poquita, pero suficiente para mover al mundo, para ello se requiere establecer el estado del pin, asumiendo que tenemos conectado un led al pin PB4 y que dicho pin esta configurado como salida en el registro DDRB, entonces podemos establecer el estado del pin en el registro <strong>PORTB</strong>, donde un cero es nivel bajo(0 V) y un uno es nivel alto (5 V).</p>
<pre><code>//Led encendido
PORTB = PORTB | (1&lt;&lt;PB4);
//Led apagado 
PORTB = PORTB &amp; ~(1&lt;&lt;PB4);
</code></pre><p>Por supuesto lo mismo aplica para los otros puertos. ¿Qué pasa cuando manipulamos los registros PORTx cuando DDRx es configurado como entrada?, la respuesta es que con un uno se conecta una resistencia interna llamada de Pull Up, con un cero se desconecta dicha resistencia, la resistencia de pull up es de gran utilidad cuando se censan entradas, cuando hagamos una entrada sobre switches o push buttons, daré más detalles.</p>
<h2 id="leer-el-estado-de-un-pin">Leer el estado de un pin.</h2>
<p>Cuando requerimos leer el estado del pin, utilizamos el registro PINx, es un registro de 8 bits, contiene el estado de cada unos de los pines del puerto,</p>
<p>Para censar al pin, debemos configurarlo como entrada en el registro DDRx. Para leer el estado del pin PC0, asumiendo que PC0 esta conectado a 5V y que PC0 esta configurado como entrada en DDRC (con un cero),</p>
<pre><code>//suponiendo que declaramos una variable adecuada llamada
//entrada
entrada = PINC &amp; (1&lt;&lt;PC0);
//Es igual a
entrada = 0bxxxxxxx1 &amp; 0b00000001;
//donde las x pueden ser 0 o 1
//resulta en
entrada = 0b00000001;
//entrada es exactamente igual a
entrada = 1;
//si PC0 estuvera conectado a tierra, 
//entrada resultaría en
entrada =0b00000000;
//o
entrada = 0;
</code></pre><h2 id="operadores-de-asignación">Operadores de asignación.</h2>
<p>Para evitar verbosidad podemos usar operadores de asignación más complejos, por ahora presento dos adicionales, |= y &amp;=, su utilidad es obvia</p>
<pre><code>//en lugar de 
PORTx = PORTx | (1&lt;&lt;Pxn);
DDRx = DDRx &amp; ~(1&lt;&lt;Pxn);
//podemos usar
PORTx |= 1&lt;&lt;Pxn;
DDRx &amp;= ~(1&lt;&lt;Pxn);
//ambas expresiones producen resultados
//identicos
</code></pre></p>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>

 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#configurar-un-pin-como-salida">Configurar un Pin como Salida.</a></li>
    <li><a href="#configurar-un-pin-como-entrada">Configurar un Pin como Entrada.</a></li>
    <li><a href="#establecer-el-estado-cuando-el-pin-es-una-salida">Establecer el estado cuando el pin es una salida.</a></li>
    <li><a href="#leer-el-estado-de-un-pin">Leer el estado de un pin.</a></li>
    <li><a href="#operadores-de-asignación">Operadores de asignación.</a></li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>

</html>












