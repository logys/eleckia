'use strict';(function(){const b={cache:!0};b.doc={id:'id',field:['title','content'],store:['title','href','section']};const a=FlexSearch.create('balance',b);window.bookSearchIndex=a,a.add({id:0,href:'/eleckia/docs/workstation/',title:"Estaci贸n de trabajo",section:"Docs",content:"Hay que trabajar, hay que aprender, hay que comer, hay que descansar y tambi茅n hay que jugar, esas son las bases del entrenamiento del maestro Roshi para tener una buena condici贸n.\n-Kame Sennin.\n"}),a.add({id:1,href:'/eleckia/docs/avr/',title:"Programaci贸n Avr en C.",section:"Docs",content:"Una l铆nea de Othello sobre un bebedor, ahora un hombre sensible; por el alcohol se convierte en bestia, eso lo explica todo.\nBarney G贸mez.\n"}),a.add({id:2,href:'/eleckia/docs/perifericos/gpio/gpiolib/',title:"Api gpio",section:"GPIO",content:"Api gpio #  Para agilizar el desarrollo y desacoplar los m贸dulos de alto nivel de los detalles del hardware, es buena idea desarrollar una api/driver para cada perif茅rico a utilizar, d谩ndonos la oportunidad de reutilizar el c贸digo desarrollado en otros proyectos.\nEn esta entrada desarrollaremos un m贸dulo que nos permita crear acceder a los pines en el atmega328p de una manera simple.\nRequerimientos #  Los gpio\u0026rsquo;s son los perif茅ricos m谩s utilizados en cualquier desarrollo de software embebido, es necesario desarrollar una api para los mismos.\nImplementaci贸n #  Cuando hablamos de gpios, lo que nos interesa es hacer una de las siguientes operaciones:\n Establecer la direcci贸n del pin (entrada/salida). Establecer el nivel del pin (alto/bajo). Obtener el estado del pin(alto/bajo)  Es natural iniciar especificando estas tres operaciones en forma de funciones:\nvoid gpio_setPinDirection(Pin * pin, PIN_DIR direction) { } void gpio_setPinLevel(Pin * pin, PIN_LEVEL level) { } PIN_LEVEL gpio_pinLevel(Pin * pin) { } Comencemos por establecer la direcci贸n, Pin es una estructura que contiene toda la informaci贸n relevante sobre el pin, (numero, ddrx, portx, pinx):\nvoid gpio_setPinDirection(Pin * pin, PIN_DIR direction) { if(direction == INPUT) *pin-\u0026gt;ddrx \u0026amp;= ~(1\u0026lt;\u0026lt;pin-\u0026gt;number); else if(direction == OUTPUT) *pin-\u0026gt;ddrx |= 1\u0026lt;\u0026lt;pin-\u0026gt;number; } muy simple, tan solo revisamos la direcci贸n y asignamos usando el operador de indirecci贸n, el nivel se implementa de manera pr谩cticamente id茅ntica.\nvoid gpio_setPinLevel(Pin * pin, PIN_LEVEL level) { if(level == LOW) *pin-\u0026gt;portx \u0026amp;= ~(1\u0026lt;\u0026lt;pin-\u0026gt;number); else if(level == HIGH) *pin-\u0026gt;portx |= 1\u0026lt;\u0026lt;pin-\u0026gt;number; } Finalmente se requiere obtener el nivel del pin, el razonamiento es el mismo:\nPIN_LEVEL gpio_pinLevel(Pin * pin) { if (*pin-\u0026gt;pinx \u0026amp; (1\u0026lt;\u0026lt;pin-\u0026gt;number)) return HIGH; else return LOW; } Todo muy simple, pero necesitamos una funci贸n que cree los pines y les asigne sus valores, la interfaz del m贸dulo es la siguiente:\n#ifndef GPIO_H #define GPIO_H  #include \u0026lt;stdint.h\u0026gt; typedef enum {INPUT=0, OUTPUT} PIN_DIR; typedef enum {LOW=0, HIGH} PIN_LEVEL; typedef struct Pin{ uint8_t number; volatile uint8_t *ddrx; volatile uint8_t *portx; volatile uint8_t *pinx; }Pin; Pin gpio_create(uint8_t pin_number, PIN_DIR direction, PIN_LEVEL level); void gpio_setPinDirection(Pin * pin, PIN_DIR direction); void gpio_setPinLevel(Pin * pin, PIN_LEVEL level); PIN_LEVEL gpio_pinLevel(Pin * pin); #endif// GPIO_H La complejidad de este m贸dulo se centra en la funci贸n gpio_create, el usuario debe indicar el n煤mero de pin, el atmega328p en paquete DIP tiene un total de 28 pines, de los cuales la gran mayor铆a pertenecen a los puertos gpio, sin embargo no hay ninguna forma de establecer una relaci贸n entre el n煤mero de pin f铆sico y el puerto al que pertenece, es decir si yo indico el pin 4, no existe una funci贸n registro o ente que me indique que tal pin f铆sico pertenece al gpio PD2 del puerto D.\nPara establecer una relaci贸n se propone crear una tabla (lookup table), con un arreglo.\nenum {portB, portC, portD}; const int8_t gpio_table[][2] = { {-1, -1}, //pin 1 	{portD, PD0}, {portD, PD1}, {portD, PD2}, {portD, PD3}, {portD, PD4}, {-1, -1}, //Vcc 	{-1, -1}, //Gnd 	{portB, PB6}, {portB, PB7}, {portD, PD5}, {portD, PD6}, {portD, PD7}, {portB, PB0}, //pin 14 	{portB, PB1}, {portB, PB2}, {portB, PB3}, {portB, PB4}, {portB, PB5}, {-1, -1}, //AVcc 	{-1, -1}, //ARef 	{-1, -1}, //Gnd 	{portC, PC0}, {portC, PC1}, {portC, PC2}, {portC, PC3}, {portC, PC4}, {portC, PC5}, //pin 28 }; De esta forma es posible consultar que puerto y que pin gpio corresponde a cada pin f铆sico del microcontrolador:\n//por ejemplo uint8_t gpio_port = gpio_table[pin][0]; uint8_t gpio_pin = gpio_table[pin][1]; Regresando a la funci贸n gpio_create, antes de establecer la direcci贸n y nivel del pin, se requiere rellenar la estructura, se inicia con:\nPin gpio_create(uint8_t pin_number, PIN_DIR direction, PIN_LEVEL level) { uint8_t gpio_port = gpio_table[pin_number][0]; uint8_t gpio_pin = gpio_table[pin_number][1]; Pin pin = {.number = gpio_pin }; } Sin embargo aunque sabemos el puerto, no sabemos los registros, nuevamente se hacer uso de lookup tables,\nvolatile uint8_t * const port_table[] = { \u0026amp;PORTB, \u0026amp;PORTC, \u0026amp;PORTD }; volatile uint8_t * const ddr_table[] = { \u0026amp;DDRB, \u0026amp;DDRC, \u0026amp;DDRD }; volatile uint8_t * const pin_table[] = { \u0026amp;PINB, \u0026amp;PINC, \u0026amp;PIND }; Entonces ahora si podemos registrar la informaci贸n.\nPin gpio_create(uint8_t pin_number, PIN_DIR direction, PIN_LEVEL level) { uint8_t gpio_port = gpio_table[pin_number][0]; volatile uint8_t * ddrx = ddr_table[gpio_port]; volatile uint8_t * portx = port_table[gpio_port]; volatile uint8_t * pinx = pin_table[gpio_port]; uint8_t gpio_pin = gpio_table[pin_number][1]; Pin pin = {.number = gpio_pin, .ddrx = ddrx, .portx = portx, .pinx = pinx }; } Finalmente establecemos la direcci贸n, su nivel y retornamos el pin creado:\nPin gpio_create(uint8_t pin_number, PIN_DIR direction, PIN_LEVEL level) { uint8_t gpio_port = gpio_table[pin_number][0]; volatile uint8_t * ddrx = ddr_table[gpio_port]; volatile uint8_t * portx = port_table[gpio_port]; volatile uint8_t * pinx = pin_table[gpio_port]; uint8_t gpio_pin = gpio_table[pin_number][1]; Pin pin = {.number = gpio_pin, .ddrx = ddrx, .portx = portx, .pinx = pinx }; gpio_setPinDirection(\u0026amp;pin, direction); gpio_setPinLevel(\u0026amp;pin, level); return pin; } Protecci贸n #  La interfaz es p煤blica, un usuario puede tener la mala fortuna de crear un pin con un n煤mero incorrecto, para evitar esto existen varias aproximaciones, desde detener el microcontrolador hasta programar defensivamente cada uno de los posible casos de error, particularmente yo prefiero detener el programa cuando de funciones create o init se trata y revisar cada caso particular en las otras funciones.\nPara detener el programa si el usuario ha introducido un pin incorrecto se sugiere utilizar la biblioteca assert.h, el funcionamiento es simple:\nassert(true); //continua la ejecuci贸n assert(false); //detiene la ejecuci贸n Gracias a la lookup table de pines es f谩cil identificar si un pin es incorrecto, por ejemplo el pin 7 pertenece a la alimentaci贸n y no puede ser usado como gpio, al obtener el puerto de la tabla, obtenemos un -1, por lo tanto si hacemos un assert del puerto podemos verificar la viabilidad del pin.\nPin gpio_create(uint8_t pin_number, PIN_DIR direction, PIN_LEVEL level) { uint8_t gpio_port = gpio_table[pin_number][0]; assert(gpio_port != -1); //驴pin valido? 	volatile uint8_t * ddrx = ddr_table[gpio_port]; volatile uint8_t * portx = port_table[gpio_port]; volatile uint8_t * pinx = pin_table[gpio_port]; uint8_t gpio_pin = gpio_table[pin_number][1]; Pin pin = {.number = gpio_pin, .ddrx = ddrx, .portx = portx, .pinx = pinx }; gpio_setPinDirection(\u0026amp;pin, direction); gpio_setPinLevel(\u0026amp;pin, level); return pin; } En otra entrada mejoraremos el assert para que sea m谩s ilustrativo, por ahora esto funciona, el resto de funciones est谩n protegidas por los if\u0026rsquo;s y no requieren mayor atenci贸n.\nMain #  Para probar nuestra flamante biblioteca, se propone el programa:\n#include \u0026#34;gpio.h\u0026#34;#define F_CPU 16000000UL #include \u0026lt;util/delay.h\u0026gt; int main(void) { Pin led = gpio_create(19, OUTPUT, LOW); while(1){ gpio_setPinLevel(\u0026amp;led, HIGH); _delay_ms(1000); gpio_setPinLevel(\u0026amp;led, LOW); _delay_ms(1000); } } Compilado y subido el led comienza a parpadear con un periodo de 2 segundos.\nOptimizar ram #  Observando el tama帽o del binario obtengo la siguiente informaci贸n:\n$ avr-size a.out --format=avr --mcu=atmega328p AVR Memory Usage ---------------- Device: atmega328p Program: 768 bytes (2.3% Full) (.text + .data + .bootloader) Data: 76 bytes (3.7% Full) (.data + .bss + .noinit) El m贸dulo utiliza una cantidad importante de memoria ram, las tablas son las responsables.\nEn la arquitectura avr existen entre otras, dos espacios de memoria importantes, la memoria de programa y la memoria ram, la memoria de programa se almacena en la memoria flash del microcontrolador y las variables se almacenan en la memoria ram (Data), con una capacidad de 32kB y 2kB respectivamente. La arquitectura dota de un bus diferente para cada una de estas memorias, pudi茅ndose acceder a una regi贸n de ambas al mismo tiempo, resultando en un mejor rendimiento, sin embargo tenemos mucha flash y poca ram, 驴ser谩 posible almacenar variables en flash?, la respuesta corta es si, sin embargo la ejecuci贸n normal del programa establece que la memoria flash es de solo lectura, volvi茅ndose un espacio inviable para las variables, pero siendo posible almacenar las constantes en flash.\nPara ello haremos uso de atributos, los atributos son modificadores que indicamos a las declaraciones, permiti茅ndoos modificar el comportamiento de las mismas, los atributos son altamente dependientes del entorno, compilador, arquitectura del microcontrolador, etc, por lo que a帽adirlos hace nula la portabilidad. Sin embargo estamos desarrollando un m贸dulo de un perif茅rico igualmente no es portable por naturaleza. Los atributos se asignan con __attribute__ sin embargo la biblioteca avr/pgmspace.h, nos ofrece un macro para facilitarnos el trabajo:\n#include \u0026lt;avr/pgmspace.h\u0026gt; const int8_t gpio_table[][2] PROGMEM = { Con esta simple modificaci贸n ahora el arreglo gpio_table se ha almacenado en memoria flash, realizando la medici贸n se obtiene:\nAVR Memory Usage ---------------- Device: atmega328p Program: 768 bytes (2.3% Full) (.text + .data + .bootloader) Data: 18 bytes (0.9% Full) (.data + .bss + .noinit) La memoria ram se ha reducido considerablemente.\nSin embargo el programa ha dejado de funcionar, pues la ejecuci贸n normal espera que el arreglo este en espacio de ram, hay que indicar que el arreglo est谩 en flash siempre que se requiere leer el arreglo. Para leer el arreglo basta con utilizar la funci贸n pgm_read_byte cuyo argumento es la direcci贸n del arreglo en ram:\nuint8_t gpio_port = pgm_read_byte(\u0026amp;gpio_table[pin_number][0]); uint8_t gpio_pin = pgm_read_byte(\u0026amp;gpio_table[pin_number][1]); Por supuesto lo mismo aplica para las otras tablas, sin embargo lo que guardan no son n煤meros si no apuntadores, avr/pgmspace.h tambi茅n tiene una funci贸n para ellos, pgm_read_ptr\nvolatile uint8_t * ddrx = pgm_read_ptr(\u0026amp;ddr_table[gpio_port]); volatile uint8_t * portx = pgm_read_ptr(\u0026amp;port_table[gpio_port]); volatile uint8_t * pinx = pgm_read_ptr(\u0026amp;pin_table[gpio_port]); nuevamente midamos el tama帽o del binario:\nAVR Memory Usage ---------------- Device: atmega328p Program: 748 bytes (2.3% Full) (.text + .data + .bootloader) Data: 0 bytes (0.0% Full) (.data + .bss + .noinit) Lo cual es impresionante e indica que no hemos programado nada, tan solo hicimos wiring y si compilamos optimizando com -Os, obtenemos:\nAVR Memory Usage ---------------- Device: atmega328p Program: 658 bytes (2.0% Full) (.text + .data + .bootloader) Data: 0 bytes (0.0% Full) (.data + .bss + .noinit) Me doy por satisfecho.\nPor supuesto lo anterior tiene desventajas y es un peque帽o incremento en la velocidad de acceso, lo que no es un problema pues las tablas solo se usan una vez cuando se crea un pin, as铆 hemos llegado a otro dogma de la programaci贸n:\nLa optimizaci贸n temprana es el origen de todos los males\nOptimizando Flash #  Aunque 658 bytes no son demasiados, existen microcontroladores que tiene una cantidad de flash muy reducida, el atmega8 tiene un total de 8kB de flash y 32 pines, una implementaci贸n como esta tomar铆a alrededor del 10% del total de flash, algo inaceptable.\nLa tabla de pines es costosa en tama帽o, una forma de arreglar esto 煤ltimo implica un cambio radical en el dise帽o. Se propone que sea el usuario quien indique el puerto y el pin gpio y olvidarnos por completo del pin f铆sico.\ntypedef enum {portB, portC, portD}PORTN; Pin gpio_create(PORTN port, uint8_t pin_gpio, PIN_DIR direction, PIN_LEVEL level); Ser铆a fant谩stico poder evaluar las tablas sin tener que guardarlas, pero 驴realmente requiero tener estas tablas?, no lo hab铆a pensado pero los registros ya est谩n ordenados en forma de arreglos, 驴para que los estoy guardando en otras tablas?, fuente :https://www.microchip.com/\nLos registros tiene una direcci贸n en memoria, basta con \u0026ldquo;apuntar\u0026rdquo; hacia esa direcci贸n para tener acceso al registro. La biblioteca avr/sfr_defs.h nos hace las cosas aun m谩s f谩ciles, nos provee de la funci贸n, _SFR_IO8, permiti茅ndonos acceder a cualquier 谩rea de memoria por medio de su direcci贸n, por ejemplo si requerimos acceder al registro DDRB y asignarle un valor:\n_SFR_IO8(0x04) = 1\u0026lt;\u0026lt;PB5; Aprovechando la forma en la que est谩n arreglados los registros en memoria podemos 煤nicamente guardar el indice y evitamos guardar los registros.\ntypedef enum {portB=0x03, portC=0x06, portD=0x09}PORTBASE; typedef struct Pin{ uint8_t gpio_pin; PORTBASE port_base; }Pin; Pin gpio_create(PORTBASE port, uint8_t gpio_pin, PIN_DIR direction, PIN_LEVEL level); Las funciones para establecer la direcci贸n y nivel deben ser cambiadas para manejar los cambios:\nvoid gpio_setPinDirection(Pin * pin, PIN_DIR direction) { if(direction == INPUT) _SFR_IO8(pin-\u0026gt;port_base+1) \u0026amp;= ~(1\u0026lt;\u0026lt;pin-\u0026gt;gpio_pin); else if(direction == OUTPUT) _SFR_IO8(pin-\u0026gt;port_base+1) |= 1\u0026lt;\u0026lt;pin-\u0026gt;gpio_pin; } void gpio_setPinLevel(Pin * pin, PIN_LEVEL level) { if(level == LOW) _SFR_IO8(pin-\u0026gt;port_base+2) \u0026amp;= ~(1\u0026lt;\u0026lt;pin-\u0026gt;gpio_pin); else if(level == HIGH) _SFR_IO8(pin-\u0026gt;port_base+2) |= 1\u0026lt;\u0026lt;pin-\u0026gt;gpio_pin; } Finalmente actualizamos la funci贸n para crear un pin:\nPin gpio_create(PORTBASE port, uint8_t pin_gpio, PIN_DIR direction, PIN_LEVEL level) { assert(port == portB || port == portC || port == portD); assert(pin_gpio \u0026lt; 8); Pin pin = {.gpio_pin = pin_gpio, .port_base = port }; gpio_setPinDirection(\u0026amp;pin, direction); gpio_setPinLevel(\u0026amp;pin, level); return pin; } Compilando, obtengo los siguientes resultados:\nAVR Memory Usage ---------------- Device: atmega328p Program: 506 bytes (1.5% Full) (.text + .data + .bootloader) Data: 0 bytes (0.0% Full) (.data + .bss + .noinit) Comentarios finales #  La intensi贸n de desarrollar esta biblioteca tiene varios objetivos en principio es aprender y en segundo lugar se debe a el principio de inversi贸n de dependencias, el cual indica que los m贸dulos de alto nivel no deben depender de los m贸dulos de bajo nivel, con esta biblioteca he logrado desacoplar el concepto de gpio de los registros, permiti茅ndome \u0026ldquo;inyectar\u0026rdquo; instancias de pines en m贸dulos de alto nivel, de tal forma que los m贸dulos que alto nivel no conocen nada de los pines, ni su registro, ni su n煤mero, ni su locaci贸n, lo 煤nico que conocen es que se pueden configurar como entrada/salida y que se pueden encender/apagar, esto tiene la gran, gran, grandiosa ventaja de que los m贸dulos de alto nivel se vuelven independientes de la plataforma, arquitectura, hardware, etc, pudiendo ser ejecutados en avr, cortex-m, linux, windows, tostadoras, licuadoras, lavadoras, etc.\ngpio\navr/pgmspace.h\navr/sfr_defs.h\n"}),a.add({id:3,href:'/eleckia/docs/avr/registros/',title:"Registros",section:"Programaci贸n Avr en C.",content:"Registros y Acceso #  Registros #  驴Qu茅 son los registros?, un registro es un espacio en memoria que guarda informaci贸n, tan simple como eso. En el mundo de los microcontroladores un registro guarda la informaci贸n que define el comportamiento del microcontrolador.\nCada perif茅rico cuenta con varios registros, listos para ser modificados y le铆dos para adaptarlos a la soluci贸n de un problema en particular.\nEn la arquitectura avr de 8 bits, los registros son de 8 bits, algunos registros se presentan como de 16 bits, pero en realidad son 2 registros de 8 bits, el tama帽o lo indica el bus de datos que en avr es de 8 bits, en otras arquitecturas donde el bus es m谩s grande los registros son de otros tama帽os.\nLa programaci贸n de sistemas embebidos mucho tiene que ver con modificar registros, esta es la principal diferencia aunque no la 煤nica con respecto a programa en software de alto nivel.\nAcceso #  Entendido lo que es un registro, veamos como modificarlo.\nYa hemos utilizado registros, por ejemplo DDRB, data direction register del puerto B, establece a los pines como entrada o salida:\n//Establece el pin 5 del puerto B como salida y el resto como entradas DDRB = 0b00100000; sin embargo la sintaxis 0bxxxx no es est谩ndar, 煤nicamente esta disponible via avr-libc, que es la biblioteca principal utilizada por avr-gcc, lo que implica que nuestro c贸digo no sea portable si usamos esta sintaxis.\nOtra forma de abordar la asignaci贸n es por medio de la notaci贸n hexadecimal,\n//0b0010 0000; // 2 0	DDRB = 0x20; El n煤mero binario se divide en dos cuartetos y cada uno representa un n煤mero en hexadecimal, esto es cierto debido a las propiedades de las bases binarias y hexadecimal, es una forma estandarizada de asignaci贸n y es ampliamente utilizada, operaciones con datos de 8 bits son f谩ciles pero cuando los registros son de 32 bits por ejemplo, las conversiones son m谩s complicadas y se suelen cometer errores, existe otra forma de abordar el problema\nbitwise Corrimiento a la izquierda #  El operador \u0026laquo; corrimiento a la izquierda es un gran aliado para resolver este problema:\n//0b0010 0000; DDRB = 1\u0026lt;\u0026lt;5; Recorre el n煤mero a la izquierda del operador el n煤mero de veces indicado a la derecha del operador, en este caso recorre el n煤mero 1, 5 veces a la izquierda, el corrimiento se hace en la forma binaria del n煤mero a la izquierda:\nDDRB = 3\u0026lt;\u0026lt;1; //Daria como resultado 0b110 (6 en decimal) no 30 en decimal  DDRB = 1\u0026lt;\u0026lt;PB5; //Lo que nos intersa es que el 1 quede en la posici贸n PB5 Sin embargo el problema de modificar el resto de pines del registro persiste, veamos la soluci贸n a este problema.\nEstablecer un bit #  El operado binario or | es perfecto para solucionar el problema, el operador |, opera en dos n煤meros binarios con la regla:\n0 or 0 = 0 1 or 0 = 1 0 or 1 = 1 1 or 1 = 1 Por ejemplo, para los n煤meros binarios, 100 y 010, el resultado de hacer un or bit a bit es\nbit2 bit1 bit0 1 0 0 or or or 0 1 0 -------------- 1 1 0 Resultado Asumiendo que el registro DDRB contiene el valor 0000 0111, es decir los 3 primeros bits est谩n configurados como salidas, requerimos hacer que el bit correspondiente a PB5 sea 1, sin modificar el resto, para ello usamos la sintaxis,\nDDRB = DDRB | (1\u0026lt;\u0026lt;PB5); //Es igual a DDRB = 0b00000111 | 0b00100000; //despues de hacer or, resulta DDRB = 0b00100111; //DDRB queda con el bit PB5 en 1 y el resto sin modificar Una notaci贸n m谩s compacta y equivalente es:\nDDRB |= 1\u0026lt;\u0026lt;PB5; Tambi茅n es posible encadenar varios pines:\nDDRB |= 1\u0026lt;\u0026lt;PB5 | 1\u0026lt;\u0026lt;PB0 | 1\u0026lt;\u0026lt;PB3; Limpiar un bit #  Con limpiar un bit me refiero a ponerlo en cero, para ello el operador binario and \u0026amp; es el indicado, el operado \u0026amp; opera con dos n煤meros binarios con la regla:\n0 and 0 = 0 0 and 1 = 0 1 and 0 = 0 1 and 1 = 1 Por ejemplo en los siguientes n煤meros binarios el resultado es,\nbit2 bit1 bit0 1 0 0 and 0 1 0 -------------- 0 0 0 Resultado Otro operador (en este caso unario) importante es el complemento a uno ~, cambia el valor de 1 a 0 y de 0 a 1, por ejemplo:\n1010 ~ ----- 0101 Resultado Asumiendo que el registro DDRC contiene el n煤mero 0b0010 0011, requerimos configurar el pin PC0 como entrada, asignar DDRC = 0 no es aceptable (colocar铆a todos los pines como entrada), en su lugar usaremos el siguiente c贸digo\nDDRC = DDRC \u0026amp; ~(1\u0026lt;\u0026lt;PC0); //Primero se realiza (1\u0026lt;\u0026lt;PC0), resulta DDRC = DDRC \u0026amp; ~0b00000001; //Ahora se aplica el operador complemento, resulta DDRC = DDRC \u0026amp; 0b11111110; //Operador And bit a bit, DDRC = 0b00100011 \u0026amp; 0b11111110; //Resulta DDRC = 0b00100010; De esta forma logramos establecer el pin requerido sin afectar el resto. Por supuesto tambi茅n se pueden limpiar varios pines:\nDDRC \u0026amp;= ~(1\u0026lt;\u0026lt;PC0 | 1\u0026lt;\u0026lt;PC1 | 1\u0026lt;\u0026lt;PC5); "}),a.add({id:4,href:'/eleckia/docs/avr/programando-avr-en-c-arreglos/',title:"Programando Avr en C. Arreglos.",section:"Programaci贸n Avr en C.",content:"Los arreglos o arrays son elementos que permiten hacer colecciones de datos del tipo indicado, su uso es amplio en pr谩cticamente todos los lenguajes de programaci贸n, en C los arreglos se declaran con la siguiente sintaxis,\ntipo_dato nombre_array[TAMAO]; Por ejemplo para declarar un arreglo de 5 enteros llamado horas:\nint horas[5]; Para declarar un arreglo de 3 boleanos llamado respuestas:\n#include\u0026lt;stdbool.h\u0026gt; bool respuestas[3]; Los arreglos pueden ser de cualquier tipo de dato. El n煤mero entre corchetes (par茅ntesis cuadrados) indica la cantidad de elementos que puede almacenar, en el caso del arreglo horas, este puede almacenar hasta 5 enteros, la forma de asignar los valores es la siguiente:\nint horas[5] = {1, 2, 1, 2, 3}; //o tambi茅n int horas[5]; horas[0] = 1; horas[1] = 2; horas[2] = 1; horas[3] = 2; horas[4] = 3; Ambas asignaciones resultaran en los mismos enteros para el arreglo, n贸tese que cuando asignamos los valores, la primera posici贸n es cero y no uno, esto implica que la 煤ltima posici贸n sea cuatro y no cinco, si asign谩ramos horas[5] = 4; obtendr铆amos un error en tiempo de ejecuci贸n, este error es muy diferente de el error en tiempo de compilaci贸n, de hecho el programa compilara sin error, pero si se intenta ejecutar dentro del microcontrolador la ejecuci贸n sera err谩tica, probablemente el programa se reinicie al tratar de ejecutar la instrucci贸n o tal vez se detenga en ese instante, o tal vez no pase nada, depende de la forma en que se organiza la memoria en el micro, por lo tanto hay que tener cuidado en no rebasar el indice, el m谩ximo es igual a el tama帽o menos uno.\nArreglos y apuntadores. #  Los arreglos y apuntadores tienen una relaci贸n importante, el nombre de un arreglo es un apuntador que apunta a la direcci贸n del primer elemento o elemento cero,\nint numeros[2] = {1, 4}; int a = *numeros + numeros[1]; //a contendra el valor de 5 A pesar de esta equivalencia, prefiero utilizar los corchetes cuando de arreglos se trata, esto me evita la sobrecargar de conceptos en la cabeza y me permite diferenciar claramente el prop贸sito de un arreglo y el de un apuntador, con el arreglo quiero manejar una colecci贸n de datos, mientras que con los apuntadores quiero manejar el acceso a objetos individuales.\n"}),a.add({id:5,href:'/eleckia/posts/principio-de-responsabilidad-unica-srp/',title:"Principio de responsabilidad 煤nica (SRP)",section:"Posts",content:"En el desarrollo 谩gil, el principio de responsabilidad 煤nica es uno de los cinco principios fundamentales, el principio define lo siguiente:\nUn m贸dulo debe tener un solo motivo para cambiar.\nY eso es todo, 驴f谩cil no?, yo tambi茅n lo creo, 驴qu茅 es lo que creo?, no lo entiendo. Vamos por partes, las palabras son obvias, pero la frase es un poco ambigua, el meollo del asunto es claramente un solo motivo para cambiar, podemos apoyarnos en el nombre del principio, responsabilidad 煤nica, mmm parece ser que ambas frases se refieren a lo mismo, 驴a qu茅 mismo?, mmm, lo que esta claro es que un m贸dulo solo debe tener una sola responsabilidad, por ejemplo suponiendo que requerimos un sistema que controle el movimiento de un robot m贸vil, el robot puede ir hacia adelante, atr谩s y rotar las ruedas de direcci贸n, una forma de visualizarlo es la siguiente,\nSeparaci贸n obvia.\nSe sugiere una separaci贸n de responsabilidades, en lugar de que el m贸dulo robot_posici贸n administre el avance, retroceso y giro, separamos las responsabilidades y las asignamos a nuevos m贸dulos, esta separaci贸n es lo primero que se me vino a la mente, 驴pero esta separaci贸n es la m谩s adecuada?, las repuesta no es evidente ni definitiva, es aqu铆 donde recurrimos a la definici贸n un solo motivo para cambiar, los m贸dulos traslaci贸n y rotaci贸n cumplen con el principio srp, solo si al requerir una nueva caracter铆stica, solo uno de los dos m贸dulos necesita modificarse.\nSuponiendo que los requerimientos cambian y que se requiere que la velocidad a la que se mueve el robot hacia adelante y atr谩s sea controlable, es evidente que el m贸dulo traslaci贸n sera el 煤nico que cambie, por lo tanto la separaci贸n que se realizo es adecuada y cumple con el principio srp.\nAhora suponiendo que la especificaci贸n cambia, se desea que el robot tenga movimiento continuo, es decir que el robot avance hacia adelante o atr谩s mientras est谩 rotando. Ahora nuestros m贸dulos no cumplen con el principio, pues ambos deben ser modificados para alcanzar los nuevos requerimientos, este ser谩 un buen momento para replantear nuestra anterior separaci贸n en m贸dulos, una refactorizaci贸n nos da el siguiente modelo,\nDe esta manera velocidad solo se encarga de mover los motores avance y de retroceso, tren_de_giro se encarga de girar un motor de direcci贸n o el ajuste necesario dependiendo de la forma del robot.\nCon esto quiero decir que los m贸dulos deben agruparse de tal forma que las razones por las que cambian est茅n juntas, con esto logramos que al agregar nuevos cambios, solo debamos modificar el m铆nimo de m贸dulos.\n驴Y cuales son esas razones de cambio?, la respuesta es el cliente, el usuario, si el cliente del m贸dulo hace una nueva especificaci贸n que implique un cambio y para lograr la implementaci贸n se requieren modificar m谩s de un m贸dulo se debe replantear la forma y el tama帽o de los m贸dulos.\nRepito, el objetivo del SRP es proveer una forma de \u0026ldquo;modularizar\u0026rdquo; el programa en base a peticiones de cambios, aunque exista la tentaci贸n de agrupar m贸dulos por forma, color, sabor, etc, que pudieran parecer m谩s naturales, agrupar por motivos de cambios, nos dar谩 como resultado un software altamente 谩gil en el sentido de nuevas caracter铆sticas.\nEn el ejemplo anterior, 驴que sentido tendr铆a mezclar el c贸digo de control de posici贸n con el c贸digo de control visi贸n del robot?, si nosotros requerimos modificar el contraste o el brillo de la imagen, 驴ser铆a necesario modificar la velocidad del robot?, las respuesta obvia es que no, sin embargo piensa que las c谩maras aveces son muy lentas, quiz谩 requerimos tomar una imagen cuando el robot se acerque a un objeto, entonces si la c谩mara es lenta necesariamente requerimos bajar la velocidad, ni modo, es triste, pero debemos refactorizar los m贸dulos en har谩s de lograr el objetivo.\nEl SRP es el principio m谩s sencillo de describir, pero el m谩s dif铆cil de asimilar, requiere pr谩ctica, esfuerzo, experiencia y mucha meditaci贸n.\n"}),a.add({id:6,href:'/eleckia/posts/solid/',title:"SOLID",section:"Posts",content:"_Soy malo y eso es bueno, yo jam谩s ser茅 bueno y eso no es malo, no hay nadie que quiera ser adem谩s de mi. #  - Ralph el demoledor._\nSOLID #  Dentro del mundo de la programaci贸n existen los famosos paradigmas de programaci贸n, entre ellos: la programaci贸n funcional, la programaci贸n orientada a eventos, la programaci贸n estructurada, la programaci贸n orientada a objetos y otros m谩s. En esta fecha 2020, la programaci贸n orientada a objetos sin duda domina la forma en que se escribe el software en general, vale la pena aprender este paradigma pues no ser谩 raro encontrarnos con programas basados en 茅l.\nEl 茅xito de la programaci贸n orientada a objetos, se basa en la abstracci贸n de objetos, 驴qu茅 es la abstracci贸n de objetos?, personalmente la defino como una combinaci贸n entre imaginar, separar y simplificar, es decir tomamos un objeto real por ejemplo un motor, identificamos lo que nos interesa por ejemplo la velocidad y la direcci贸n de giro y descartamos el resto de detalles, el tipo de motor, la potencia, la tensi贸n de entrada, el par, marca, color, peso, etc, este motor que 煤nicamente gira a la velocidad y direcci贸n indicada, es una abstracci贸n de un motor real, esto que parece tan trivial tiene la cualidad de simplificar la forma en que se resuelven los problema, pues los humanos estamos adaptados a pensar en objetos abstractos.\nDentro de la programaci贸n orientada a objetos han surgido diferentes corrientes de desarrollo, en los 煤ltimos a帽os el desarrollo 谩gil gano una popularidad importante. En las catacumbas de un lugar de cuyo nombre no quiero acordarme, se reuni贸 un grupo de programadores con gran experiencia en el desarrollo de software, conspirando en contra de la t茅cnicas tradicionales escribieron el manifiesto 谩gil,\nhttps://agilemanifesto.org/iso/es/manifesto.html\nuna vez popularizado el desarrollo 谩gil comenzaron a desarrollarse numerosas metodolog铆as de trabajo, entre ellas: scrum, kaban, xp, tdd, etc, como mencione las personas funcionamos en base a abstracciones por lo que las metodolog铆as 谩giles pueden salir del mundo de la programaci贸n e implementarse en otros rubros de la humanidad.\nPersonalmente yo no me sent铆 seguro con mi c贸digo hasta que aprend铆 TDD (Test Driven Development), Desarrollo Guiado por Pruebas.\nAqu铆 tratare de describir los cinco principios fundamentales del desarrollo 谩gil, acu帽ados por Robert C. Martin, Agile Software Development, Principles, Patterns, and Practices. Es un excelente referencia para cualquiera que pretenda aprender a programar.\nSOLID es un acr贸nimo formador por los cinco principios del desarrollo 谩gil.\nS Single responsibility principle (Principio de responsabilidad 煤nica)\nO Open/closed principle (Principio Abierto/Cerrado)\nL Liskov substitution principle (Principio de sustituci贸n de Liskov)\nI Interface segregation principle (Principio de segregaci贸n de la interfaz)\nD Dependency inversion principle (Principio de inversi贸n de dependencia)\nSi cumplimos con estos principios dentro de nuestro c贸digo, entonces podemos decir que nuestro c贸digo es 谩gil\n Sigue mi blog #  Recibe nuevo contenido directamente en tu bandeja de entrada.\n[jetpack_subscription_form subscribe_placeholder=\u0026ldquo;Introduce tu direcci贸n de correo electr贸nico\u0026rdquo; show_subscribers_total=\u0026ldquo;false\u0026rdquo; button_on_newline=\u0026ldquo;false\u0026rdquo; submit_button_text=\u0026ldquo;Registrarse\u0026rdquo; custom_background_emailfield_color=\u0026ldquo;undefined\u0026rdquo; custom_background_button_color=\u0026ldquo;undefined\u0026rdquo; custom_text_button_color=\u0026ldquo;undefined\u0026rdquo; custom_font_size=\u0026ldquo;16\u0026rdquo; custom_border_radius=\u0026ldquo;0\u0026rdquo; custom_border_weight=\u0026ldquo;1\u0026rdquo; custom_border_color=\u0026ldquo;undefined\u0026rdquo; custom_padding=\u0026ldquo;15\u0026rdquo; custom_spacing=\u0026ldquo;10\u0026rdquo; submit_button_classes=\u0026quot;\u0026quot; email_field_classes=\u0026quot;\u0026quot; show_only_email_and_button=\u0026ldquo;true\u0026rdquo; ]\n"}),a.add({id:7,href:'/eleckia/posts/electronica/',title:"Electr贸nica",section:"Posts",content:"Ah, 驴pero que oigo?, una intromisi贸n, debe ser #  Lisa Simpson, la respuesta a una pregunta que\nnunca hizo nadie.\n-Ned Flanders\n Sigue mi blog #  Recibe nuevo contenido directamente en tu bandeja de entrada.\n[jetpack_subscription_form show_only_email_and_button=\u0026ldquo;true\u0026rdquo; custom_background_button_color=\u0026ldquo;undefined\u0026rdquo; custom_text_button_color=\u0026ldquo;undefined\u0026rdquo; submit_button_text=\u0026ldquo;Suscribir\u0026rdquo; submit_button_classes=\u0026ldquo;undefined\u0026rdquo; show_subscribers_total=\u0026ldquo;false\u0026rdquo; ]\n"}),a.add({id:8,href:'/eleckia/docs/avr/programando-avr-en-c-apuntadores-punteros-pointers-ii-apuntadores-dobles/',title:"Programando Avr en C.- Apuntadores, punteros, pointers III. Apuntadores Dobles.",section:"Programaci贸n Avr en C.",content:"Los apuntadores suenan bastante complejos, nuestro cerebro amplifica su complejidad, pero al igual que cualquier otra variable su funcionamiento es simple,\ntipo ** nombre_apuntador; a que me refiero con apuntador doble, a un apuntador que guarda direcciones de otros apuntadores de su mismo tipo,\nchar caracter1 = 'a'; char caracter2 = 'b'; char \\* letra = \u0026amp;caracter1; char \\*\\* apuntador\\_doble = \u0026amp;letra; \\*apuntador\\_doble = \u0026amp;caracter2; //ahora letra apunta a la direcci贸n de caracter2, //\\*letra es 'b' el prop贸sito evidente de los apuntadores dobles, es cambiar el valor a donde apuntan apuntadores simples,\nint \\* pointer1=NULL; int \\* pointer2=NULL; void updatePointers(int \\*\\* a, int \\*\\* b) { \\*a = direction\\_1; \\*b = direction\\_2; } //ahora los apuntadores apuntan a las //direcciones en direction\\_n Esta aplicaci贸n es muy sencilla, la usaremos con frecuencia.\n"}),a.add({id:9,href:'/eleckia/docs/avr/programando-avr-en-c-apuntadores-punteros-pointers-ii-apuntadores-a-funciones/',title:"Programando Avr en C.- Apuntadores, punteros, pointers II. Apuntadores a funciones.",section:"Programaci贸n Avr en C.",content:"Como ya he dicho un apuntador es una variable que apunta a direcciones de memoria, tambi茅n hemos mencionado que los apuntadores deben ser especificados sobre el tipo, cuando las funciones se compilan se les asigna una direcci贸n en memoria, 驴existir谩n apuntadores a funciones?, la respuesta es afirmativa, la sintaxis es un poco rara,\ntipo (*nombre_apuntador)(argumento1, argumento2, ..., argumento_n); al igual que los apuntadores comunes, los apuntadores a funciones deben ser especificados con el tipo de dato que regresan, entre parentesis se coloca el operador * seguido del nombre del apuntador, finalmente se especifican los par谩metros)\nint (\\*operacion)(int a, int b); int suma(int a, int b) { return a + b; } int resta(int a, int b) { return a - b; } int a = 5; int b = 10; if(condicion) operacion = suma; else operacion = resta; int c = operacion(a , b); /\\* S铆 condici贸n es verdadera c contendr谩 15 de \\* lo contrario c contendr谩 -5 \\*/ gracias a los apuntadores a funciones, tambi茅n es posible pasar funciones como argumentos de otras funciones,\nint operadorBinario(int (\\*operation)(int a, int b), int c, int d) { return operation(c,d); } int resultado = operadorBinario(suma, 5, 10); //resultado es igual a 15 resultado = operadorBinario(resta, 5, 10); //resultado = -5; Esta caracter铆stica nos ayudara a mejorar la calidad del c贸digo.\n"}),a.add({id:10,href:'/eleckia/docs/avr/programando-avr-en-c-apuntadores-punteros-pointers/',title:"Programando Avr en C.- Apuntadores, punteros, pointers I.",section:"Programaci贸n Avr en C.",content:"Los apuntadores (pienso que esta es la traducci贸n m谩s acertada), tambi茅n conocidos como punteros o pointers en ingles, es un tipo de dato caracter铆stico de lenguajes de bajo nivel y algunos de nivel medio, C por supuesto cuenta con tal tipo de dato.\nUn apuntador es una variable cuyo tipo de dato almacena direcciones de memoria, tan simple como eso. Aunque una direcci贸n de memoria puede ser interpretada como un entero, es mejor pensar que una direcci贸n de memoria es un tipo de dato diferente, un tipo de dato de tipo apuntador.\nLos apuntadores son temidos y exaltados, por buenas razones, el problema es que los apuntadores sirven para gran cantidad de aplicaciones y da la impresi贸n de que debes conocerlas todas, por supuesto no es as铆, se puede usar apuntadores de forma efectiva sin tener todo el bagaje t茅cnico alrededor, e ir aprendiendo gradualmente los pormenores. El secreto esta en auto limitarse y ser disciplinado.\nla sintaxis para declarar un apuntador es la siguiente\ntipo_a_donde_apunta * nombre_apuntador; un apuntador que apunta a una variable de tipo entero es diferente a un apuntador que apunta a una variable de tipo car谩cter,\nchar a; int b; int * apuntador1; // solo puede apuntar hacia b, apuntar hacia a implica un error Operador addressOff \u0026amp; #  Para almacenar la direcci贸n de una variable primero debemos obtener su direcci贸n, para ello contamos con el operador \u0026amp;,\nint b = 0; int * apuntador = \u0026amp;b; //apuntador ahora contiene la direcci贸n de memoria de b Operador de indirecci贸n * #  驴Para que se usa un apuntador?, como mencione las aplicaciones son amplias, pero la base es la misma, se trata de acceder al contenido guardado en una direcci贸n de memoria de manera indirecta. Una vez establecido un apuntador, usamos el operador de indirecci贸n para acceder al contenido a donde apunta.\nint b = 0; int * apuntador = \u0026amp;b; *apuntador = 10; //ahora b contiene el valor 10 y no 0. Una de las aplicaciones m谩s importantes es el paso de par谩metros a funciones, cuya intensi贸n sea modificar tales par谩metros, por ejemplo\nint a = 5; int b= 3; //Se pasan dos apuntadores intercambiar(\u0026amp;a, \u0026amp;b); //pasar \u0026amp;a, es equivalente a crear un apuntador //int *apuntador = \u0026amp;a y escribir intercambiar(apuntador, \u0026amp;b); //ahora a = 3 y b = 5; void intercambiar(int * v1, int * v2) { int tmp = *v1;//tmp = valor guardado en la //direcci贸n a donde apunta v1 *v1 = *v2; *v2 = tmp; } Usaremos ampliamente la forma de la funci贸n intercambiar, por ahora es suficiente con este conocimiento sobre apuntadores, por supuesto m谩s adelante veremos otras aplicaciones.\n"}),a.add({id:11,href:'/eleckia/posts/contacto/',title:"Contacto",section:"Posts",content:"Hablemos . No dudes en ponerte en contacto con nosotros mediante la informaci贸n de contacto a continuaci贸n, o env铆anos un mensaje mediante el formulario.\nPonte en contacto con nosotros #  Calle Ejemplo, 10\nCiudad, 10100\nEspa帽a\ncorreoelectronico@ejemplo.com\n(+34) 399 555 234\nEnv铆anos un mensaje #  "}),a.add({id:12,href:'/eleckia/posts/gpio-atmega328p/',title:"GPIO atmega328p.",section:"Posts",content:"_Si, se nos acabo la duela y pintamos la tierra, 驴qu茅 trucazo no? #  Moe Szyslak_\n Sigue mi blog #  Recibe nuevo contenido directamente en tu bandeja de entrada.\n[jetpack_subscription_form subscribe_placeholder=\u0026ldquo;Direcci贸n de correo electr贸nico\u0026rdquo; show_subscribers_total=\u0026ldquo;false\u0026rdquo; button_on_newline=\u0026ldquo;true\u0026rdquo; submit_button_text=\u0026ldquo;Suscribir\u0026rdquo; custom_background_emailfield_color=\u0026ldquo;undefined\u0026rdquo; custom_background_button_color=\u0026ldquo;undefined\u0026rdquo; custom_text_button_color=\u0026ldquo;undefined\u0026rdquo; custom_font_size=\u0026ldquo;16\u0026rdquo; custom_border_radius=\u0026ldquo;0\u0026rdquo; custom_border_weight=\u0026ldquo;1\u0026rdquo; custom_border_color=\u0026ldquo;undefined\u0026rdquo; custom_padding=\u0026ldquo;15\u0026rdquo; custom_spacing=\u0026ldquo;10\u0026rdquo; submit_button_classes=\u0026ldquo;has-text-color has-background-color has-background has-primary-background-color\u0026rdquo; email_field_classes=\u0026quot;\u0026quot; show_only_email_and_button=\u0026ldquo;true\u0026rdquo; ]\n"}),a.add({id:13,href:'/eleckia/docs/avr/programando-avr-en-c-el-flujo-del-programa-if-else-if-else/',title:"Programando Avr en C.- El flujo del programa, if, else, if else.",section:"Programaci贸n Avr en C.",content:"Definimos el flujo del programa como, la ruta que toma la ejecuci贸n del mismo, imaginemos que tenemos una lista de tareas que debemos ejecutar, digamos, tarea 1, tarea 2, tarea 3, \u0026hellip;, tarea n, ya vimos que podemos abstraer tareas como funciones, entonces simplemente podemos agregar cada una de las funciones en orden para ejecutarlas,\nint main(void) { tarea1(); tarea2(); tarea3(); tarean(); return 0; } pero que pasa si queremos ejecutar alguna de estas tareas solo si se cumple una condici贸n, digamos, solo si se pulsa un bot贸n determinado, o solo si el resultado de una operaci贸n satisface alg煤n requerimiento.\nPara ello contamos con la palabra if, si se cumple una condici贸n, el c贸digo dentro de sus llaves se ejecutara, de lo contrario el programa continuara despu茅s de la llave de cierre,\nint main(void) { tarea1(); if(condicion){ //si condici贸n es verdadera tarea2(); //se ejecutaran 茅sta dos tareas tarea3(); } tarea4(); //Aqu铆 continua tarean(); return 0; } tambi茅n es posible agregar la palabra else, para controlar el flujo cuando la condici贸n es falsa\nint main(void) { tarea1(); if(condicion){ //si condici贸n es verdadera tarea2(); //se ejecutara 茅sta tarea }else{ tarea3(); //si condici贸n es falsa, ejecuta 茅sta tarea } tarea4(); tarean(); return 0; } agregar m谩s sentencias nos permite un control aun m谩s preciso.\nint main(void) { tarea1(); if(condicion == 0){ //si condici贸n es igual a 0 tarea2(); //se ejecutara 茅sta tarea }else if(condicion == 1){ tarea3(); //si condici贸n igual a 1, ejecuta 茅sta tarea }else{ tarea4(); //si no se cumple ninguna de las anteriores } tarean(); return 0; } es importante se帽alar que la ejecuci贸n es en orden descendente, si tenemos varios if else y en m谩s de uno se cumple la condici贸n, solo se ejecutara el primero que la cumpla en orden descendente.\nint main(void) { tarea1(); if(true){ tarea2(); //se ejecutara 茅sta tarea }else if(true){ tarea3(); //No se ejecuta }else{ tarea4(); //No se ejecuta } tarean(); //una vez ejecutada tarea2, el programa continua aqu铆 return 0; } "}),a.add({id:14,href:'/eleckia/docs/avr/programando-avr-en-c-constantes/',title:"Programando Avr en C.- Constantes",section:"Programaci贸n Avr en C.",content:"Las constantes son de gran utilidad en la programaci贸n, a diferencia de las variables, las constantes no pueden cambiar su valor.\nLas dos formas m谩s comunes de definir constantes son con la palabra reservada const y con la directiva define.\nLa palabra const #  Agregando la palabra const a la declaraci贸n de una variable, esta se convierte en constate, sin embargo tambi茅n debe asignarle el valor al momento de la declaraci贸n;\nuint8_t const NUMERO = 10; //Declaraci贸n de una constante NUMERO = 1; //error, no se puede reasignar Sin embargo el uso m谩s cotidiano que tiene la palabra const es en los argumentos de funciones,\nint8_t suma(int8_t const sumando1, int8_t const sumando2); Directiva define #  Entre otras cosas, la directiva define puede ser usada para definir constantes;\n#define NUMERO 10 cuando el programa se compilar, la palabra NUMERO, se reemplaza por el n煤mero 10,\n#define PRIMERO 5 int8_t = 5 + PRIMERO; al compilar, sera reemplazado por\nint8_t = 5 + 5; Enum #  Los enum son un tipo de dato que nos facilit谩 la creaci贸n de colecciones de constantes, su sintaxis es\nenum NOMBRE{CONSTANTE1 = 0, CONSTANTE2, CONSTANTE3 = 5, CONSTANTE4}; de esta forma CONSTANTE1 es una variable de tipo enum NOMBRE y contiene el valor de 0, CONSTANTE2 contiene el valor 1 y CONSTANTE3 tiene el valor de 5 y CONSTANTE4 tiene el valor de 6.\nenum numeros{CERO, UNO, DOS}; a = CERO + UNO + DOS; //a contiene el n煤mero 3 驴Por qu茅 usar constantes? #  Hay dos conceptos al utilizar constantes, ser constante y querer ser constante.\nSer constante se refiere a declarar una constante expl铆citamente por ejemplo el n煤mero PI, SQRT2, etc.\nQuerer ser constante, se refiere a evitar que las variables cambien por accidente su valor, por ejemplo las funciones suele recibir par谩metros constantes, se busca evitar que los par谩metros cambien su valor, esto tomara sentido cuando comentemos los apuntadores en entradas posteriores.\nMuchos lenguajes de programaci贸n nuevos, definen a las variables como constantes (inmutable) y es el usuario quien expl铆citamente declara una variable como variable (mutable), la raz贸n principal como se menciona es reducir la posibilidad de a帽adir errores de programaci贸n.\n"}),a.add({id:15,href:'/eleckia/docs/avr/control_flujo/',title:"Control de flujo (if, while, for)",section:"Programaci贸n Avr en C.",content:"Control de flujo #  El control de flujo es el pilar de la programaci贸n estructurada, a pesar de que el paradigma de la programaci贸n estructurada pueda considerarse anticuada para algunos, lo cierto es que la soluci贸n de los algoritmos siempre requiere control de flujo; condicionales y repeticiones, antes de adentrarnos en el tema, revisemos el tipo de dato booleano.\nTipo de dato Booleano #  Otro tipo de datos b谩sico es el tipo booleano, aunque por raro que parezca en C, no exist铆a este tipo de dato originalmente, actualmente se requiere incluir la biblioteca;\n#include \u0026lt;stdbool.h\u0026gt;El tipo de dato bool puede contener 煤nicamente dos valores, verdadero(true) o falso(false), la sintaxis es:\n#include\u0026lt;stdbool.h\u0026gt;//Para declarar una variable bool un_nombre; //Para definir un valor un_nombre = true; un_nombre = false; Para asumir la carencia del tipo de dato bool, C que cualquier valor diferente de 0o NULL es verdadero, sin embargo es mejor utilizar expl铆citamente los valores true o false para denotar valores booleanos, por razones de legibilidad.\nOperadores booleanos #  Como el nombre sugiere, los operadores booleanos operan sobre tipos de dato booleanos y dan como resultado un booleano.\nEl operador and (\u0026amp;\u0026amp;) probablemente es el m谩s utilizado,\ntrue \u0026amp;\u0026amp; true //Resulta true true \u0026amp;\u0026amp; false //Resulta false false \u0026amp;\u0026amp; true //Resulta false false \u0026amp;\u0026amp; false //Resulta false El operador or (||)\ntrue || true //Resulta true true || false //Resulta true false || true //Resulta true false || false //Resulta false El operador de negaci贸n (!)\n!false //Resulta true !true //Resulta false Operadores de comparaci贸n #  Los operadores de comparaci贸n, comparan dos expresiones y eval煤an el resultado como falso o verdadero.\nIgualdad:\n10 == 10 //true \u0026#39;a\u0026#39; == \u0026#39;b\u0026#39; //false Diferencia:\n10 != 10 //false \u0026#39;a\u0026#39; != \u0026#39;b\u0026#39; //true Menor que:\n10 \u0026lt; 11 //true 10 \u0026lt; 10 //false Mayor que:\n10 \u0026gt; 11 //false 11 \u0026gt; 10 //true Menor o igual que:\n10 \u0026lt;= 11 //true 10 \u0026lt;= 10 //true Mayor o igual que:\n10 \u0026gt;= 11 //false 10 \u0026gt;= 10 //true Condicionales, if, else #  El termino control de flujo se deriva de los diagramas de flujo, una t茅cnica gr谩fica de dise帽o de programas estructurados, en ellos existe un bloque llamado if, el cual tiene la capacidad de decidir la siguiente acci贸n en base a una condici贸n, en C:\nbool condicional; if(condicional){ //Ejecuta este c贸digo si condicional es verdadero } el complemento de if es else:\nbool condicional; if(condicional){ //Ejecuta este c贸digo si condicional es verdadero }else{ //Ejecuta este c贸digo si condicional es falso } tambi茅n es posible hacer comparaciones intermedias:\nif(condicion1){ //Ejecuta este c贸digo si condicion1 es verdadera }else if(condicion2{ //Ejecuta este c贸digo si condicion1 es falso y si condicion2 es verdadera }else if(condicion3){ //Ejecuta este c贸digo si condicion1 y condicion2 son falsos y condicion3 	//es verdadera }else{ //Ejecuta este c贸digo si todas las condiciones son falsas } Debe resaltarse que la evaluaci贸n de las condiciones se detiene cuando se encuentra la primera condici贸n verdadera.\nCiclos, while, for #  La repetici贸n de acciones se logra de varias formas, pero lo m谩s com煤n es utilizar los ciclos while y for.\nWhile #  El ciclo while repite el c贸digo dentro de sus llaves mientras una condici贸n sea verdadera:\nbool condicion = true; while(condicion){ //Repite estas lineas de c贸digo 	//mientras condici贸n sea verdadera } Simple y f谩cil de entender, otra forma de hacer repeticiones es por medio del ciclo for.\nFor #  "}),a.add({id:16,href:'/eleckia/docs/avr/funciones/',title:"Funciones",section:"Programaci贸n Avr en C.",content:"Funciones en C #  Las funciones son caracter铆sticas fundamentales de cualquier lenguaje de programaci贸n, inclusive existe un paradigma de programaci贸n llamado programaci贸n funcional, veamos brevemente como funcionan las funciones en C. Una funci贸n tiene la siguiente sintaxis en C,\ntipo_de_retorno nombre_de_funcion(tipo_dato argumento_n) { ... hacer_tareas ... return un_objeto_del_tipo_de_retorno; } Las funciones son usadas como una forma de separar o estratificar tareas, pueden recibir \u0026ldquo;n\u0026rdquo; cantidad de argumentos y pueden retornar o no un valor, un ejemplo sencillo, definimos la funci贸n suma,\nint8_t suma(int8_t sumando1, int8_t sumando2) { int8_t resultado = sumando1 + sumando2; return resultado; } Es importante aclarar que el valor de retorno debe ser del mismo tipo que el tipo de retorno declarada en la funci贸n, en este caso un entero de 8 bits.\nEsta funci贸n simplemente suma los dos argumentos pasados en ella, definida la funci贸n es posible llamarla desde main o cualquier otra funci贸n:\nint main(void) { int8_t numero = suma(3,2); //ahora numero contiene 5 } Al ejecutarse, la variable numero contendr谩 el valor de 5.\nDeclaraci贸n vs Definici贸n #  Ahora que sabemos definir funciones sencillas, escribamos un programa donde se define la funci贸n:\n#include\u0026lt;stdint.h\u0026gt; //Para int8_t  int main(void) { int8_t numero = suma(2,3); return 0; } int8_t suma(int8_t sumando1, int8_t sumando2) { int8_t resultado = sumando1 + sumando2; return resultado; } Compilamos y nos dar谩 un error:\nprogram.c: In function int main(): program.c:5:25: error: suma was not declared in this scope int8_t numero = suma(2,3); El error indica que la funci贸n main no puede encontrar a la funci贸n sum, En C hay dos conceptos fundamentales que indican la existencia de un s铆mbolo:\n Declaraci贸n, Indica al compilador la existencia de un s铆mbolo, de tal forma que el compilador pueda seguir sin la necesidad de conocer los detalles del s铆mbolo.  int8_t funcion1(void); //Declaraci贸n de una funci贸n char letra; //Declaraci贸n de una variable char A las funciones declaradas se les suele llamar prototipos, la declaraci贸n de variables no recibe un nombre en particular,\n Definici贸n, Se indica al compilador en que espacio se encuentra y que tama帽o tiene.  letra = \u0026#39;b\u0026#39;;	//Definici贸n de una variable prefiamente declarada char vocal = \u0026#39;o\u0026#39;; //Declaraci贸n y definici贸n de una variable int8_t suma(void) //Definici贸n y Declaraci贸n de una funci贸n, {	//Si la funci贸n fue previamente declarada solo se define 	return 1 + 2; } En nuestro c贸digo la funci贸n suma se declara y define al final del fichero, 驴por qu茅 nos indica un error de declaraci贸n?, El compilador analiza el c贸digo linea por linea de arriba hacia abajo, cuando llega a la funci贸n main, aun no ha encontrado ning煤n s铆mbolo con el nombre suma, la soluci贸n es tan simple como escribir el prototipo una o varias l铆neas antes de la funci贸n main.\nint8_t suma(int8_t sumando1, int8_t sumando2); int main(void) { Con esto el compilador estar谩 feliz de hacer su trabajo, en otra etapa de compilaci贸n encontrara la definici贸n de la funci贸n y har谩 el trabajo necesario para asignar su direcci贸n de memoria y su tama帽o.\nEn las siguientes entradas entenderemos las ventajas que se obtiene de esta separaci贸n entre prototipo(declaraci贸n) y la definici贸n.\nPar谩metros y retorno #  Par谩metros #  Los par谩metros sirven para enviar datos a las funciones, aunque una interpretaci贸n m谩s 煤til es que las funciones operan sobre los datos, una funci贸n puede recibir cualquier cantidad de par谩metros, el limite es el tama帽o de memoria, sin embargo lo deseable es que las funciones reciban pocos o ning煤n par谩metros, algunos ejemplos:\nint8_t suma(float sumando1, float sumando2); int8_t factorial(int8_t numero); int8_t contador(char * palabra); //apuntador tipo char int8_t simbolo(char letra); int8_t mesActual(void); //el tipo void(vacio) indica que no hay par谩metros Retorno #  Las funciones pueden retornar uno o ning煤n par谩metro por medio de la palabra return, al igual que los par谩metros de entrada puede ser de cualquier tipo:\nint8_t suma(); char * palabras(); void encender(); //Sin retorno char ultimaLetra(); int * lista(); Llamada a funciones #  Las funciones pueden ser llamadas dentro de cualquier otra funci贸n, incluso existe una t茅cnica llamada recursividad donde una funci贸n se llama a si misma entrando en una especie de ciclo, aunque es una t茅cnica maravillosa es poco utilizada en sistemas embebidos, principalmente por:\n La raz贸n m谩s importante: es una t茅cnica altamente elegante que esta reservada para gente altamente sofisticada y de buen gusto. Otra raz贸n menos importante es que los microcontroladores carecen de la memoria suficiente para almacenar todas las variables de llamadas sucesivas a una funci贸n.  Para llamar a una funci贸n basta con indicar su nombre, pasar los argumentos y guardar el retorno si es necesario.\nvoid funcion1(void) { int numero = suma(3, 5); //Hacer tareas con numero } "}),a.add({id:17,href:'/eleckia/docs/bibliotecas/display7/',title:"Api Display Siete Segmentos",section:"Bibliotecas",content:"Api para un display de siete segmentos #  Escribamos una biblioteca/api sencilla que nos permita configurar un n煤mero en un display de 7 segmentos, el circuito es el siguiente,\nConexi贸n Arduino-Display #  Contamos con un display de c谩todo com煤n por lo tanto cada segmento se enciende con un voltaje alto en el pin correspondiente, es decir para encender el segmento \u0026ldquo;A\u0026rdquo; debemos configurar el pin digital D2 en alto. Evitamos la conexi贸n en los pines D0 y D1, debido a que estos est谩n conectados al convertidor serial-usb, y pueden provocar problemas para subir el c贸digo a la tarjeta.\nComo primer paso debemos incluir la biblioteca \u0026ldquo;avr/io.h\u0026rdquo;, para tener acceso a los puertos de GPIOx de entrada/salida, cuyos registros asociados son DDRx, PORTx, PINx.\n#include\u0026lt;avr/io.h\u0026gt;Ahora declaramos la funci贸n principal, recordemos que la funci贸n principal es llamada autom谩ticamente cuando el programa es ejecutado,\nint main(void) { return 0; } Dentro de las llaves del main configuramos los pines adecuados como salidas, para hacerlo requerimos saber a que pines del microcontrolador corresponden los pines del Arduino,\nfuente:(http://www.chicoree.fr/w/Arduino_sur_ATmega328P)\nEn la anterior imagen observamos la correspondencia entre los pines del Arduino y los del microcontrolador, por ejemplo el pin digital D2 es en realidad el pin PD2 del atmega328p, por ejemplo el pin digital D8 es en realidad el pin PB0 del atmega328p. Configuramos el registro DDRB y DDRD como salidas,\nDDRB |= 1\u0026lt;\u0026lt;PB0; DDRD |= 1\u0026lt;\u0026lt;PD2 | 1\u0026lt;\u0026lt;PD3 | 1\u0026lt;\u0026lt;PD4 | 1\u0026lt;\u0026lt;PD5 | 1\u0026lt;\u0026lt;PD6 | 1\u0026lt;\u0026lt;PD7; Ahora solo encendemos los leds, poniendo en alto los pines requeridos, por ejemplo para el n煤mero cinco, encendemos los segmentos a,c,d,f,g.\nPara ello escribimos a los puertos PORTB y PORTD los pines indicados\nPORTB |= 1\u0026lt;\u0026lt;PB0; PORTD |= 1\u0026lt;\u0026lt;PD2 | 1\u0026lt;\u0026lt;PD4 | 1\u0026lt;\u0026lt;PD5 | 1\u0026lt;\u0026lt;PD7; El c贸digo completo luce como el siguiente,\n#include\u0026lt;avr/io.h\u0026gt; int main(void) { DDRB |= 1\u0026lt;\u0026lt;PB0; DDRD |= 1\u0026lt;\u0026lt;PD2 | 1\u0026lt;\u0026lt;PD3 | 1\u0026lt;\u0026lt;PD4 | 1\u0026lt;\u0026lt;PD5 | 1\u0026lt;\u0026lt;PD6 | 1\u0026lt;\u0026lt;PD7; PORTB |= 1\u0026lt;\u0026lt;PB0 ; PORTD |= 1\u0026lt;\u0026lt;PD2 | 1\u0026lt;\u0026lt;PD4 | 1\u0026lt;\u0026lt;PD5 | 1\u0026lt;\u0026lt;PD7; return 0; } Compilamos y subimos.\nEl \u0026ldquo;estilo\u0026rdquo; en que hemos escrito nuestro programa es coloquialmente llamado hardcoding, debido a que nosotros especificamos tanto los valores como el flujo, usualmente lo que queremos es que el programa calcule los valores y elija el flujo, imaginemos que ahora requerimos una secuencia de n煤meros en serie, comenzado con 1 y terminando en 9 y repetir esta secuencia 1000 veces, seria un poco tedioso cambiar uno por uno los estados de los segmentos, para evitar este trabajo nos apoyaremos en funciones y sentencias de flujo.\nBiblioteca #  Nuestro anterior programa sirve para dos cosas, para nada y para la basura, no hay ninguna diferencia con respecto a conectar los pines del display directamente a Vcc, requerimos funcionalidad, que el microcontrolador haga lo adecuado para mostrar cualquier n煤mero indicado, con una interfaz del tipo\ndisplay7_showNumber(3); //Muestra el n煤mero 3 en el display De esta forma podemos realizar una secuencia de n煤meros\nint main(void) { while(1){ display7_showNumber(0); //delay  display7_showNumber(1); //delay  . . . display7_showNumber(9); //delay  } } El display mostrara los n煤meros del 0 al 9 en orden ascendente, nuestro objetivo entonces es definir la funci贸n display7_showNumber(short const number).\nAunque en este problema sencillo podemos programar la soluci贸n de forma monol铆tica(un solo fragmento de c贸digo), es de utilidad desarrollarlo en forma modular, como en la siguiente figura\nDe tal forma que podemos utilizarla dentro de nuestra aplicaci贸n con un simple include, pensar en forma modular tiene grandes ventajas y conforme crece el proyecto se vuelve la 煤nica forma sostenible de escribir c贸digo,\nPara nuestro prop贸sito un m贸dulo es un ente de software que aglutina las caracter铆sticas:\n Responsabilidad 煤nica, solo realiza una tarea. D茅bilmente acoplado, dos m贸dulos est谩n d茅bilmente acoplados si ambos desconocen los detalles de implementaci贸n del otro. Altamente cohesivo, un m贸dulo es altamente cohesivo si utiliza la totalidad de sus miembros, para realizar sus tareas.  La definici贸n de m贸dulo es un poco vol谩til, cada autor lo llama diferente, algunos indican que una clase es equivalente a un m贸dulo, algunos indican que un conjunto de clases es un m贸dulo, otros les llaman entidades, componentes o paquetes. Para este prop贸sito cuando digo m贸dulo me refiero al conjunto de un fichero .h con su o sus respectivos ficheros .c.\nUna bonita interfaz para nuestro modulo puede ser\nvoid display7_init(void); void display7_showNumber(int8_t number); Elegir buenos nombres es una parte fundamental para que nuestro c贸digo sea de alta calidad, estoy seguro que al leer las funciones anteriores de inmediato formaste una idea de lo que hacen y a que pertenecen.\nNi tardos ni perezosos comenzamos con la creaci贸n del m贸dulo, declaramos la interfaz del m贸dulo en un fichero display7.h:\n#ifndef DISPLAY7_H #define DISPLAY7_H  #include \u0026lt;stdint.h\u0026gt; void display7_init(void); void display7_showNumber(int8_t number); #endif// DISPLAY7_H Comenzar茅 con la funci贸n display7_showNumber, pues actualmente no tengo idea de que requiero inicializar en la otra funci贸n, r谩pidamente defino la funci贸n dentro de un fichero display7.c:\n#include \u0026#34;display7.h\u0026#34; void display7_showNumber(int8_t number) { } Enfoc谩ndonos en la funci贸n requerimos que number sea traducida a un formato donde los pines puedan ser establecidos, supongamos que siempre number = 1, bastar铆a con:\n#include\u0026lt;avr/io.h\u0026gt; void display7_showNumber(int8_t number) { PORTD |= 1\u0026lt;\u0026lt;PD3 | 1\u0026lt;\u0026lt;PD4; } Ahora consideremos el caso en que number puede ser uno o siete,\nvoid display7_showNumber(int8_t number) { if(number == 1) PORTD |= 1\u0026lt;\u0026lt;PD3 | 1\u0026lt;\u0026lt;PD4; else if(number == 7) PORTD |= 1\u0026lt;\u0026lt;PD3 | 1\u0026lt;\u0026lt;PD4 | 1\u0026lt;\u0026lt;PD2; } Parece la direcci贸n correcta, sin embargo, si primero se muestra siete, ya no ser谩 posible mostrar un uno, el problema habla y nos est谩 diciendo que requerimos implementar la funcionalidad de establecer los pines y de borrar los pines complementarios. Se proponen dos funciones adicionales:\nstatic void setPins(uint8_t pins); static void clearPins(uint8_t pins); void display7_showNumber(int8_t number) { if(number == 1){ setPins(1\u0026lt;\u0026lt;PD3 | 1\u0026lt;\u0026lt;PD4); clearPins(1\u0026lt;\u0026lt;PD3 | 1\u0026lt;\u0026lt;PD4); } else if(number == 7){ setPins(1\u0026lt;\u0026lt;PD3 | 1\u0026lt;\u0026lt;PD4 | 1\u0026lt;\u0026lt;PD2); clearPins(1\u0026lt;\u0026lt;PD3 | 1\u0026lt;\u0026lt;PD4 | 1\u0026lt;\u0026lt;PD2); } } static void setPins(uint8_t pins) { PORTD |= pins; } static void clearPins(uint8_t pins) { PORTD \u0026amp;= ~pins; } El c贸digo tiene dos problemas graves, el primero es que comienza a verse algo de repetici贸n, este es un dogma de la programaci贸n:\nLa repetici贸n de ideas, es el origen de todos los males.\nEl segundo es que no todos los pines est谩n en el puerto D, hay uno en el B.\nSolucionemos r谩pidamente el primer problema:\nvoid display7_showNumber(int8_t number) { uint8_t pins; if(number == 1) pins = 1\u0026lt;\u0026lt;PD3 | 1\u0026lt;\u0026lt;PD4; else if(number == 7) pins = 1\u0026lt;\u0026lt;PD3 | 1\u0026lt;\u0026lt;PD4 | 1\u0026lt;\u0026lt;PD2; setPins(pins); clearPins(pins); } Lo anterior tiene un nombre, se llama refactoring, algunos le dicen refactorizar pero evidentemente es una palabra que no existe, aunque tu deber铆as llamarle como te de la gana, el refactoring tiene sus reglas y directrices, es un t贸pico relativamente avanzado que tocaremos en otra entrada, para quien desee adelantarse, tiene disponible Martin Fowler:Refactoring.\nEl segundo problema no es tan sencillo de atacar, no hay forma de diferencia PB0 de PD0, ambos son un cero, para esta configuraci贸n de pines tenemos suerte, solo hay PB0 y podemos trabajar con una condicional sobre el, pero deber铆amos buscar una forma m谩s generalizada:\nstatic void setPins(uint8_t pins) { PORTD |= pins; if(pins \u0026amp; (1\u0026lt;\u0026lt;PB0)) PORTB |= 1\u0026lt;\u0026lt;PB0; } static void clearPins(uint8_t pins) { PORTD \u0026amp;= ~pins; if(pins \u0026amp; (1\u0026lt;\u0026lt;PB0)) PORTB \u0026amp;= ~(1\u0026lt;\u0026lt;PB0); } No me da buenas sensaciones pero funciona, m谩s adelante lo intentaremos de nuevo, por ahora agreguemos un caso m谩s, cuando number puede ser tambi茅n cuatro:\nvoid display7_showNumber(int8_t number) { uint8_t pins; if(number == 1) pins = 1\u0026lt;\u0026lt;PD3 | 1\u0026lt;\u0026lt;PD4; else if(number == 7) pins = 1\u0026lt;\u0026lt;PD3 | 1\u0026lt;\u0026lt;PD4 | 1\u0026lt;\u0026lt;PD2; else if(number == 4) pins = 1\u0026lt;\u0026lt;PD3 | 1\u0026lt;\u0026lt;PD4 | 1\u0026lt;\u0026lt;PB0 | 1\u0026lt;\u0026lt;PD7; setPins(pins); clearPins(pins); } Esos if\u0026rsquo;s se ven horribles y faltan m谩s, 驴habr谩 alguna forma de quitarlos?, actualmente representamos los segmentos como sigue:\n0b76543210 FEDCBA0G Si sabemos que a cada valor de number le corresponde una y solo una representaci贸n de segmentos, entonces 驴no podr铆amos guardar los \u0026ldquo;patrones\u0026rdquo; que le corresponde a cada valor de number?, por supuesto, a eso se le conoce como lookup table o tabla de consulta, hay muchas formas de implementarla pero la m谩s sencilla es por medio de un arreglo:\nconst uint8_t segments_table[] ={ 1\u0026lt;\u0026lt;PD2 | 1\u0026lt;\u0026lt;PD3 | 1\u0026lt;\u0026lt;PD4 | 1\u0026lt;\u0026lt;PD5 | 1\u0026lt;\u0026lt;PD6 | 1\u0026lt;\u0026lt;PD7, //0 	1\u0026lt;\u0026lt;PD3 | 1\u0026lt;\u0026lt;PD4, //1 	1\u0026lt;\u0026lt;PD2 | 1\u0026lt;\u0026lt;PD3 | 1\u0026lt;\u0026lt;PD5 | 1\u0026lt;\u0026lt;PD6 | 1\u0026lt;\u0026lt;PB0, //2 	1\u0026lt;\u0026lt;PD2 | 1\u0026lt;\u0026lt;PD3 | 1\u0026lt;\u0026lt;PD4 | 1\u0026lt;\u0026lt;PD5 | 1\u0026lt;\u0026lt;PB0, //3 	. . . }; void display7_showNumber(int8_t number) { uint8_t pins = segments_table[number]; setPins(pins); clearPins(pins); } Ahora si, se ve simple y claro. 驴Qu茅 pasar铆a si el usuario introduce un n煤mero m谩s grande que el tama帽o del arreglo?, claramente habr铆a un error, debemos protegernos de valores inadecuados:\nvoid display7_showNumber(int8_t number) { if(number \u0026lt; 0 || number \u0026gt; 9) return ; uint8_t pins = segments_table[number]; setPins(pins); clearPins(pins); } Si se introduce un n煤mero incorrecto, la funci贸n simplemente lo ignora.\nYa sabemos que lo 煤nico que requerimos inicializar, son los pines en la funci贸n display7_init\nvoid display7_init(void) { DDRD |= 1\u0026lt;\u0026lt;PD2 | 1\u0026lt;\u0026lt;PD3 | 1\u0026lt;\u0026lt;PD4 | 1\u0026lt;\u0026lt;PD5 | 1\u0026lt;\u0026lt;PD6 | 1\u0026lt;\u0026lt;PD7; DDRB |= 1\u0026lt;\u0026lt;PB0; } Solo nos queda incluir la biblioteca dentro del main:\n#include \u0026#34;display7.h\u0026#34;#define F_CPU 16000000UL #include \u0026lt;util/delay.h\u0026gt; int main(void) { display7_init(); int i = 0; while(1){ display7_showNumber(i); _delay_ms(1000); i++; if(i \u0026gt; 9) i = 0; } } Compilando el programa con:\n$ avr-gcc -mmcu=atmega328p -Wall -Os display7.c main.c Obtengo los siguientes resultados:\n$ avr-size --mcu=atmega328p --format=avr a.out AVR Memory Usage ---------------- Device: atmega328p Program: 260 bytes (0.8% Full) (.text + .data + .bootloader) Data: 8 bytes (0.4% Full) (.data + .bss + .noinit) Lo que es fant谩stico, pues no hemos utilizado ni el 1% de la memoria flash y una miserable cantidad de memoria ram.\nDesafortunadamente esa biblioteca es muy concreta, depende directamente de la asignaci贸n de pines indicada en el esquem谩tico, cualquier cambio en alguno de los pines deriva en cambiar tres funciones y la tabla.\nGeneralizando m谩s #  Las expectativas son altas, necesito que este c贸digo se ejecute con cualquier combinaci贸n de pines y que sea altamente portable, la anterior implementaci贸n no cubre los requerimientos, veamos otra posibilidad donde se usa la biblioteca gpio, desarrollada en la entrada perifericos-\u0026gt;Api gpio.\nAsumiendo que cada segmento es representado por un pin, procedemos a implementar la funci贸n display7_showNumber, es casi id茅ntica y tambi茅n reutilizamos la tabla,\nconst uint8_t segments_table[] = { //0b76543210 	// .GFEDCBA 	0x3F, //0 	0x06, //1 	0x5B, //2 	0x4f, //3 	0x66, //4 	0x6d, //5 	0x7d, //6 	0x07, //7 	0x7F, //8 	0x6f //9 }; static void setSegments(uint8_t segments); void display7_showNumber(int8_t number) { if(number \u0026lt; 0 || number \u0026gt; 9) return; uint8_t segments = segments_table[number]; setSegments(segments); } La novedad est谩 en setSegments, pues ya no hay acceso a los registros, en su lugar tenemos una lista de segmentos representados por pines, la idea es iterar sobre todos los segmentos desde A hasta G e ir revisando su estado, si el estado es cero el pin se apaga.\nstatic void setSegments(uint8_t segments) { for(int i = 0; i\u0026lt;TOTAL_PINS-1; i++){ if((segments \u0026amp;(1\u0026lt;\u0026lt;i)) == 0) gpio_setPinLevel(segments_pins_table[i], LOW); else gpio_setPinLevel(segments_pins_table[i], HIGH); } } segments_pins_table, ya no contiene el n煤mero de pin correspondiente a cada segmento, ahora es una tabla que contiene apuntadores a instancias Pin, por supuesto la funci贸n display7_init es la encargada de recibir los pines y guardarlos en la tabla:\n#define TOTAL_PINS 8  Pin * segments_pins_table[TOTAL_PINS]; void display7_init(Pin * A, Pin * B, Pin * C, Pin * D, Pin * E, Pin * F, Pin * G, Pin * dot) { segments_pins_table[0] = A; segments_pins_table[1] = B; segments_pins_table[2] = C; segments_pins_table[3] = D; segments_pins_table[4] = E; segments_pins_table[5] = F; segments_pins_table[6] = G; segments_pins_table[7] = dot; } Observe la simplicidad del c贸digo, esto es debido a la separaci贸n de responsabilidades entre el manejo de los segmentos y el manejo de los registros.\nComentarios finales #  Ahora contamos con dos m贸dulos que deber铆an verse de la siguiente forma:\n.  display7  include  display7.h  src  display7.c  gpio  include  gpio.h  src  gpio.c  main.c 6 directories, 5 files Comparando las dos versiones, es evidente que la segundo es mucho m谩s limpia, pero tom贸 mucho m谩s tiempo y se cometieron m谩s errores, adem谩s ocupa m谩s recursos y es m谩s lenta. 驴Vale la pena realizar la sobrecarga de trabajo?, la respuesta no es simple, pienso que vale la pena cuando no existe un m贸dulo que ya lo haga, si ya existe no pierdas el tiempo y 煤salo, si no existe y solo vas a realizar un proyecto con ese dispositivo, olv铆dalo no vale la pena \u0026ldquo;harcodea\u0026rdquo;, si no existe y vas a utilizar de forma regular esa caracter铆sticas, vale totalmente la pena, la verdad es muy bonito que cuando requieres comenzar un proyecto ya tengas tus bibliotecas de los perif茅ricos listas y no tengas que andar buscando registros y pines en el data sheet.\nm贸dulo display7\n"}),a.add({id:18,href:'/eleckia/posts/electronica-basica-display-de-7-segmentos/',title:"Electr贸nica b谩sica.- Display de 7 segmentos.",section:"Posts",content:"Un display de 7 segmentos es un arreglo de leds distribuidos de una manera determinada, 8 leds en total, el display de 7 segmentos tiene el prop贸sito de mostrar caracteres, usualmente n煤meros pero tambi茅n puede mostrar letras.\nDisplay 7 segmentos\nel circuito equivalente es muy sencillo,\nC谩todo com煤n\nesta configuraci贸n es llamada c谩todo com煤n, puesto que el c谩todo de todos los diodos est谩 en corto circuito, es una buena caracter铆stica pues tenemos un solo pin para todos los c谩todos y podemos usar un solo cable para la conexi贸n en lugar de ocho.\nnodo com煤n\nLa configuraci贸n de 谩nodo com煤n es similar a la de c谩todo com煤n salvo que los 谩nodos son los que est谩n conectados en corto.\nEl dispositivo cuenta con nueve terminales (aveces diez, dos dedicadas para el com煤n) una para el com煤n y el resto para los ocho leds, para el c谩todo com煤n; la terminal com煤n se conecta a tierra y los leds se encienden con voltaje alto, por el contrario para el 谩nodo com煤n; la terminal com煤n se conecta a Vcc y los leds se encienden con voltaje bajo.\nCada terminal es simplemente un led, por lo tanto para usarlo debemos agregar una resistencia para limitar la corriente, para nuestro atmega328p; resistencias para cada led de 330 $latex \\Omega$ o un poco mayores son suficientes. Cada led sera alimentado por 10[mA], si todos los leds se encienden al mismo tiempo, en total tenemos 80[mA], por lo que nuestro microcontrolador puede manejarlos sin problema, recordemos que la corriente m谩xima provista por el microcontrolador es de 200[mA] por todos los pines y 40[mA] en cada pin.\n"}),a.add({id:19,href:'/eleckia/posts/electronica-basica-led-y-su-resistencia/',title:"Electr贸nica b谩sica.- Led y su resistencia.",section:"Posts",content:"La ley de Ohm es una herramienta fundamental en la electr贸nica, en esta ocasi贸n vamos a calcular la resistencia adecuada para que un diodo pueda operar de forma segura.\nAntes que nada definamos que es un diodo, sin entrar en detalles, un diodo es un dispositivo que permite el flujo de corriente en una sola direcci贸n, cuenta con dos terminales, el 谩nodo y el c谩todo, la regla es que si se conecta un voltaje alto al 谩nodo y uno bajo al c谩todo, entonces fluye corriente, esta operaci贸n del diodo se conoce como polarizaci贸n directa, si se invierten las conexiones se dice que el diodo esta polarizado en inversa y no fluye corriente. Un circuito simple se muestra en la figura,\nCircuito con Diodo\nAhora reemplazamos el diodo por su circuito equivalente,\nDiodo en Directa\nLa resistencia \u0026ldquo;interna\u0026rdquo; del diodo es muy peque帽a por lo que podemos despreciarla, no debemos olvidar que este circuito es un modelo, el modelo funciona bien porque representa el comportamiento del diodo, no significa que dentro del diodo exista una resistencia y una fuente de voltaje, el valor de la fuente de voltaje varia de diodo a diodo, debemos verificar la hoja de datos para ver que voltaje tiene el diodo en cuesti贸n, en algunos casos el voltaje es peque帽o comparado con el resto de voltajes y simplemente se desprecia, modelandolo como un simple corto circuito.\nEn el caso de la polarizaci贸n inversa el circuito es aun m谩s simple\nDiodo en Inversa\nes un circuito abierto y no hay circulaci贸n de corriente.\nLed. #  Un led es un diodo que tiene la capacidad de emitir luz, el voltaje del diodo led es mayor que el voltaje de otro tipo de diodos, siendo el rojo el mas peque帽o alrededor de 1.8 [V] y el azul el m谩s grande alrededor de 4.8 [V], esto para leds de 5mm, sin embargo esto valores cambian seg煤n el tama帽o del led, lo mejor es revisar en la hoja de datos del diodo en cuesti贸n.\nUn led generalmente se acompa帽a de una resistencia conectada en serie, 驴para qu茅?, la respuesta es simple, para limitar su corriente, entendamos que es un corto circuito.\nPartiendo del circuito anterior, tenemos una fuente en serie con una resistencia, recordemos que la corriente es\n$latex i = \\frac{V}{R}$\nun corto se entiende como una conexi贸n el茅ctrica de cero resistencia entre dos terminales. De esta forma los puntos A y B en el esquema est谩n en corto, dicho de otra manera no hay resistencia entre ellos, esto implica que la corriente puede fluir totalmente entre estos dos puntos, Las terminales C y D no est谩n en corto pues hay una resistencia entre ellas, 驴que pasar铆a si quitamos la resistencia?, pues tendr铆amos a las terminales C y D en corto y las consecuencias serian desastrosas. de la ley de Ohm tenemos $latex i = \\frac{V}{0} = \\infty$, las fuentes no pueden otorgar energ铆a infinita, est谩n dise帽ada para dar una corriente especifica, si se sobrepasa el limite se da帽aran, es por eso que nunca debes juntar las terminales de una fuente.\nRegresando a nuestro diodo led, 驴qu茅 pasar铆a si no colocamos una resistencia entre el diodo y la fuente?,\nDiodo en corto\ncomo dijimos la resistencia del modelo del diodo es muy peque帽a por lo tanto la fuente y el diodo est谩n pr谩cticamente en corto, es decir fluir谩 una gran cantidad de corriente desde la fuente hacia el diodo, si se tiene suerte el diodo se quemara y se abrir谩 el circuito, si tienes un mal d铆a tu fuente se da帽ara tambi茅n, los diodos est谩n fabricados para trabajar a un cierta corriente, en el caso de los diodos peque帽os de 5mm la corriente suele estar alrededor de los 10[mA], en el caso de los diodos led de iluminaci贸n es com煤n encontrar corrientes de 300[mA]. Calculemos r谩pidamente la resistencia de un led de 5mm rojo de 1.8[V] y 10[mA], que se desea conectar a una fuente de 5[V]. El circuito es el siguiente.\nde la ley de Ohm\n$latex V = Ri$\ndividiendo ambos lados entre la corriente\n$latex \\frac{V}{i} = R \\frac{i}{i} = R$\npara la resistencia R\n$latex R = \\frac{V_R}{i}$\ny la aplicamos a la resistencia R, recordemos que la corriente es un flujo, por lo tanto la corriente que pasa por la resistencia es la misma que pasa por el led, sabemos que el voltaje en la terminal positiva de la resistencia es 5V y el voltaje en la terminal negativa de la resistencia es 1.8V (estamos despreciando la resistencia interna del diodo), por lo tanto el voltaje que hay entre las terminales de la resistencia R es\n$latex V_R = (5 - 1.8) [V] = 3.2[V]$\nsabemos que la corriente de operaci贸n del led es de 10[mA], por lo tanto la resistencia adecuada debe ser\n$latex R = \\frac{3.2[V]}{10[mA]} = \\frac{3.2[V]}{0.010[A]} = 320 \\Omega$\nla resistencia comercial m谩s cercana es de 330 Ohms, usaremos esa, la corriente disminuir谩 una cantidad marginal.\n驴Y si quiero a帽adir un led adicional a la misma fuente?, podemos a帽adir el led de forma paralela al led ya existen y recalcular la resistencia.\nLeds en paralelo\nEl c谩lculo es id茅ntico salvo que ahora la corriente es el doble, pues se requiere satisfacer la corriente de cada diodo $latex i = i_{D1} + i_{D2} = 20[mA]$, la resistencia necesaria es $latex R = 160 \\Omega$, el problema es que la resistencia disipara m谩s potencia, que significa que se calentara m谩s. Un m茅todo m谩s recomendado es conectar una segunda rama (con diodo y resistencia incluidos), en paralelo a la fuente,\nDiodos con resistencia en paralelo\nde esta forma las dos resistencias son iguales a 330 Ohms. Podemos conectar tantas ramas en paralelo como deseemos, el limite es la capacidad de corriente de nuestra fuente, hay que recordar que el limite de un pin del atmega328p es de 40[mA].\n"}),a.add({id:20,href:'/eleckia/posts/bloque-reutilizable-sin-titulo-2/',title:"res",section:"Posts",content:"La ley de Ohm es una herramienta fundamental en la electr贸nica, en esta ocasi贸n vamos a calcular la resistencia adecuada para que un diodo pueda operar de forma segura.\nAntes que nada definamos que es un diodo, sin entrar en detalles, un diodo es un dispositivo que permite el flujo de corriente en una sola direcci贸n, cuenta con dos terminales, el 谩nodo y c谩todo, la regla es que si se conecta un voltaje alto al 谩nodo y uno bajo al c谩todo, entonces fluye corriente, esta operaci贸n del diodo se conoce como polarizaci贸n directa, si se invierten las conexiones se dice que el diodo esta polarizado en inversa y no fluye corriente. Un circuito simple se muestra en la figura,\nCircuito con Diodo\nAhora reemplazamos el diodo por su circuito equivalente,\nDiodo en Directa\nLa resistencia \u0026ldquo;interna\u0026rdquo; del diodo es muy peque帽a por lo que podemos despreciarla, no debemos olvidar que este circuito es un modelo, este modelo funciona bien porque representa el comportamiento del diodo, no significa que dentro del diodo exista una resistencia y una fuente de voltaje, el valor de la fuente de voltaje varia de diodo a diodo, debemos verificar la hoja de datos para ver que voltaje tiene el diodo en cuesti贸n, en algunos casos el voltaje es peque帽o comparado con el resto de voltajes y simplemente se desprecia, modelando el diodo como un simple corto circuito.\nEn el caso de la polarizaci贸n inversa el circuito es aun m谩s simple\nDiodo en Inversa\nes un circuito y no hay circulaci贸n de corriente.\nLed. #  Un led es un diodo que tiene la capacidad de emitir luz, el voltaje del diodo led es mayor que el voltaje de otro tipo de diodos, siendo el rojo el mas peque帽o alrededor de 1.8 [V] y el azul el m谩s grande alrededor de 4.8 [V], esto para leds de 5mm, sin embargo esto valores cambian seg煤n el tama帽o del led, lo mejor es revisar en la hoja de datos del diodo en cuesti贸n.\nUn led generalmente se acompa帽a de una resistencia conectada en serie, 驴para qu茅?, la respuesta es simple, para limitar su corriente, entendamos que es un corto circuito.\nPartiendo del circuito anterior, tenemos una fuente en serie con una resistencia, recordemos que la corriente es\n$latex i = \\frac{V}{R}$\nun corto se entiende como una conexi贸n el茅ctrica de cero resistencia entre dos terminales. De esta forma los puntos A y B en el esquema est谩n en corto, dicho de otra manera no hay resistencia entre ellos, esto implica que la corriente puede fluir totalmente entre estos dos puntos, Las terminales C y D no est谩n en corto pues hay una resistencia entre ellas, 驴que pasar铆a si quitamos la resistencia?, pues tendr铆amos a las terminales C y D en corto y las consecuencias serian desastrosas. de la ley de Ohm tenemos $latex i = \\frac{V}{0} = \\infty$, las fuentes no pueden otorgar energ铆a infinita, est谩n dise帽ada para dar una corriente establecida de corriente, si se sobrepasa el limite se da帽aran, es por eso que nunca debes juntar las terminales de una fuente.\nRegresando a nuestro diodo led, 驴qu茅 pasar铆a si no colocamos una resistencia entre el diodo y la fuente?,\nDiodo en corto\ncomo dijimos la resistencia del modelo del diodo es muy peque帽a por lo tanto la fuente y el diodo est谩n en corto, es decir fluir谩 una gran cantidad de corriente desde la fuente hacia el diodo, si se tiene suerte el diodo se quemara y se abrir谩 el circuito, si tienes un mal d铆a tu fuente se da帽ara tambi茅n, los diodos est谩n fabricados para trabajar a un cierta corriente, en el caso de los diodos peque帽os de 5mm la corriente suele estar alrededor de los 10[mA], en el caso de los diodos led de iluminaci贸n es com煤n encontrar corrientes de 300[mA]. Calculemos r谩pidamente la resistencia de un led de 5mm rojo de 1.8[V] y 10[mA], que se desea conectar a una fuente de 5[V]. El circuito es el siguiente.\nde la ley de Ohm despejando la resistencia se tiene\n$latex R = \\frac{V_R}{i}$\ny la aplicamos a la resistencia R, recordemos que la corriente es un flujo, por lo tanto la corriente que pasa por la resistencia es la misma que pasa por el led, sabemos que el voltaje en la terminal positiva de la resistencia es 5V y el voltaje en la terminal negativa de la resistencia es 1.8V (estamos despreciando la resistencia interna del diodo), por lo tanto el voltaje que hay entre las terminales de la resistencia R es\n$latex V_R = (5 - 1.8) [V] = 3.2[V]$\nsabemos que la corriente de operaci贸n del led es de 10mA, por lo tanto la resistencia adecuada debe ser\n$latex R = \\frac{3.2[V]}{10[mA]} = \\frac{3.2[V]}{0.010[A]} = 320 \\Omega$\nla resistencia comercial m谩s cercana es de 330 Ohms, usaremos esa, la corriente disminuir谩 una cantidad marginal.\n驴Y si quiero a帽adir un led adicional a la misma fuente?, podemos a帽adir el led de forma paralela al led ya existen y recalcular la resistencia.\nLeds en paralelo\nEl c谩lculo es id茅ntico salvo que ahora la corriente es el doble, pues se requiere satisfacer la corriente de cada diodo $latex i = i_{D1} + i_{D2} = 20[mA]$, la resistencia necesaria es $latex R = 160 \\Omega$, el problema es que la resistencia disipara m谩s potencia, que significa que se calentara m谩s. Un m茅todo m谩s recomendado es conectar una segunda rama con diodo y resistencia incluidos en paralelo a la fuente,\nDiodos con resistencia en paralelo\nde esta forma las dos resistencias son iguales a 330 Ohms. Podemos conectar tantas ramas en paralelo que deseemos, el limite es la capacidad de corriente de nuestra fuente, hay que recordar que el limite de un pin del atmega328p es de 40[mA].\n"}),a.add({id:21,href:'/eleckia/docs/avr/primitivos/',title:"Variables y tipos",section:"Programaci贸n Avr en C.",content:"Variables y tipos primitivos #  El lenguaje de programaci贸n C, es un lenguaje de tipado est谩tico, esto quiere decir que nosotros debemos indicar el tipo de dato que guarda una variable.\n驴Qu茅 es una variable?, puede decirse que una variable es un espacio en memoria que guarda un valor determinado, y 驴qu茅 es un tipo?, por tipo de se entiende a una indicaci贸n hacia el compilador de como se utilizar谩 el dato. En C existen los siguientes tipos, tambi茅n llamados tipos primitivos:\n int, enteros almacenan valores enteros, como: 1, 2, -100, 0b11111, 0x32, \u0026hellip; float o double, de punto Flotante, cantidades con decimales como: 1.111, 3.141598, -1.4142, \u0026hellip; char, Caracter. \u0026lsquo;a\u0026rsquo;, \u0026lsquo;y\u0026rsquo;, ' \u0026lsquo;, \u0026lsquo;\\n\u0026rsquo;, \u0026hellip; *, Apuntador, almacena direcciones de memoria.  Existen tipos adicionales pero son variantes de las anteriores, como dijimos para declarar una variable debemos especificar su tipo, esto se hace con la siguiente sintaxis,\ntipo nombre_de_variable; //Una variable entera llamado numero int numero; //Una variable de tipo car谩cter llamada letra char letra; //Una variable de tipo punto flotante llamada cantidad double cantidad; //Un apuntador de tipo entero llamado signal int * signal; 驴F谩cil no?, pero en la vida nada es f谩cil :D.\nEl tama帽o de los enteros, stdint.h #  Un problema importante es que el tama帽o de los enteros depende del compilador y de otros factores como la arquitectura del microcontrolador, en el caso de los microcontroladores avr de 8 bits, el tama帽o de los enteros declarados con int es 2 bytes, sin embargo en microcontroladores cortex-m suelen ser de 4 bytes, esto provoca que el c贸digo sea dif铆cil de portar entre una plataforma y otra, afortunadamente podemos hacer el c贸digo m谩s portable con la biblioteca stdint.h, con ella podemos especificar el tama帽o de los enteros:\n#include \u0026lt;stdint.h\u0026gt; //entero de 8 bits llamado ocho int8_t ocho; int16_t dieciseis; int32_t treintaydos; Con esto tenemos la seguridad de que los enteros tendr谩n el mismo tama帽o en ambas arquitecturas o en cualquier otra que soporte la biblioteca(la mayor铆a).\n8 bits pueden almacenar desde -128 a 127 16 bits pueden almacenar desde -32768 a 32767 32 bits pueden almacenar desde -2147483648 a 2147483647 64 bits pueden almacenar desde -9,223,372,036,854,775,808 a 9,223,372,036,854,775,807 Nosotros evitaremos utilizar la declaraci贸n com煤n en favor de la declaraci贸n provista por la biblioteca stdint.h cuando de manipulaci贸n de registros se trate.\nEl tipo char #  El tipo char sirve para guardar caracteres tiene un tama帽o de 8 bits, es muy com煤n ver programas donde un tipo char guarda el valor de un registro:\n//variable de tipo char llamada registro que guarda el valor de DDRB; char registro = DDRB; Es preferible guardar el valor de los registros en variable enteras de 8 bits, principalmente por motivos de legibilidad, pero tambi茅n por portabilidad.\n驴Y las palabras? #  En C no existe el tipo string como en otros lenguajes, ciertamente el manejo de strings o mejor dicho de cadenas de caracteres es m谩s doloroso.\nLos strings se representan como arreglos de caracteres (los arreglos se detallan en otra entrada), los arreglos son espacios conjuntos de memoria, un string por lo tanto no es m谩s que una serie de caracteres que son declarados de forma contigua:\nchar palabra[] = \u0026#34;Hola mundo\u0026#34;; //otra forma char * otra = \u0026#34;Adios mundo\u0026#34;; El tipo char puede almacenar los caracteres descritos por el c贸digo ASCII, incluidos los de control, por ejemplo el car谩cter nulo \u0026lsquo;\\0\u0026rsquo;, o el tabulador \u0026lsquo;\\t\u0026rsquo;, el uso de caracteres suele estar limitado a los dispositivos capaces de mostrarlos, como pantallas por ejemplo.```\nAlgunas personas utilizan el puerto serial para enviar comandos por medio de caracteres, sin embargo es un m茅todo ineficiente, imagina que queremos enviar el n煤mero 200 desde un microcontrolador a una PC, podr铆as usar el puerto serial y enviar un \u0026lsquo;2\u0026rsquo;, \u0026lsquo;0\u0026rsquo; y \u0026lsquo;0\u0026rsquo;, cada uno es un car谩cter y tiene un tama帽o de 8 bits, en total son 3x8 bits, sin embargo el n煤mero 200 puede almacenarse sin problemas en solo 8 bits, ahora supongamos que queremos enviar el n煤mero 2,000,000,000, enviarlo car谩cter por car谩cter requerir铆a 8x10 bits, 80 bits, cuando perfectamente ese n煤mero puede ser almacenado en un entero de 32 bits.\nDouble y float #  El tipo double almacena n煤meros con punto decimal, por medio de una representaci贸n de punto flotante. En el lenguaje C moderno para arquitecturas de 64 bits float esta en desuso, sin embargo en microcontroladores avr de 8 bits float y double se implementan igual, ambas tienen un tama帽o de 32 bits.\nLa aritmetica de punto floate es costosa y se realiza por software, otras arquitecturas como los cortex-m4 tienen hardware dedicado para punto flotante, sin embargo es pronto para preocuparse por el rendimiento, sugiero no preocuparse tanto por el comentario anterior.\nApuntadores #  Los apuntadores son la herramienta m谩s poderosa del lenguaje C y tambi茅n la m谩s peligrosa, har茅 una entrada dedicada a Apuntadores.\n"}),a.add({id:22,href:'/eleckia/docs/perifericos/gpio/gpio/',title:"Puertos de entrada/salida de prop贸sito general (GPIO)",section:"GPIO",content:"Puertos de entrada/salida de prop贸sito general. #  Cando pensamos en programar microcontroladores, lo que queremos es hacer que el mundo se mueva, controlar un motor, un relevador, una lampara, altavoz, etc. Para ello los microcontroladores cuentan con una serie de perif茅ricos. A grandes rasgos un perif茅rico puede definirse como: una interfaz que permite al microcontrolador comunicarse con el exterior, en esta entrada describiremos los puertos de entrada/salida de prop贸sito general; GPIOx.\nSeg煤n la hoja de datos el atmega328p tiene hasta 23 pines programables, cada uno con la posibilidad de ser programado individualmente, Arduino Uno tiene 20 pines disponibles, pues 2 est谩n destinados al reloj y el otro est谩 destinado al pin de reset.\nLos pines est谩n agrupados en puertos, en el atmega328 contamos con tres puertos disponibles, PORTB, PORTC, PORTD, de manera gen茅rica los llamamos PORTx, cada uno de estos puertos cuentan con tres registros asociados, DDRx, PORTx, PINx, donde \u0026ldquo;x\u0026rdquo; es el puerto(B, C, D), estos nueve registros nos permiten configurar y acceder a los valores de cada uno de los pines del microcontrolador.\nLos pines en el microcontrolador tienen un nombre del tipo Pxn, donde x es el puerto y n es 茅l n煤mero de pin, el pin PB0 y el pin PD7, son el pin 0 y el pin 7 del puerto B y del puerto D respectivamente.\nConfigurar un Pin como Salida. #  La primera necesidad que se resuelve al programar un microcontrolador es encender y apagar un dispositivo externo, todos los pines que corresponden a alguno de los puertos gpio pueden establecerse como salidas, establecer un pin como salida implica dotar a ese pin de la capacidad de entregar o recibir corriente el茅ctrica, cada unos de los pines del atmega328p puede entregar un m谩ximo de 20[mA] y un total de 200[mA] entre todos, esto es bastante aunque no lo parezca, la mayor铆a de las veces tomaremos alrededor de 1[mA] de cada pin o menos, el objetivo de un microcontrolador es controlar, no dotar de potencia a los dispositivos, cuando se requiere m谩s potencia como para manejar un motor grande, se recurre a electronica adicional dedicada a ese rubro.\nSuponiendo que requerimos encender un led (un led requiere alrededor de 10[mA]) que est谩 conectado al pin PB4, Debemos indicarle al registro DDRB que requerimos el pin PB4 como salida:\nDDRB |= 1\u0026lt;\u0026lt;PB4; Para mayores detalles sobre como establecer un bit\nEstablecer el estado cuando el pin es configurado como salida. #  Cuando un pin es configurado como salida, puede entregar/recibir potencia, poquita, pero suficiente para mover al mundo, para ello se requiere establecer el estado del pin, asumiendo que tenemos conectado un led al pin PB4 y que dicho pin esta configurado como salida en el registro DDRB, entonces podemos establecer el estado del pin en el registro PORTB, donde un cero es nivel bajo(0 V) y un uno es nivel alto (5 V).\n//Led encendido PORTB |= 1\u0026lt;\u0026lt;PB4; //Led apagado PORTB \u0026amp;= ~(1\u0026lt;\u0026lt;PB4); Toggle #  Algo muy curioso es que sin un pin esta configurado como salida y se escribe al registro correspondiente de entrada, el pin hace un toggle o un xor, suponiendo que el pin PD1 se encuentre configurado como salida:\nPINB |= 1\u0026lt;\u0026lt;PD1; //El pin se pone en estado alto si estaba en bajo PINB |= 1\u0026lt;\u0026lt;PD1; //El pin se pone en estado bajo si estaba en alto Este es un comportamiento t铆pico y raro pero 煤til de los avr de 8 bits.\nConfigurar un Pin como Entrada. #  Para poder hacer acciones m谩s complejas requerimos que nuestro microcontrolador pueda \u0026ldquo;sentir\u0026rdquo; al mundo, los pines de nuestro microcontrolador pueden configurarse para que se pueda interpretar el estado de un pin, establecido por un elemento externo (como un bot贸n pulsador). Para ello tambi茅n se utiliza el registro DDRx, pero en esta ocasi贸n el pin a ser configurado se establece con un cero.\nDDRC \u0026amp;= ~(1\u0026lt;\u0026lt;PC0); //Pin PC0 como entrada Establecer un pin como entrada implica que el pin es incapaz de recibir y entregar corriente, esto es muy bueno pues el dispositivo que esta enviando los pulsos requiere un gasto de energ铆a m铆nimo, por otro lado el pin se vuelve extremadamente sensible a cualquier impulso incluso a las ondas electromagn茅ticas generadas por diferentes fuentes, como lamparas o televisores. Se dice que el pin del microcontrolador esta configurado en modo de alta impedancia. La mayor铆a de los microcontroladores cuentan con una resistencia de pull up que resuelve este problema.\nResistencia de Pull up. #  Para evitar que el pin configurado como entrada se vuelva loco con solo mirarlo, basta con habilitar una resistencia de pull up en el pin, la resistencia se puede poner de forma externa o habilitar la resistencia interna que el microcontrolador trae para este prop贸sito, la resistencia de pull up no es m谩s que una resistencia conectada entre el pin y Vcc(5[V] en condiciones normales), de tal forma que el pin se \u0026ldquo;ancla\u0026rdquo; al voltaje de Vcc. La resistencia de pull up tiene un valor grande no se requiere de mucha potencia para \u0026ldquo;desanclar\u0026rdquo; el pin de Vcc por parte del dispositivo que env铆a la se帽al.\nPara habilitar la resistencia interna de pull up, asumiendo que el pin PC0 se encuentra configurado como entrada:\nPORTC |= 1\u0026lt;\u0026lt;PC0; //PC0 con resistencia de pullUp Desafortunadamente el atmega328p no cuenta con resistencia de pull down.\nLeer el estado de un pin. #  Cuando requerimos leer el estado del pin, utilizamos el registro PINx, contiene el estado de cada unos de los pines del puerto, Para censar al pin, debemos configurarlo como entrada en el registro DDRx.\nPara leer el estado del pin PC3, asumiendo que PC3 esta conectado a 5V y que PC3 esta configurado como entrada en DDRC (con un cero),\nuint8_t entrada = PINC \u0026amp; (1\u0026lt;\u0026lt;PC3); //Es igual a entrada = 0bxxxx1xxx \u0026amp; 0b00001000; //donde las x pueden ser 0 o 1 //aplicando and bit a bit resulta en entrada = 0b00001000; //entrada es exactamente igual a entrada = 8; //si PC0 estuvera conectado a tierra, //entrada resultar铆a en entrada = 0bxxxx0xxx \u0026amp; 0b00001000; //aplicando and bit a bit resulta en entrada =0b00000000; //o entrada = 0; "}),a.add({id:23,href:'/eleckia/posts/electronica-basica-voltaje-corriente-resistencia-y-ley-de-ohm/',title:"Electr贸nica B谩sica.- Voltaje, Corriente, resistencia y ley de Ohm.",section:"Posts",content:"Cuando la gente de computaci贸n escucha las palabras en el titulo de esta entrada, suele entrar en p谩nico y no es para menos, el an谩lisis de circuitos el茅ctricos puede llegar a ser muy complejo; sin embargo la electr贸nica descansa sobre una ley simple, la ley de Ohm,\n$latex V = iR$\nla ley de Ohm relaciona el voltaje con la corriente y la resistencia; pero esto no nos dice nada si no entendemos estos t茅rminos, comencemos con el voltaje, tambi茅n llamado tensi贸n o potencial el茅ctrico, en la f铆sica,\nE_l voltaje se define como la cantidad de trabajo necesaria para mover una carga desde el infinito hasta un punto determinado_.\nAhora que ya sabes y entendiste claramente el voltaje pasemos con lo siguiente (es broma obviamente), la definici贸n no nos sirve pues se aleja demasiado de la parte pr谩ctica, una forma m谩s laxa y 煤til de interpretarlo es;\nEl voltaje es una fuente de energ铆a el茅ctrica que impulsa a la corriente el茅ctrica a fluir a trav茅s de un circuito el茅ctrico.\nEsta definici贸n no rigurosa pero nos es de gran utilidad, por la definici贸n y por la ley de Ohm, su unidad de medida es el Volt [V], si el voltaje es muy grande la corriente que puede proveer la fuente es de mayor intensidad, por el contrario si el voltaje es negativo, \u0026ldquo;absorbe\u0026rdquo; corriente el茅ctrica.\n驴Pero qu茅 es la corriente el茅ctrica?, pues no es m谩s que un flujo de cargas el茅ctricas, flujo de electrones a trav茅s de un medio, usualmente un conductor, pero puede ser incluso a trav茅s del aire form谩ndose un arco el茅ctrico cuando hay voltaje muy alto, su unidad de medida es el Ampere [A], se le representa con un s铆mbolo \u0026ldquo;i\u0026rdquo; en el esquema a continuaci贸n, la direcci贸n de la corriente va de voltaje alto a voltaje bajo; o si solo hay una fuente va de la terminal positiva a tierra (una forma com煤n de referirse al voltaje o potencial 0[V]).\nDirecci贸n de la corriente\nUna resistencia es un elemento que se opone a el paso de la corriente, si colocamos en un circuito el茅ctrico un resistencia de 10 Ohms, la corriente que pasa por ella seria mucho mayor que si coloc谩ramos una resistencia de 1000 Ohms.\nPor ejemplo, tenemos una fuente de 5V, una resistencia de 330 Ohms conectada entre sus terminales, 驴Qu茅 corriente pasa por la resistencia?\nsabemos que $latex V = i R$, dividiendo ambos lados entre la resistencia\n$latex \\frac{V}{R} = \\frac{iR}{R}$\npor lo tanto, la corriente es\n$latex i = \\frac{V}{R}$\n$latex = \\frac{5}{330}=0.015 [A] = 15 [mA]$\n驴Por qu茅 es importante conocer la corriente?, debido a que cada pin de nuestro microcontrolador tiene poca capacidad de entregar o recibir potencia, dicho de otra forma la corriente que sale de cada pin est谩 limitada, para el atmega328p la corriente m谩xima de cada pin es de 40mA y la corriente entre todos los pines no debe ser superior a 200mA, sobrepasar este limite implica da帽ar el microcontrolador, para manejar corrientes grandes mayores a 10[mA] utilizaremos componentes externos.\n"}),a.add({id:24,href:'/eleckia/posts/que-son-los-registros-en-un-microcontrolador/',title:"驴Qu茅 son los registros en un microcontrolador?",section:"Posts",content:"Hemos hablado acerca de los registros en anteriores entradas, vamos a profundizar un poco en el tema.\nPara entender un registro, definamos que es un bit, la palabra tiene varias acepciones, para nuestro prop贸sito un bit es la representaci贸n de un valor binario, este puede ser 1 o 0. Entonces un registro es sencillamente un conjunto de bits, en nuestro microcontrolador atmega328p, existen registros de 8bits, en otras arquitecturas como los cortex-m los registros son de 32 bits, algunos como el msp de texas instruments, tienen registros de 16 bits.\n驴Es mejor 32 que 8 bits?, no realmente, la diferencia radica en que un sistema de 32 bits requiere un bus de 32 bits, un bus podr铆a definirse como un conjunto paralelo de cables que comunica los registros con alg煤n otro elemento, en otras palabras un bus de 32 bits comunica mayor informaci贸n por cada ciclo, a priori esto es bueno, sin embargo las instrucciones que tambi茅n viajan por este bus, no necesariamente ocupan los 32 bits, esto deriva en programas m谩s grandes para las arquitecturas de 32 bits. Hoy por hoy las arquitecturas de 32 bits son muy populares, siendo incluso m谩s baratas y eficientes que sus contrapartes de 8 bits, la gran ventaja de los 8 bits radica en su facilidad y simpleza.\nSiguiendo con los registros, programar un microcontrolador se resume a modificar los registros, ya comentamos el registro DDRx, donde x es un puerto determinado (haremos una serie especifica sobre puertos), modificar dicho registro nos permite establecer el comportamiento de cada uno de los pines pertenecientes a dicho puerto. A lo largo de las entradas iremos revisando varios de los registros y explicaremos las implicaciones que se tienen al modificarlos. En realidad DDRx es un nemot茅cnico no un registro, cuando escribimos DDRB, realmente estamos escribiendo algo similar a *(0xfa020121029120), una vez que estudiemos los apuntadores detallaremos que es lo anterior, adelanto que el n煤mero entre par茅ntesis es la direcci贸n del registro).\nEl tema de los registros tiene una gran exposici贸n cuando se programa en ensamblador, el ensamblador es un lenguaje muy estimulante de aprender y el ensamblador de avr es muy limpio y sencillo, quiz谩 en el futuro expliquemos un poco.\n"}),a.add({id:25,href:'/eleckia/docs/avr/iniciando/',title:"Programando Avr en C.- Blinky",section:"Programaci贸n Avr en C.",content:"Comenzando con avr y C #  Para iniciar en la programaci贸n de dispositivos avr, se requieren algunas cosas:\n Un compilador de C y sus utilidades para avr:  Aunque existen varios compiladores disponibles, avr_gcc es el que se encuentra en la mayor铆a de los proyectos.   Un editor de texto:  Nuevamente hay muchas opciones, en lo personal prefiero vim.   avrdude, este programa nos ayuda a subir el c贸digo al microcontrolador.  Escribiendo el programa #  Comenzamos creando un fichero llamado blinky.c, dentro del cual agregamos:\n#include \u0026lt;avr/io.h\u0026gt;La directiva \u0026ldquo;include\u0026lt;\u0026gt; copia el contenido del fichero indicado, en nuestro fichero blinky.c, en este caso copia el contenido del fichero io.h que se encuentra dentro del directorio avr, no nos interesa la ubicaci贸n del directorio avr, el compilador sabe donde se encuentra y lo incluye de manera autom谩tica. Lo que si nos interesa saber es que incluir el fichero io.h nos permite acceder a los registros que controlan los pines del microcontrolador.\nPosteriormente tenemos la funci贸n main:\nint main(void) { return 0; } La funci贸n main es un ente importante, cuando el programa se ejecuta, la funci贸n main es llamada autom谩ticamente, el c贸digo dentro de las llaves se ejecutara l铆nea por l铆nea, lo que est茅 fuera de dicha funci贸n deber谩 ser llamado expl铆citamente para poder ejecutarse. Por definici贸n la funci贸n main retorna un entero al finalizar y en el caso de microcontroladores no suele recibir argumentos por eso la palabra void (m谩s adelante analizaremos la estructura de las funciones).\nDespu茅s viene el superloop,\nint main(void) { while(1){ //tareas 	} return 0; } El superloop es un ciclo infinito que se ejecuta dentro del main, en general las tareas deben definirse dentro del loop de tal forma que se repitan una y otra vez.\nFinalmente tenemos un retorno, como nuestro programa se queda \u0026ldquo;ciclado\u0026rdquo; dentro del while, nunca alcanzaremos esta l铆nea, sin embargo es conveniente poner esta l铆nea o el compilador nos dar谩 una advertencia.\nYa estamos un poco m谩s familiarizados con la estructura del programa, ahora si analicemos el programa Blink,\n#include\u0026lt;avr/io.h\u0026gt;#include\u0026lt;util/delay.h\u0026gt; int main(void) { DDRB = 1\u0026lt;\u0026lt;PB5; PORTB = 0; while(1){ PORTB = 1\u0026lt;\u0026lt;PB5; _delay_ms(1000); PORTB = 0; _delay_ms(1000); } return 0; } Al inicio tenemos dos directivas include, la primera io.h, nos permite acceder a los registros de los puertos de nuestro microcontrolador, en este caso el puerto B, har茅 una entrada especifica para este tema, la segunda delay.h nos permite usar la funci贸n _delay_ms, que como deducir谩s nos permite crear un tiempo muerto.\nIniciamos con la funci贸n main y lo primero que tenemos es una asignaci贸n, te preguntaras que es DDRB, para entenderlo primero debo explicar que es un registro y lo explicare en una entrada dedicada, por ahora vamos a decir que DDRB es una variable a secas, a esta variable le asignamos el resultado de una operaci贸n 1\u0026laquo;PB5, el s铆mbolo \u0026ldquo;\u0026laquo;\u0026rdquo; es un operado binario llamado left shift o corrimiento a la izquierda, indica que el n煤mero a la izquierda sera recorrido el n煤mero de veces que tiene a la derecha en binario, por ejemplo\n3 en binario es 0b0011 Aplicar un corrimiento a la izquierda en una unidad implica: 3\u0026lt;\u0026lt;1 es exactamente igual a: 0b0011\u0026lt;\u0026lt;1 y da como resultado 0b0110 en decimal 6 En nuestro caso, casi siempre usaremos un 1 a la izquierda del operador, por lo tanto\n1 en binario es 0b1 1\u0026lt;\u0026lt;1 da como resultado 0b10 1\u0026lt;\u0026lt;2 da como resultado 0b100 1\u0026lt;\u0026lt;3 da como resultado 0b1000 1\u0026lt;\u0026lt;7 da como result. 0b10000000 Realmente no nos interesa el valor en decimal, lo que nos interesa es donde queda posicionado el 1, al final de la operaci贸n con 1\u0026laquo;2, el 1 queda posicionado en la tercera de derecha a izquierda, con 1\u0026laquo;7, queda en la octava de derecha a izquierda.\n驴Para que es esto?, DDRB es una \u0026ldquo;variable\u0026rdquo; que le indica al microcontrolador si el pin es de entrada o de salida, si el bit es cero, el pin operara como entrada, de lo contrario opera como salida. DDRB contiene 8 bits y cada bit corresponde a un pin de nuestro microcontrolador, al inicio contiene el valor binario 0b0000 0000, si revisas la hoja de datos de tu microcontrolador te dar谩s cuenta que los pines est谩n rotulados con las leyendas PA0, PB0, PC0, PA1, etc, estos son los \u0026ldquo;nombres\u0026rdquo; de los pines y A,B,C, es el puerto al que pertenecen, por lo tanto el pin 5 del puerto B se llama PB5.\nEl pin PB5 esta conectado al led de nuestra tarjeta, hay que decirle a DDRB que ponga el pin 5 como salida, tan f谩cil como:\nDDRB = 1\u0026lt;\u0026lt;PB5; //que es exactamente igual a DDRB = 0b00100000; //bit 76543210 Lo anterior tiene la desventaja de poner al resto de pines como entrada, por ahora no es un problema, pero no es la forma correcta, en otra entrada se dar谩 la forma correcta.\nSeguimos adelante y tenemos otra asignaci贸n, PORTB es otro registro, de igual forma asumiremos por ahora que es una variable, controla el estado del pin, el estado puede ser 0 para bajo o 1 para alto, en s铆ntesis cuando el pin se configura en alto tendr谩 5 volts y cuando se configura en bajo tendr谩 0 volts, cuando necesitemos encender el led lo configuramos como alto con\nPORTB = 1\u0026lt;\u0026lt;PB5; //que es exactamente igual a PORTB = 0b00100000; 驴y si queremos ponerlo en bajo?, por ahora solo esto,\nPORTB = 0; //que es exactamente igual a PORTB = 0b00000000; Siguiendo con el programa, entramos al ciclo infinito en donde la parte interesante es la funci贸n _delay_ms(), la funci贸n se explica por si misma, cuando se llama toma el control de la ejecuci贸n del programa y espera la cantidad de tiempo indicada en milisegundos, 1000 para este ejemplo, pasado este tiempo la funci贸n termina y sigue con la ejecuci贸n del programa.\nEl programa se queda en este bucle encendiendo y apagando el led cada dos segundos.\nCompilando #  Si no tenemos instalado avr_gcc, en una terminal:\n$ sudo dnf install avr-gcc El proceso de compilaci贸n es simple, abrimos una terminal, nos dirigimos al directorio donde se encuentra nuestro fichero y escribimos:\n$ avr-gcc -mmcu=atmega328p blinky.c El compilador generar谩 un archivo ejecutable en formato elf: a.out, sin embargo se requiere convertir este fichero a otro formato antes de poder grabarlo en el microcontrolador. El archivo a.out contiene informaci贸n adicional a las instrucciones del programa, para \u0026ldquo;filtrar\u0026rdquo; la informaci贸n relevante:\n$ avr-objcopy -O ihex a.out blinky.hex La herramienta avr-objcopy extrae las instrucciones y las coloca en el fichero blinky.hex.\nGrabando #  Finalmente utilizamos la herramienta avrdude para grabar el programa\n$ avrdude -c arduino -P /dev/ttyACM0 -p m328p -U flash:w:blinky.hex Un par de segundos despu茅s el led del arduino comenzara a parpadear cada dos segundos.\nEl par谩metro -P /dev/ttyACM0 indica el puerto, desafortunadamente no siempre es el mismo, tambi茅n puede ser /dev/ttyUSB0 o alg煤n otro, pero por lo general es alguno de esos dos.\n"}),a.add({id:26,href:'/eleckia/posts/bloque-reutilizable-sin-titulo/',title:"save",section:"Posts",content:"El siguiente paso obvio es analizar el programa Blink, sin embargo aqu铆 no usaremos las bibliotecas de Arduino, usaremos c贸digo c para dispositivos AVR, entonces 驴para que tanto problema instalando la maquina virtual y Arduino?, simplemente porque utilizaremos la infraestructura ya hecha para nuestro prop贸sito, abrimos el ejemplo Blink y reemplazamos el c贸digo por:\n#include\u0026lt;avr/io.h\u0026gt; #include\u0026lt;util/delay.h\u0026gt; int main(void) { DDRB = 1 \u0026lt;\u0026lt; PB5; PORTB = 0; while(1){ PORTB |= 1 \u0026lt;\u0026lt; PB5; \\_delay\\_ms(1000); PORTB \u0026amp;= ~(1\u0026lt;\u0026lt;PB5); \\_delay\\_ms(1000); } } compilamos y subimos el c贸digo, el comportamiento es exactamente el mismo, pero el c贸digo es totalmente C y no C++, tambi茅n evitamos el uso de las bibliotecas de Arduino en favor de las avr. Esto se nota de inmediato en el tama帽o del programa, mientras que nuestro c贸digo usa 108 Bytes, el c贸digo de Arduino usa 924 Bytes, esto realmente no es determinante, en un proyecto complejo y grande usar una biblioteca u otra no tendr谩 gran impacto en el tama帽o final. En realidad las Arduino usa como base las bibliotecas avr. Este peque帽o hola mundo, da para comentar muchas cosas, no te preocupes por no entender el c贸digo iremos desglos谩ndolo en las siguientes entradas, tambi茅n mostrare como liberarnos del IDE y por si fuera poco como liberarnos de la tarjeta.\n驴Por qu茅 no usar unicamente Arduino para todo?, la verdad es que la 煤nica raz贸n verdadera y valida es que no me gusta, otras razones menos validas son:\n Te limita a un pu帽ado de microcontroladores.- Dentro de la familia de los microcontroladores avr apenas unos cuantos son utilizados para las tarjetas Arduino, existen ports a otras arquitecturas y micros, pero suelen ser limitadas, quiz谩 lo que requieres realizar sea un programa muy sencillo, quiz谩 no necesites toda la potencia que te ofrece un atmega328p, tal vez lo que necesites sea un attiny13(hiper barato y peque帽o), por el contrario tal vez requieres algo muy r谩pido y potente como un amr cortex m7, o un risc V, no siempre tenemos a disponibilidad las bibliotecas de Arduino, pienso que es importante saber hacer tus propias bibliotecas y adaptarlas a un hardware cambiante. Te obliga a usar C++, aunque es posible enlazar bibliotecas de C++ en C, es un proceso un poco traum谩tico, el problema de C++ es que es muy dif铆cil de leer, el ejemplo cl谩sico es el siguiente  struct unaEstructura primero = nuevoNumero(); struct unaEstructura segundo = nuevoNumero(); // C a = primero.num + segundo.num; //En C esto tiene un significado obvio // C++ a = primero + segundo; //A priori no sabemos que esta pasando aqu铆 pudiera parecer una trivialidad, pero de igual forma sucede con varias otras situaciones, realmente es una cuesti贸n de simple gusto, C++ es un lenguaje muy potente, si te sientes c贸modo con 茅l 煤salo y expl贸talo al m谩ximo.\n El entorno en general es precario. No se puede tener todo, si es f谩cil tiene que haber un costo, el costo es que no tenemos herramientas de debugging, el editor es horrible, no se adapta muy bien a los proyectos colaborativos, no hay control de versiones.  Sin embargo hay muchas cosas buenas que no se encuentran en ning煤n otro ambiente, por lo tanto debemos equilibrar nuestras preferencias en aras de obtener el mejor rendimiento y calidad.\n"}),a.add({id:27,href:'/eleckia/docs/workstation/arduino/',title:"Arduino",section:"Estaci贸n de trabajo",content:"Arduino #  Arduino se compone tanto de software como de hardware, miremos un poco el hardware.\nHardware #  El Arduino Uno (placa de desarrollo), cuenta con un puerto usb, por el que se alimenta la placa; enviamos y recibimos datos, este puerto esta conectado a un circuito integrado FTDI que no es m谩s que un convertidor serial-usb, igualmente este convertidor se conecta a unos pines espec铆ficos del microcontrolador. Lo importante a destacar es que esta conexi贸n ya esta hecha y es perfectamente funcional, permitiendo la conexi贸n entre la placa y pc sin mayores complicaciones, esta es sin duda la gran caracter铆stica que dio paso al 茅xito, una plataforma lista para usarse sin necesidad de componentes adicionales.\nEl convertidor serial varia dependiendo de la versi贸n de tu tarjeta, pero su comportamiento es similar en todas las versiones. Ahora nos enfocamos en conocer el microcontrolador,\nEl atmega328p es un microcontrolador avr de 8 bits con arquitectura RISC, no entraremos en detalles sobre la arquitectura. Quiz谩 el par谩metro m谩s importante de un microcontrolador es la capacidad de memoria con la que cuenta, la asombrosa cantidad de 32KB de flash o memoria de programa y 2KB de ram, teniendo en cuenta que en este momento contamos con PCs regularmente de 8GB de ram y mayores de 1TB de almacenamiento, la memoria del atmega328p parecer铆a poco, sin embargo se pueden hacer muchas cosas con ella y cuando digo muchas es muchas, adicionalmente cuenta con 1KB de memoria eeprom, en la cual podemos guardar datos y evitar que se pierdan cuando se corta la alimentaci贸n.\nOtro par谩metro importante es la frecuencia a la que trabaja, siendo hasta 20MHz el m谩ximo posible, internamente cuenta con un oscilador que puede ser configurado hasta 8MHz, si queremos frecuencias mayores podemos conseguirlas conectado un oscilador externo, usualmente un reloj de cuarzo, la regla es que a mayor frecuencia mayor capacidad de procesamiento, pero mayor gasto de energ铆a. En el caso del Arduino(tarjeta), tiene un reloj de 16MHz ya conectado, por lo que el entorno esta desarrollado con este reloj en mente.\nCuenta con 23 pines programables en la versi贸n DIP y hasta 32 en la versi贸n de montaje superficial.\nLos perif茅ricos con los que cuenta\n Timer con output compare ADC USART SPI I2C Y varias fuentes de interrupciones  Describir茅 con mucho detalle los perif茅ricos en posteriores entradas.\nAdicionalmente la tarjeta cuenta con un par de hileras de pines donde podemos conectar componentes externos, un jack de alimentaci贸n por el cual podemos conectar hasta 9V, finalmente un LED conectado al pin 13.\nSoftware #  En cuanto al software, Arduino es un conjunto de bibliotecas que nos permiten programar el microcontrolador de una manera simple y f谩cil, hay bibliotecas para muchos dispositivos, muy probablemente la soluci贸n a una de tus necesidades o al menos la soluci贸n parcial se encuentre en forma de biblioteca ya programada por alguien m谩s.\nSin Arduino #  Mi objetivo es exponer al microcontrolador per se m谩s que al ambiente Arduino en general, tan solo sacare provecho de la tarjeta.\n"}),a.add({id:28,href:'/eleckia/docs/workstation/estacion-de-trabajo/',title:"Estaci贸n de trabajo",section:"Estaci贸n de trabajo",content:"Estaci贸n de trabajo #  No es obligatorio instalar Fedora, pero todos los ejemplos se har谩n desde este sistema operativo, eres libre de adaptar lo que aqu铆 se mencione a tus circunstancias.\nPara poder trabajar a gusto es necesario disponer de un conjunto de herramientas adecuado, dejando de lado el tipo de computadora con la que se cuenta, lo importante es el sistema operativo, utilizaremos software libre, nuestro sistema operativo sera linux, concretamente Fedora, esta distribuci贸n cuenta con los paquetes necesarios para desarrollar software c贸modamente, as铆 que si utilizas algo diferente comienza borrado tu disco duro e instala Fedora (obviamente esto es broma :D).\nLa manera m谩s sencilla de comenzar en este mundo (y la que seguiremos aqu铆) es con linux + arduino, hablemos r谩pida y brevemente de ellos.\nLinux es una pieza de software que funciona como interfaz entre el hardware de una computadora (memoria, procesador, perif茅ricos, etc), en pocas palabras y de manera muy general, linux se encarga de administrar el hardware de una PC, por otro lado existe software (GNU y otros) que se comunica con linux para formar un sistema operativo, de ah铆 surgen los sistemas GNU/Linux, a grandes rasgos el software GNU se encarga de administrar el sistema, envi谩ndole instrucciones a Linux (com煤nmente llamado kernel o n煤cleo) y este 煤ltimo las ejecuta en el hardware. Para el que este interesado en entender un poco m谩s sobre el origen y filosof铆a de GNU/linux y el software libre, les recomiendo ver el documental \u0026ldquo;C贸digo linux\u0026rdquo;, disponible en youtube en espa帽ol. Compa帽铆as aprovechan este conjunto de software para crear distribuciones, en nuestro caso trabajaremos con la distribuci贸n Fedora, patrocinada por Red Hat, disponible para su descarga gratuitamente.\nArduino es una plataforma de desarrollo, contiene tanto software como hardware, sera com煤n referirnos de manera indistinta al software o hardware con la palabra Arduino, con respecto al hardware hay muchas versiones, siendo el \u0026ldquo;Arduino uno\u0026rdquo; el m谩s com煤n y el que utilizaremos, este Arduino cuenta con un microcontrolador atmega328p, es un microcontrolador de la empresa Microchip, anteriormente le pertenec铆a a Atmel, pero fue comprada por la anterior mencionada, el microcontrolador es de 8 bits y contiene numerosos perif茅ricos. Arduino es software libre pero tambi茅n hardware libre, esto implica que los clones funcionen de manera id茅ntica a el hardware original, aunque si puedes comprarlo original siempre es bueno apoyar a los creadores. En la parte de software Arduino cuenta con su propio entorno de desarrollo (aunque a mi me parece horrible) y cuenta con miles de bibliotecas listas para ser usadas en nuestros proyectos.\nLo que requerimos:\n-Instalar Fedora\n-Adquirir un Arduino\n-Instalar Arduino dentro de Fedora\nComencemos instalando Fedora, como mencionamos Fedora es un sistema operativo, por lo tanto requerimos instalarlo en nuestra PC, podemos instalar junto a nuestro sistema operativo actual, podemos reemplazar nuestro sistema operativo actual por Fedora o si ya utilizamos Fedora como sistema operativo principal no hay necesidad de reinstalarlo, la 煤ltima opci贸n es instalarlo en una maquina virtual, si eres usuario windows probablemente esta opci贸n es la m谩s adecuada para ti.\nUna maquina virtual es un entorno que permite ejecutar un sistema operativo adicional sobre uno ya en ejecuci贸n, el sistema adicional se conoce como \u0026ldquo;huesped\u0026rdquo;(guess) y el que ya esta en ejecuci贸n se le denomina \u0026ldquo;anfitri贸n\u0026rdquo;(host), de esta manera podemos instalar Fedora sin la necesidad de modificar nuestro sistema operativo actual.\nInstalando VirtualBox #  Procedemos a instalar la maquina virtual, para ello visitamos el enlace https://www.virtualbox.org/\ny descargamos la versi贸n m谩s reciente para nuestro sistema operativo anfitrion(probablemente windows), no entrare en detalles sobre como instalar virtual box puesto que cada sistema es diferente, pero confi贸 en que sabes como instalar programas en tu sistema, para instalarlo en windows doble click sobre el ejecutable descargado, si eres usuario linux seguramente viene en los repositorios oficiales de tu distribuci贸n.\nCreando la maquina virtual #  Ahora descargaremos Fedora, accedemos al enlace\nhttps://getfedora.org/es/\nexisten varias ediciones, elegimos Workstation y la descargamos, la descarga es una imagen .iso de alrededor de 2GB, una vez descargado procedemos a instalar.\nAbrimos Virtualbox y seleccionamos \u0026ldquo;nueva\u0026rdquo;\nSe abrir谩 una nueva ventana escribimos \u0026ldquo;Fedora\u0026rdquo; en nombre, carpeta la dejamos por defecto, seleccionamos, tipo \u0026ldquo;Linux\u0026rdquo; y Versi贸n \u0026ldquo;Fedora (64-bit)\u0026rdquo;, click en siguiente.\nAhora nos pide configurar la memoria, aqui aparece un control de deslizamiento, selecciona por lo menos 2GB y da click en siguiente.\nAhora nos pide configurar un nuevo disco duro, seleccionamos \u0026ldquo;Crear un disco virtual Ahora\u0026rdquo; y damos click en siguiente.\nTipo de archivo de disco duro, VDI, siguiente.\nAlmacenamiento en unidad de disco duro f铆sica, Reservado din谩micamente, siguiente.\nUbicaci贸n del archivo y tama帽o, dejamos la ubicaci贸n por defecto y seleccionamos un tama帽o de 20GB, siguiente.\nHemos finalizado la creaci贸n de la maquina virtual, procedemos a instalar Fedora en el siguiente post.\nInstalando Fedora dentro de VirtualBox #  Abrimos VirtualBox y seleccionamos la maquina virtual Fedora que creamos anteriormente, ahora damos click en Configuraci贸n, se nos abrir谩 una nueva ventana, seleccionamos Almacenamiento y en controlador IDE, seleccionamos Vaci贸, a la derecha de unidad 贸ptica damos click en el icono de un disco azul y seleccionamos el .iso de Fedora que descargamos anteriormente, finalmente damos click en aceptar.\nSi tienes anfitri贸n linux, ah铆 mismo en configuraci贸n seleccionamos Pantalla y cambiamos Controlador Gr谩fico a VBoxVGA y aumenta la memoria de video a por lo menos 64MB.\nNuevamente en Configuraci贸n, ahora seleccionamos Sistema y en la pesta帽a Procesador, seleccionamos el n煤mero de procesadores que tenemos, damos click en aceptar.\nNuestra maquina virtual, esta lista para arrancar y ya tiene el \u0026ldquo;disco\u0026rdquo; de instalaci贸n insertado, procedemos a iniciarla con el icono Iniciar.\nArrancamos y la primer pantalla de selecci贸n nos da tres opciones, seleccionamos la primera, Start Fedora, cuidado por defecto esta seleccionada la segunda opci贸n.\nEsperamos a que el sistema inicie y tenemos una versi贸n live de Fedora funcionando,\nEsta versi贸n de Fedora es totalmente funcional, podemos jugar con ella, revisar los programas y menus, cambiar la resoluci贸n, etc, sabedores de que los cambios que hagamos no se guardaran, cuando estemos listos damos click en Install to Hard Drive. Se abrir谩 el asistente de instalaci贸n Anaconda (puede que tarde unos minutos), aqu铆 elegimos el idioma y la regi贸n y damos click en continuar,\nseleccionamos nuestra distribuci贸n de teclado(probablemente espa帽ol latinoamericano) y la zona horaria, click en Destino de la Instalaci贸n, sin modificar nada damos click en Hecho en la esquina superior izquierda y comenzamos la instalaci贸n.\nEsperamos unos minutos a que termine la instalaci贸n y damos click en salir.\nApagamos la maquina virtual y removemos la imagen .iso de Fedora.\nIniciamos nuevamente la maquina virtual esta vez iniciara Fedora instalado, todo lo que hagamos ahora si se guardara, nos dar谩 la bienvenida un asistente de configuraci贸n donde nos pedir谩 algunos datos, de ellos lo importante es el usuario y la contrase帽a, los cuales debemos recordar o en su defecto anotar. Una vez ingresados nuestro sistema estar谩 listo para poder instalar Arduino.\nInstalando Arduino #  Ya casi estamos listos, damos click en Actividades y abrimos una terminal, la terminal puede ser intimidante, pero creeme una vez te acostumbres a ella la amaras.\nEn los sistemas linux tenemos diferentes tipos de usuarios cada uno de ellos con diferentes privilegios, el usuario con m谩s privilegios es el usuario root, puede hacer y deshacer el sistema, nuestro usuario por defecto tiene pocos privilegios para evitar que el usuario pueda romper el sistema por accidente. Al abrir la terminal tendremos algo similar a esto\n[eleckia@tuxin-lp ~]$ donde eleckia es el nombre de usuario que se eligi贸, y tuxin-lp es el nombre que se le dio a la pc, delante del signo $, podemos escribir.\nDNF es el manejador de paquetes de Fedora, es una herramienta que nos permite actualizar, instalar y remover los programas y/o bibliotecas instaladas en nuestro sistema, para utilizarlo simplemente tecleamos\n[eleckia@tuxin-lp ~]$ dnf nos desplegara una enorme lista de las opciones disponibles para este comando, el que nos interesa por ahora es update, esta opci贸n nos actualiza todos los paquetes a la 煤ltima versi贸n disponible, tecleamos\n[eleckia@tuxin-lp ~]$ dnf update Error: Este comando debe ejecutarse como usuario root. el error nos indica que requerimos privilegios altos, la forma de escapar de la tiran铆a el usuario root, es anteponer la palabra sudo,\n[eleckia@tuxin-lp ~]$ sudo dnf update nos pedir谩 introducir la contrase帽a que creamos al iniciar Fedora por primera vez, la introducimos y nos desplegar谩 la lista de actualizaciones disponibles, nos pedir谩 confirmaci贸n a lo que responderemos s. La primera vez que actualicemos, habr谩 muchas actualizaciones, por lo que se tardara un poco, al terminar de actualizar, reiniciaremos el sistema y abriremos nuevamente una terminal, una vez hecho esto instalaremos Arduino por fin. Para instalarlo tan f谩cil como escribir lo siguiente:\n[eleckia@tuxin-lp ~]$ sudo dnf install arduino terminada la descarga e instalaci贸n, ya tenemos disponible el software Arduino, hacemos click en actividades y lo ejecutamos, nos indicara que debemos agregar nuestro usuario a los grupos dialout y lock, le decimos que si e introducimos la contrase帽a del sistema, tenemos finalmente todo listo para comenzar a programar, tan solo nos falta conectar nuestro Arduino a un puerto usb.\nAnteriormente mencione que trabajaremos con Arduino uno, sin embargo debo confesar que cualquier Arduino de 8 bits es valido, de hecho ni siquiera es necesario instalar Fedora, puedes instalar Arduino en casi cualquier sistema operativo, la raz贸n de instalar Fedora es que nos ofrece todas las herramientas de manera simple e inmediata, al estar dentro de una m谩quina virtual no debemos preocuparnos de da帽ar el sistema accidentalmente, yo har茅 todo desde Fedora, por que es mi sistema instalado, pero sientete libre de utilizar lo que m谩s te acomode, eso si, si tienes alg煤n problema con tu sistema no podre ayudarte puesto que yo no lo uso (windows). Lo mismo va para la tarjeta Arduino que utilices, funciona cualquiera, pero los registros de cada microcontrolador varian mucho, sobre todo de una arquitectura a otra, los microcontroladores de 8 bits no tiene nada que ver con los micros de 32 o 16 bits.\nNo es de mi inter茅s centrarme en Arduino, pero es la opci贸n de aprendizaje m谩s adecuada y ser铆a tonto no empezar con ella.\nLos lugares m谩s comunes para adquirir la tarjeta es ebay, amazon y mercadolibre, es tu elecci贸n, tambi茅n requerimos algunos dispositivos como leds, resistencias, transistores, capacitores, etc, en el siguiente post daremos algunos detalles adicionales.\nFin #  Finalizamos esta serie de post iniciales con una lista de materiales recomendada, en ebay existen una gran variedad de paquetes donde se incluyen Arduinos, resistencias, capacitores, transistores y algunos sensores, basta con ir a ebay o mercadolibre y buscar kit Arduino, adquirir uno de ellos es un buen comienzo.\nIgualmente puedes adquirir kits de resistencias, capacitores y leds, adem谩s de jumpers, cables y un par de atmega328p DIP adicionales.\nCon esto podemos comenzar nuestro estudio, m谩s adelante requeriremos m谩s componentes, pero se mencionar谩n con forme se requieran.\n"}),a.add({id:29,href:'/eleckia/posts/about/',title:"About",section:"Posts",content:"This is an example of a page. Unlike posts, which are displayed on your blogs front page in the order theyre published, pages are better suited for more timeless content that you want to be easily accessible, like your About or Contact information. Click the Edit link to make changes to this page or add another page.\n"})})()