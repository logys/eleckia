<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Bienvenidos on Blog sobre sistemas embebidos</title>
    <link>https://logys.github.io/eleckia/</link>
    <description>Recent content in Bienvenidos on Blog sobre sistemas embebidos</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>es-mx</language>
    <lastBuildDate>Tue, 04 Jun 2019 20:45:42 +0000</lastBuildDate><atom:link href="https://logys.github.io/eleckia/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Registros</title>
      <link>https://logys.github.io/eleckia/docs/avr/registros/</link>
      <pubDate>Sat, 25 Dec 2021 11:04:48 -0600</pubDate>
      
      <guid>https://logys.github.io/eleckia/docs/avr/registros/</guid>
      <description>Registros y Acceso #  Registros #  ¬øQu√© son los registros?, un registro es un espacio en memoria que guarda informaci√≥n, tan simple como eso. En el mundo de los microcontroladores un registro guarda la informaci√≥n que define el comportamiento del microcontrolador.
Cada perif√©rico cuenta con varios registros, listos para ser modificados y le√≠dos para adaptarlos a la soluci√≥n de un problema en particular.
En la arquitectura avr de 8 bits, los registros son de 8 bits, algunos registros se presentan como de 16 bits, pero en realidad son 2 registros de 8 bits, el tama√±o lo indica el bus de datos que en avr es de 8 bits, en otras arquitecturas donde el bus es m√°s grande los registros son de otros tama√±os.</description>
    </item>
    
    <item>
      <title>Programando Avr en C. Arreglos.</title>
      <link>https://logys.github.io/eleckia/docs/avr/programando-avr-en-c-arreglos/</link>
      <pubDate>Wed, 01 Jul 2020 23:39:42 +0000</pubDate>
      
      <guid>https://logys.github.io/eleckia/docs/avr/programando-avr-en-c-arreglos/</guid>
      <description>Los arreglos o arrays son elementos que permiten hacer colecciones de datos del tipo indicado, su uso es amplio en pr√°cticamente todos los lenguajes de programaci√≥n, en C los arreglos se declaran con la siguiente sintaxis,
tipo_dato nombre_array[TAMA√ëO]; Por ejemplo para declarar un arreglo de 5 enteros llamado horas:
int horas[5]; Para declarar un arreglo de 3 boleanos llamado respuestas:
#include&amp;lt;stdbool.h&amp;gt; bool respuestas[3]; Los arreglos pueden ser de cualquier tipo de dato.</description>
    </item>
    
    <item>
      <title>Principio de responsabilidad √∫nica (SRP)</title>
      <link>https://logys.github.io/eleckia/posts/principio-de-responsabilidad-unica-srp/</link>
      <pubDate>Sun, 28 Jun 2020 02:28:46 +0000</pubDate>
      
      <guid>https://logys.github.io/eleckia/posts/principio-de-responsabilidad-unica-srp/</guid>
      <description>En el desarrollo √°gil, el principio de responsabilidad √∫nica es uno de los cinco principios fundamentales, el principio define lo siguiente:
Un m√≥dulo debe tener un solo motivo para cambiar.
Y eso es todo, ¬øf√°cil no?, yo tambi√©n lo creo, ¬øqu√© es lo que creo?, no lo entiendo. Vamos por partes, las palabras son obvias, pero la frase es un poco ambigua, el meollo del asunto es claramente un solo motivo para cambiar, podemos apoyarnos en el nombre del principio, responsabilidad √∫nica, mmm parece ser que ambas frases se refieren a lo mismo, ¬øa qu√© mismo?</description>
    </item>
    
    <item>
      <title></title>
      <link>https://logys.github.io/eleckia/posts/464/</link>
      <pubDate>Sat, 27 Jun 2020 23:20:47 +0000</pubDate>
      
      <guid>https://logys.github.io/eleckia/posts/464/</guid>
      <description></description>
    </item>
    
    <item>
      <title>SOLID</title>
      <link>https://logys.github.io/eleckia/posts/solid/</link>
      <pubDate>Sat, 27 Jun 2020 23:19:57 +0000</pubDate>
      
      <guid>https://logys.github.io/eleckia/posts/solid/</guid>
      <description>_Soy malo y eso es bueno, yo jam√°s ser√© bueno y eso no es malo, no hay nadie que quiera ser adem√°s de mi. #  - Ralph el demoledor._
SOLID #  Dentro del mundo de la programaci√≥n existen los famosos paradigmas de programaci√≥n, entre ellos: la programaci√≥n funcional, la programaci√≥n orientada a eventos, la programaci√≥n estructurada, la programaci√≥n orientada a objetos y otros m√°s. En esta fecha 2020, la programaci√≥n orientada a objetos sin duda domina la forma en que se escribe el software en general, vale la pena aprender este paradigma pues no ser√° raro encontrarnos con programas basados en √©l.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://logys.github.io/eleckia/posts/415/</link>
      <pubDate>Sun, 24 May 2020 21:52:48 +0000</pubDate>
      
      <guid>https://logys.github.io/eleckia/posts/415/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://logys.github.io/eleckia/posts/383/</link>
      <pubDate>Sat, 23 May 2020 04:30:43 +0000</pubDate>
      
      <guid>https://logys.github.io/eleckia/posts/383/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Electr√≥nica</title>
      <link>https://logys.github.io/eleckia/posts/electronica/</link>
      <pubDate>Sat, 23 May 2020 04:30:12 +0000</pubDate>
      
      <guid>https://logys.github.io/eleckia/posts/electronica/</guid>
      <description>Ah, ¬øpero que oigo?, una intromisi√≥n, debe ser #  Lisa Simpson, la respuesta a una pregunta que
nunca hizo nadie.
-Ned Flanders
 Sigue mi blog #  Recibe nuevo contenido directamente en tu bandeja de entrada.
[jetpack_subscription_form show_only_email_and_button=&amp;ldquo;true&amp;rdquo; custom_background_button_color=&amp;ldquo;undefined&amp;rdquo; custom_text_button_color=&amp;ldquo;undefined&amp;rdquo; submit_button_text=&amp;ldquo;Suscribir&amp;rdquo; submit_button_classes=&amp;ldquo;undefined&amp;rdquo; show_subscribers_total=&amp;ldquo;false&amp;rdquo; ]</description>
    </item>
    
    <item>
      <title>Programando Avr en C.- Apuntadores, punteros, pointers III. Apuntadores Dobles.</title>
      <link>https://logys.github.io/eleckia/docs/avr/programando-avr-en-c-apuntadores-punteros-pointers-ii-apuntadores-dobles/</link>
      <pubDate>Wed, 20 May 2020 04:19:41 +0000</pubDate>
      
      <guid>https://logys.github.io/eleckia/docs/avr/programando-avr-en-c-apuntadores-punteros-pointers-ii-apuntadores-dobles/</guid>
      <description>Los apuntadores suenan bastante complejos, nuestro cerebro amplifica su complejidad, pero al igual que cualquier otra variable su funcionamiento es simple,
tipo ** nombre_apuntador; a que me refiero con apuntador doble, a un apuntador que guarda direcciones de otros apuntadores de su mismo tipo,
char caracter1 = &#39;a&#39;; char caracter2 = &#39;b&#39;; char \* letra = &amp;amp;caracter1; char \*\* apuntador\_doble = &amp;amp;letra; \*apuntador\_doble = &amp;amp;caracter2; //ahora letra apunta a la direcci√≥n de caracter2, //\*letra es &#39;b&#39; el prop√≥sito evidente de los apuntadores dobles, es cambiar el valor a donde apuntan apuntadores simples,</description>
    </item>
    
    <item>
      <title>Programando Avr en C.- Apuntadores, punteros, pointers II. Apuntadores a funciones.</title>
      <link>https://logys.github.io/eleckia/docs/avr/programando-avr-en-c-apuntadores-punteros-pointers-ii-apuntadores-a-funciones/</link>
      <pubDate>Wed, 20 May 2020 03:44:43 +0000</pubDate>
      
      <guid>https://logys.github.io/eleckia/docs/avr/programando-avr-en-c-apuntadores-punteros-pointers-ii-apuntadores-a-funciones/</guid>
      <description>Como ya he dicho un apuntador es una variable que apunta a direcciones de memoria, tambi√©n hemos mencionado que los apuntadores deben ser especificados sobre el tipo, cuando las funciones se compilan se les asigna una direcci√≥n en memoria, ¬øexistir√°n apuntadores a funciones?, la respuesta es afirmativa, la sintaxis es un poco rara,
tipo (*nombre_apuntador)(argumento1, argumento2, ..., argumento_n); al igual que los apuntadores comunes, los apuntadores a funciones deben ser especificados con el tipo de dato que regresan, entre parentesis se coloca el operador * seguido del nombre del apuntador, finalmente se especifican los par√°metros)</description>
    </item>
    
    <item>
      <title>Programando Avr en C.- Apuntadores, punteros, pointers I.</title>
      <link>https://logys.github.io/eleckia/docs/avr/programando-avr-en-c-apuntadores-punteros-pointers/</link>
      <pubDate>Sat, 16 May 2020 21:27:18 +0000</pubDate>
      
      <guid>https://logys.github.io/eleckia/docs/avr/programando-avr-en-c-apuntadores-punteros-pointers/</guid>
      <description>Los apuntadores (pienso que esta es la traducci√≥n m√°s acertada), tambi√©n conocidos como punteros o pointers en ingles, es un tipo de dato caracter√≠stico de lenguajes de bajo nivel y algunos de nivel medio, C por supuesto cuenta con tal tipo de dato.
Un apuntador es una variable cuyo tipo de dato almacena direcciones de memoria, tan simple como eso. Aunque una direcci√≥n de memoria puede ser interpretada como un entero, es mejor pensar que una direcci√≥n de memoria es un tipo de dato diferente, un tipo de dato de tipo apuntador.</description>
    </item>
    
    <item>
      <title>Contacto</title>
      <link>https://logys.github.io/eleckia/posts/contacto/</link>
      <pubDate>Fri, 15 May 2020 22:25:13 +0000</pubDate>
      
      <guid>https://logys.github.io/eleckia/posts/contacto/</guid>
      <description>Hablemos üëã. No dudes en ponerte en contacto con nosotros mediante la informaci√≥n de contacto a continuaci√≥n, o env√≠anos un mensaje mediante el formulario.
Ponte en contacto con nosotros #  Calle Ejemplo, 10
Ciudad, 10100
Espa√±a
correoelectronico@ejemplo.com
(+34) 399 555 234
Env√≠anos un mensaje #  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://logys.github.io/eleckia/posts/264/</link>
      <pubDate>Mon, 11 May 2020 06:05:40 +0000</pubDate>
      
      <guid>https://logys.github.io/eleckia/posts/264/</guid>
      <description></description>
    </item>
    
    <item>
      <title>GPIO</title>
      <link>https://logys.github.io/eleckia/posts/gpio/</link>
      <pubDate>Mon, 11 May 2020 05:51:01 +0000</pubDate>
      
      <guid>https://logys.github.io/eleckia/posts/gpio/</guid>
      <description></description>
    </item>
    
    <item>
      <title>GPIO atmega328p.</title>
      <link>https://logys.github.io/eleckia/posts/gpio-atmega328p/</link>
      <pubDate>Mon, 11 May 2020 05:26:43 +0000</pubDate>
      
      <guid>https://logys.github.io/eleckia/posts/gpio-atmega328p/</guid>
      <description>_Si, se nos acabo la duela y pintamos la tierra, ¬øqu√© trucazo no? #  Moe Szyslak_
 Sigue mi blog #  Recibe nuevo contenido directamente en tu bandeja de entrada.
[jetpack_subscription_form subscribe_placeholder=&amp;ldquo;Direcci√≥n de correo electr√≥nico&amp;rdquo; show_subscribers_total=&amp;ldquo;false&amp;rdquo; button_on_newline=&amp;ldquo;true&amp;rdquo; submit_button_text=&amp;ldquo;Suscribir&amp;rdquo; custom_background_emailfield_color=&amp;ldquo;undefined&amp;rdquo; custom_background_button_color=&amp;ldquo;undefined&amp;rdquo; custom_text_button_color=&amp;ldquo;undefined&amp;rdquo; custom_font_size=&amp;ldquo;16&amp;rdquo; custom_border_radius=&amp;ldquo;0&amp;rdquo; custom_border_weight=&amp;ldquo;1&amp;rdquo; custom_border_color=&amp;ldquo;undefined&amp;rdquo; custom_padding=&amp;ldquo;15&amp;rdquo; custom_spacing=&amp;ldquo;10&amp;rdquo; submit_button_classes=&amp;ldquo;has-text-color has-background-color has-background has-primary-background-color&amp;rdquo; email_field_classes=&amp;quot;&amp;quot; show_only_email_and_button=&amp;ldquo;true&amp;rdquo; ]</description>
    </item>
    
    <item>
      <title>Programando Avr en C.- El flujo del programa, if, else, if else.</title>
      <link>https://logys.github.io/eleckia/docs/avr/programando-avr-en-c-el-flujo-del-programa-if-else-if-else/</link>
      <pubDate>Sun, 28 Jul 2019 02:55:18 +0000</pubDate>
      
      <guid>https://logys.github.io/eleckia/docs/avr/programando-avr-en-c-el-flujo-del-programa-if-else-if-else/</guid>
      <description>Definimos el flujo del programa como, la ruta que toma la ejecuci√≥n del mismo, imaginemos que tenemos una lista de tareas que debemos ejecutar, digamos, tarea 1, tarea 2, tarea 3, &amp;hellip;, tarea n, ya vimos que podemos abstraer tareas como funciones, entonces simplemente podemos agregar cada una de las funciones en orden para ejecutarlas,
int main(void) { tarea1(); tarea2(); tarea3(); tarean(); return 0; } pero que pasa si queremos ejecutar alguna de estas tareas solo si se cumple una condici√≥n, digamos, solo si se pulsa un bot√≥n determinado, o solo si el resultado de una operaci√≥n satisface alg√∫n requerimiento.</description>
    </item>
    
    <item>
      <title>Programando Avr en C.- Constantes</title>
      <link>https://logys.github.io/eleckia/docs/avr/programando-avr-en-c-constantes/</link>
      <pubDate>Wed, 10 Jul 2019 13:23:09 +0000</pubDate>
      
      <guid>https://logys.github.io/eleckia/docs/avr/programando-avr-en-c-constantes/</guid>
      <description>Las constantes son de gran utilidad en la programaci√≥n, a diferencia de las variables, las constantes no pueden cambiar su valor.
Las dos formas m√°s comunes de definir constantes son con la palabra reservada const y con la directiva define.
La palabra const #  Agregando la palabra const a la declaraci√≥n de una variable, esta se convierte en constate, sin embargo tambi√©n debe asignarle el valor al momento de la declaraci√≥n;</description>
    </item>
    
    <item>
      <title>Programando Avr en C.- Tipo de dato Booleano, operadores booleanos y de comparaci√≥n.</title>
      <link>https://logys.github.io/eleckia/docs/avr/programando-avr-en-c-tipo-de-dato-booleano-operadores-booleanos-y-de-comparacion/</link>
      <pubDate>Tue, 09 Jul 2019 09:06:50 +0000</pubDate>
      
      <guid>https://logys.github.io/eleckia/docs/avr/programando-avr-en-c-tipo-de-dato-booleano-operadores-booleanos-y-de-comparacion/</guid>
      <description>Tipo de dato Booleano #  Otro tipo de datos b√°sico es el tipo booleano, este tipo de dato puede contener unicamente dos valores, verdadero(true) o Falso(false), para tener acceso a este tipo de dato debemos incluir la biblioteca stdbool.h, la sintaxis es:
#include&amp;lt;stdbool.h&amp;gt; //Para declarar una variable bool un\_nombre; //Para definir un valor un\_nombre = true; un\_nombre = false; Es com√∫n asumir en C que cualquier valor diferente de cero o NULL es verdadero, sin embargo pienso que es mejor utilizar expl√≠citamente los valores true o false para denotar valores booleanos, por razones de legibilidad.</description>
    </item>
    
    <item>
      <title>Funciones</title>
      <link>https://logys.github.io/eleckia/docs/avr/funciones/</link>
      <pubDate>Sun, 07 Jul 2019 20:09:49 +0000</pubDate>
      
      <guid>https://logys.github.io/eleckia/docs/avr/funciones/</guid>
      <description>Funciones en C #  Las funciones son caracter√≠sticas fundamentales de cualquier lenguaje de programaci√≥n, inclusive existe un paradigma de programaci√≥n llamado programaci√≥n funcional, veamos brevemente como funcionan las funciones en C. Una funci√≥n tiene la siguiente sintaxis en C,
tipo_de_retorno nombre_de_funcion(tipo_dato argumento_n) { ... hacer_tareas ... return un_objeto_del_tipo_de_retorno; } Las funciones son usadas como una forma de separar o estratificar tareas, pueden recibir &amp;ldquo;n&amp;rdquo; cantidad de argumentos y pueden retornar o no un valor, un ejemplo sencillo, definimos la funci√≥n suma,</description>
    </item>
    
    <item>
      <title>Api Display Siete Segmentos</title>
      <link>https://logys.github.io/eleckia/docs/perifericos/gpio/biblioteca7/</link>
      <pubDate>Wed, 19 Jun 2019 04:37:56 +0000</pubDate>
      
      <guid>https://logys.github.io/eleckia/docs/perifericos/gpio/biblioteca7/</guid>
      <description>Api para un display de siete segmentos #  Escribamos una biblioteca/api sencilla que nos permita configurar un n√∫mero en un display de 7 segmentos, el circuito es el siguiente,
Conexi√≥n Arduino-Display #  Contamos con un display de c√°todo com√∫n por lo tanto cada segmento se enciende con un voltaje alto en el pin correspondiente, es decir para encender el segmento &amp;ldquo;A&amp;rdquo; debemos configurar el pin digital D2 en alto.</description>
    </item>
    
    <item>
      <title>Electr√≥nica b√°sica.- Display de 7 segmentos.</title>
      <link>https://logys.github.io/eleckia/posts/electronica-basica-display-de-7-segmentos/</link>
      <pubDate>Sat, 15 Jun 2019 19:19:11 +0000</pubDate>
      
      <guid>https://logys.github.io/eleckia/posts/electronica-basica-display-de-7-segmentos/</guid>
      <description>Un display de 7 segmentos es un arreglo de leds distribuidos de una manera determinada, 8 leds en total, el display de 7 segmentos tiene el prop√≥sito de mostrar caracteres, usualmente n√∫meros pero tambi√©n puede mostrar letras.
Display 7 segmentos
el circuito equivalente es muy sencillo,
C√°todo com√∫n
esta configuraci√≥n es llamada c√°todo com√∫n, puesto que el c√°todo de todos los diodos est√° en corto circuito, es una buena caracter√≠stica pues tenemos un solo pin para todos los c√°todos y podemos usar un solo cable para la conexi√≥n en lugar de ocho.</description>
    </item>
    
    <item>
      <title>Electr√≥nica b√°sica.- Led y su resistencia.</title>
      <link>https://logys.github.io/eleckia/posts/electronica-basica-led-y-su-resistencia/</link>
      <pubDate>Fri, 14 Jun 2019 18:54:50 +0000</pubDate>
      
      <guid>https://logys.github.io/eleckia/posts/electronica-basica-led-y-su-resistencia/</guid>
      <description>La ley de Ohm es una herramienta fundamental en la electr√≥nica, en esta ocasi√≥n vamos a calcular la resistencia adecuada para que un diodo pueda operar de forma segura.
Antes que nada definamos que es un diodo, sin entrar en detalles, un diodo es un dispositivo que permite el flujo de corriente en una sola direcci√≥n, cuenta con dos terminales, el √°nodo y el c√°todo, la regla es que si se conecta un voltaje alto al √°nodo y uno bajo al c√°todo, entonces fluye corriente, esta operaci√≥n del diodo se conoce como polarizaci√≥n directa, si se invierten las conexiones se dice que el diodo esta polarizado en inversa y no fluye corriente.</description>
    </item>
    
    <item>
      <title>res</title>
      <link>https://logys.github.io/eleckia/posts/bloque-reutilizable-sin-titulo-2/</link>
      <pubDate>Fri, 14 Jun 2019 18:54:33 +0000</pubDate>
      
      <guid>https://logys.github.io/eleckia/posts/bloque-reutilizable-sin-titulo-2/</guid>
      <description>La ley de Ohm es una herramienta fundamental en la electr√≥nica, en esta ocasi√≥n vamos a calcular la resistencia adecuada para que un diodo pueda operar de forma segura.
Antes que nada definamos que es un diodo, sin entrar en detalles, un diodo es un dispositivo que permite el flujo de corriente en una sola direcci√≥n, cuenta con dos terminales, el √°nodo y c√°todo, la regla es que si se conecta un voltaje alto al √°nodo y uno bajo al c√°todo, entonces fluye corriente, esta operaci√≥n del diodo se conoce como polarizaci√≥n directa, si se invierten las conexiones se dice que el diodo esta polarizado en inversa y no fluye corriente.</description>
    </item>
    
    <item>
      <title>Variables y tipos</title>
      <link>https://logys.github.io/eleckia/docs/avr/primitivos/</link>
      <pubDate>Fri, 14 Jun 2019 02:32:35 +0000</pubDate>
      
      <guid>https://logys.github.io/eleckia/docs/avr/primitivos/</guid>
      <description>Variables y tipos primitivos #  El lenguaje de programaci√≥n C, es un lenguaje de tipado est√°tico, esto quiere decir que nosotros debemos indicar el tipo de dato que guarda una variable.
¬øQu√© es una variable?, puede decirse que una variable es un espacio en memoria que guarda un valor determinado, y ¬øqu√© es un tipo?, por tipo de se entiende a una indicaci√≥n hacia el compilador de como se utilizar√° el dato.</description>
    </item>
    
    <item>
      <title>Puertos de entrada/salida de prop√≥sito general (GPIO)</title>
      <link>https://logys.github.io/eleckia/docs/perifericos/gpio/gpio/</link>
      <pubDate>Thu, 13 Jun 2019 19:18:09 +0000</pubDate>
      
      <guid>https://logys.github.io/eleckia/docs/perifericos/gpio/gpio/</guid>
      <description>Puertos de entrada/salida de prop√≥sito general. #  Cando pensamos en programar microcontroladores, lo que queremos es hacer que el mundo se mueva, controlar un motor, un relevador, una lampara, altavoz, etc. Para ello los microcontroladores cuentan con una serie de perif√©ricos. A grandes rasgos un perif√©rico puede definirse como: una interfaz que permite al microcontrolador comunicarse con el exterior, en esta entrada describiremos los puertos de entrada/salida de prop√≥sito general; GPIOx.</description>
    </item>
    
    <item>
      <title>Electr√≥nica B√°sica.- Voltaje, Corriente, resistencia y ley de Ohm.</title>
      <link>https://logys.github.io/eleckia/posts/electronica-basica-voltaje-corriente-resistencia-y-ley-de-ohm/</link>
      <pubDate>Tue, 11 Jun 2019 14:56:24 +0000</pubDate>
      
      <guid>https://logys.github.io/eleckia/posts/electronica-basica-voltaje-corriente-resistencia-y-ley-de-ohm/</guid>
      <description>Cuando la gente de computaci√≥n escucha las palabras en el titulo de esta entrada, suele entrar en p√°nico y no es para menos, el an√°lisis de circuitos el√©ctricos puede llegar a ser muy complejo; sin embargo la electr√≥nica descansa sobre una ley simple, la ley de Ohm,
$latex V = iR$
la ley de Ohm relaciona el voltaje con la corriente y la resistencia; pero esto no nos dice nada si no entendemos estos t√©rminos, comencemos con el voltaje, tambi√©n llamado tensi√≥n o potencial el√©ctrico, en la f√≠sica,</description>
    </item>
    
    <item>
      <title>¬øQu√© son los registros en un microcontrolador?</title>
      <link>https://logys.github.io/eleckia/posts/que-son-los-registros-en-un-microcontrolador/</link>
      <pubDate>Sat, 08 Jun 2019 15:46:28 +0000</pubDate>
      
      <guid>https://logys.github.io/eleckia/posts/que-son-los-registros-en-un-microcontrolador/</guid>
      <description>Hemos hablado acerca de los registros en anteriores entradas, vamos a profundizar un poco en el tema.
Para entender un registro, definamos que es un bit, la palabra tiene varias acepciones, para nuestro prop√≥sito un bit es la representaci√≥n de un valor binario, este puede ser 1 o 0. Entonces un registro es sencillamente un conjunto de bits, en nuestro microcontrolador atmega328p, existen registros de 8bits, en otras arquitecturas como los cortex-m los registros son de 32 bits, algunos como el msp de texas instruments, tienen registros de 16 bits.</description>
    </item>
    
    <item>
      <title>Programando Avr en C.- Blinky</title>
      <link>https://logys.github.io/eleckia/docs/avr/iniciando/</link>
      <pubDate>Thu, 06 Jun 2019 21:11:38 +0000</pubDate>
      
      <guid>https://logys.github.io/eleckia/docs/avr/iniciando/</guid>
      <description>Comenzando con avr y C #  Para iniciar en la programaci√≥n de dispositivos avr, se requieren algunas cosas:
 Un compilador de C y sus utilidades para avr:  Aunque existen varios compiladores disponibles, avr_gcc es el que se encuentra en la mayor√≠a de los proyectos.   Un editor de texto:  Nuevamente hay muchas opciones, en lo personal prefiero vim.   avrdude, este programa nos ayuda a subir el c√≥digo al microcontrolador.</description>
    </item>
    
    <item>
      <title>save</title>
      <link>https://logys.github.io/eleckia/posts/bloque-reutilizable-sin-titulo/</link>
      <pubDate>Thu, 06 Jun 2019 00:35:42 +0000</pubDate>
      
      <guid>https://logys.github.io/eleckia/posts/bloque-reutilizable-sin-titulo/</guid>
      <description>El siguiente paso obvio es analizar el programa Blink, sin embargo aqu√≠ no usaremos las bibliotecas de Arduino, usaremos c√≥digo c para dispositivos AVR, entonces ¬øpara que tanto problema instalando la maquina virtual y Arduino?, simplemente porque utilizaremos la infraestructura ya hecha para nuestro prop√≥sito, abrimos el ejemplo Blink y reemplazamos el c√≥digo por:
#include&amp;lt;avr/io.h&amp;gt; #include&amp;lt;util/delay.h&amp;gt; int main(void) { DDRB = 1 &amp;lt;&amp;lt; PB5; PORTB = 0; while(1){ PORTB |= 1 &amp;lt;&amp;lt; PB5; \_delay\_ms(1000); PORTB &amp;amp;= ~(1&amp;lt;&amp;lt;PB5); \_delay\_ms(1000); } } compilamos y subimos el c√≥digo, el comportamiento es exactamente el mismo, pero el c√≥digo es totalmente C y no C++, tambi√©n evitamos el uso de las bibliotecas de Arduino en favor de las avr.</description>
    </item>
    
    <item>
      <title>Arduino</title>
      <link>https://logys.github.io/eleckia/docs/workstation/arduino/</link>
      <pubDate>Wed, 05 Jun 2019 19:07:30 +0000</pubDate>
      
      <guid>https://logys.github.io/eleckia/docs/workstation/arduino/</guid>
      <description>Arduino #  Arduino se compone tanto de software como de hardware, miremos un poco el hardware.
Hardware #  El Arduino Uno (placa de desarrollo), cuenta con un puerto usb, por el que se alimenta la placa; enviamos y recibimos datos, este puerto esta conectado a un circuito integrado FTDI que no es m√°s que un convertidor serial-usb, igualmente este convertidor se conecta a unos pines espec√≠ficos del microcontrolador. Lo importante a destacar es que esta conexi√≥n ya esta hecha y es perfectamente funcional, permitiendo la conexi√≥n entre la placa y pc sin mayores complicaciones, esta es sin duda la gran caracter√≠stica que dio paso al √©xito, una plataforma lista para usarse sin necesidad de componentes adicionales.</description>
    </item>
    
    <item>
      <title>Estaci√≥n de trabajo</title>
      <link>https://logys.github.io/eleckia/docs/workstation/estacion-de-trabajo/</link>
      <pubDate>Tue, 04 Jun 2019 22:52:26 +0000</pubDate>
      
      <guid>https://logys.github.io/eleckia/docs/workstation/estacion-de-trabajo/</guid>
      <description>Estaci√≥n de trabajo #  No es obligatorio instalar Fedora, pero todos los ejemplos se har√°n desde este sistema operativo, eres libre de adaptar lo que aqu√≠ se mencione a tus circunstancias.
Para poder trabajar a gusto es necesario disponer de un conjunto de herramientas adecuado, dejando de lado el tipo de computadora con la que se cuenta, lo importante es el sistema operativo, utilizaremos software libre, nuestro sistema operativo sera linux, concretamente Fedora, esta distribuci√≥n cuenta con los paquetes necesarios para desarrollar software c√≥modamente, as√≠ que si utilizas algo diferente comienza borrado tu disco duro e instala Fedora (obviamente esto es broma :D).</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://logys.github.io/eleckia/posts/about/</link>
      <pubDate>Sun, 20 Sep 2015 19:44:10 +0000</pubDate>
      
      <guid>https://logys.github.io/eleckia/posts/about/</guid>
      <description>This is an example of a page. Unlike posts, which are displayed on your blog‚Äôs front page in the order they‚Äôre published, pages are better suited for more timeless content that you want to be easily accessible, like your About or Contact information. Click the Edit link to make changes to this page or add another page.</description>
    </item>
    
  </channel>
</rss>
