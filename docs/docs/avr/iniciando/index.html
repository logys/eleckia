<!DOCTYPE html>
<html lang="es" dir="ltr">

<head>
  <meta name="generator" content="Hugo 0.80.0" />
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Comenzando con avr y C #  Para iniciar en la programación de dispositivos avr, se requieren algunas cosas:
 Un compilador de C y sus utilidades para avr:  Aunque existen varios compiladores disponibles, avr_gcc es el que se encuentra en la mayoría de los proyectos.   Un editor de texto:  Nuevamente hay muchas opciones, en lo personal prefiero vim.   avrdude, este programa nos ayuda a subir el código al microcontrolador.">
<meta name="theme-color" content="#FFFFFF"><meta property="og:title" content="Programando Avr en C.- Blinky" />
<meta property="og:description" content="Comenzando con avr y C #  Para iniciar en la programación de dispositivos avr, se requieren algunas cosas:
 Un compilador de C y sus utilidades para avr:  Aunque existen varios compiladores disponibles, avr_gcc es el que se encuentra en la mayoría de los proyectos.   Un editor de texto:  Nuevamente hay muchas opciones, en lo personal prefiero vim.   avrdude, este programa nos ayuda a subir el código al microcontrolador." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://logys.github.io/eleckia/docs/avr/iniciando/" />
<meta property="article:published_time" content="2019-06-06T21:11:38+00:00" />
<meta property="article:modified_time" content="2019-06-06T21:11:38+00:00" />
<title>Programando Avr en C.- Blinky | Blog sobre sistemas embebidos</title>
<link rel="manifest" href="/eleckia/manifest.json">
<link rel="icon" href="/eleckia/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/eleckia/book.min.e935e20bd0d469378cb482f0958edf258c731a4f895dccd55799c6fbc8043f23.css" integrity="sha256-6TXiC9DUaTeMtILwlY7fJYxzGk&#43;JXczVV5nG&#43;8gEPyM=">
<script defer src="/eleckia/es.search.min.1fb21b7378979348942bec50cb4a8097e5e2d5182cd4922354f0cded7ebddf5a.js" integrity="sha256-H7Ibc3iXk0iUK&#43;xQy0qAl&#43;Xi1Rgs1JIjVPDN7X6931o="></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a href="/eleckia"><span>Blog sobre sistemas embebidos</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Buscar" aria-label="Buscar" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>











  



  
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-6f6f484549ce2d8602f7989616e2f29f" class="toggle"  />
    <label for="section-6f6f484549ce2d8602f7989616e2f29f" class="flex justify-between">
      <a href="https://logys.github.io/eleckia/docs/workstation/" class="">Estación de trabajo</a>
      <span>▾</span>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://logys.github.io/eleckia/docs/workstation/arduino/" class="">Arduino</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://logys.github.io/eleckia/docs/workstation/estacion-de-trabajo/" class="">Estación de trabajo</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-c5a8f28f5516b1587793df786fc2352d" class="toggle" checked />
    <label for="section-c5a8f28f5516b1587793df786fc2352d" class="flex justify-between">
      <a href="https://logys.github.io/eleckia/docs/avr/" class="">Programación Avr en C.</a>
      <span>▾</span>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://logys.github.io/eleckia/docs/avr/registros/" class="">Registros</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://logys.github.io/eleckia/docs/avr/programando-avr-en-c-arreglos/" class="">Programando Avr en C. Arreglos.</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://logys.github.io/eleckia/docs/avr/programando-avr-en-c-apuntadores-punteros-pointers-ii-apuntadores-dobles/" class="">Programando Avr en C.- Apuntadores, punteros, pointers III. Apuntadores Dobles.</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://logys.github.io/eleckia/docs/avr/programando-avr-en-c-apuntadores-punteros-pointers-ii-apuntadores-a-funciones/" class="">Programando Avr en C.- Apuntadores, punteros, pointers II. Apuntadores a funciones.</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://logys.github.io/eleckia/docs/avr/programando-avr-en-c-apuntadores-punteros-pointers/" class="">Programando Avr en C.- Apuntadores, punteros, pointers I.</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://logys.github.io/eleckia/docs/avr/programando-avr-en-c-el-flujo-del-programa-if-else-if-else/" class="">Programando Avr en C.- El flujo del programa, if, else, if else.</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://logys.github.io/eleckia/docs/avr/programando-avr-en-c-constantes/" class="">Programando Avr en C.- Constantes</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://logys.github.io/eleckia/docs/avr/programando-avr-en-c-tipo-de-dato-booleano-operadores-booleanos-y-de-comparacion/" class="">Programando Avr en C.- Tipo de dato Booleano, operadores booleanos y de comparación.</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://logys.github.io/eleckia/docs/avr/funciones/" class="">Funciones</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://logys.github.io/eleckia/docs/avr/primitivos/" class="">Variables y tipos</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://logys.github.io/eleckia/docs/avr/iniciando/" class=" active">Programando Avr en C.- Blinky</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Perifericos</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-32e0e2a16668b9d33b9df31ea5765d8c" class="toggle"  />
    <label for="section-32e0e2a16668b9d33b9df31ea5765d8c" class="flex justify-between">
      <a  class="">GPIO</a>
      <span>▾</span>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://logys.github.io/eleckia/docs/perifericos/gpio/biblioteca7/" class="">Api Display Siete Segmentos</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://logys.github.io/eleckia/docs/perifericos/gpio/gpio/" class="">Puertos de entrada/salida de propósito general (GPIO)</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>















</nav>




  <script>(function(){var a=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(b){localStorage.setItem("menu.scrollTop",a.scrollTop)}),a.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/eleckia/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>Programando Avr en C.- Blinky</strong>

  <label for="toc-control">
    
    <img src="/eleckia/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#escribiendo-el-programa">Escribiendo el programa</a></li>
    <li><a href="#compilando">Compilando</a></li>
    <li><a href="#grabando">Grabando</a></li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown"><h1 id="comenzando-con-avr-y-c">
  Comenzando con avr y C
  <a class="anchor" href="#comenzando-con-avr-y-c">#</a>
</h1>
<p>Para iniciar en la programación de dispositivos avr, se requieren algunas
cosas:</p>
<ul>
<li>Un compilador de C y sus utilidades para avr:
<ul>
<li>Aunque existen varios compiladores disponibles, <strong>avr_gcc</strong> es el que
se encuentra en la mayoría de los proyectos.</li>
</ul>
</li>
<li>Un editor de texto:
<ul>
<li>Nuevamente hay muchas opciones, en lo personal prefiero vim.</li>
</ul>
</li>
<li><strong>avrdude</strong>, este programa nos ayuda a subir el código al microcontrolador.</li>
</ul>
<h2 id="escribiendo-el-programa">
  Escribiendo el programa
  <a class="anchor" href="#escribiendo-el-programa">#</a>
</h2>
<p>Comenzamos creando un fichero llamado blinky.c, dentro del cual agregamos:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;avr/io.h&gt;</span><span style="color:#75715e">
</span></code></pre></div><p>La directiva <em>&ldquo;include&lt;&gt;</em> copia el contenido del fichero indicado, en nuestro
fichero blinky.c, en este caso copia el contenido del fichero <em>io.h</em> que se
encuentra dentro del directorio <em>avr</em>, no nos interesa la ubicación del
directorio avr, el compilador sabe donde se encuentra y lo incluye de manera
automática. Lo que si nos interesa saber es que incluir el fichero io.h nos
permite acceder a los registros que controlan los pines del microcontrolador.</p>
<p>Posteriormente tenemos la función <strong>main</strong>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>)
{
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>La función main es un ente
importante, cuando el programa se ejecuta, la función main es llamada
automáticamente, el código dentro de las llaves se ejecutara línea por
línea, lo que esté fuera de dicha función deberá ser llamado explícitamente para
poder ejecutarse. Por definición la función main retorna un entero al finalizar
y en el caso de microcontroladores no suele recibir argumentos por eso la
palabra void (más adelante analizaremos la estructura de las funciones).</p>
<p>Después viene el <strong>superloop</strong>,</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>)
{
	<span style="color:#66d9ef">while</span>(<span style="color:#ae81ff">1</span>){
		<span style="color:#75715e">//tareas
</span><span style="color:#75715e"></span>	}
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>El superloop es un ciclo infinito que se ejecuta dentro del main, en general
las tareas deben definirse dentro del loop de tal forma que se repitan una
y otra vez.</p>
<p>Finalmente tenemos un retorno, como nuestro programa se queda &ldquo;ciclado&rdquo; dentro
del while, nunca alcanzaremos esta línea, sin embargo es conveniente poner esta
línea o el compilador nos dará una advertencia.</p>
<p>Ya estamos un poco más familiarizados con la estructura del programa,
ahora si analicemos el programa Blink,</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;avr/io.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;util/delay.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>)
{
        DDRB <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">&lt;&lt;</span>PB5;
        PORTB <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

        <span style="color:#66d9ef">while</span>(<span style="color:#ae81ff">1</span>){
                PORTB <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">&lt;&lt;</span>PB5;
                _delay_ms(<span style="color:#ae81ff">1000</span>);
                PORTB <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
                _delay_ms(<span style="color:#ae81ff">1000</span>);
        }
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>Al inicio tenemos dos directivas include, la primera io.h, nos permite acceder
a los registros de los puertos de nuestro microcontrolador, en este caso el
puerto B, haré una entrada especifica para este tema, la segunda delay.h nos
permite usar la función <em>_delay_ms</em>, que como deducirás nos permite crear un
tiempo muerto.</p>
<p>Iniciamos con la función main y lo primero que tenemos es una asignación,
te preguntaras que es DDRB, para entenderlo primero debo explicar que es un
registro y lo explicare en una entrada dedicada, por ahora vamos a decir que
DDRB es una variable a secas, a esta variable le asignamos el resultado de una
operación <em>1&laquo;PB5</em>, el símbolo &ldquo;&laquo;&rdquo; es un operado binario llamado left shift o
corrimiento a la izquierda, indica que el número a la izquierda sera recorrido
el número de veces que tiene a la derecha en binario, por ejemplo</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Bash" data-lang="Bash"><span style="color:#ae81ff">3</span> en binario es 0b0011
Aplicar un corrimiento a la izquierda en una unidad implica:
3<span style="color:#e6db74">&lt;&lt;1
</span><span style="color:#e6db74">es exactamente igual a:
</span><span style="color:#e6db74">0b001</span>1<span style="color:#e6db74">&lt;&lt;1 
</span><span style="color:#e6db74">y da como resultado 
</span><span style="color:#e6db74">0b01</span><span style="color:#ae81ff">10</span> 
en decimal <span style="color:#ae81ff">6</span>
</code></pre></div><p>En nuestro caso, casi siempre usaremos un 1 a la izquierda del operador, por lo tanto</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Bash" data-lang="Bash"><span style="color:#ae81ff">1</span> en binario es 0b1
1<span style="color:#e6db74">&lt;&lt;1 da como resultado     0b1</span><span style="color:#ae81ff">0</span>
1&lt;&lt;<span style="color:#ae81ff">2</span> da como resultado    0b100
1&lt;&lt;<span style="color:#ae81ff">3</span> da como resultado   0b1000
1&lt;&lt;<span style="color:#ae81ff">7</span> da como result. 0b10000000
</code></pre></div><p>Realmente no nos interesa el valor en decimal, lo que nos interesa es donde queda
posicionado el 1, al final de la operación con 1&laquo;2, el 1 queda posicionado en la
tercera de derecha a izquierda, con 1&laquo;7, queda en la octava de derecha a izquierda.</p>
<p>¿Para que es esto?, DDRB es una &ldquo;variable&rdquo; que le indica al microcontrolador si
el pin es de entrada o de salida, si el bit es cero, el pin operara como entrada,
de lo contrario opera como salida. DDRB contiene 8 bits y cada bit corresponde
a un pin de nuestro microcontrolador, al inicio contiene el valor binario
0b0000 0000, si revisas la hoja de datos de tu microcontrolador te darás
cuenta que los pines están rotulados con las leyendas PA0, PB0, PC0, PA1, etc,
estos son los &ldquo;nombres&rdquo; de los pines y A,B,C, es el puerto al que pertenecen,
por lo tanto el pin 5 del puerto B se llama PB5.</p>
<p>El pin PB5 esta conectado al led de nuestra tarjeta, hay que decirle a DDRB
que ponga el pin 5 como salida, tan fácil como:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C">DDRB <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">&lt;&lt;</span>PB5;
<span style="color:#75715e">//que es exactamente igual a
</span><span style="color:#75715e"></span>DDRB <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>b00100000;
<span style="color:#75715e">//bit    76543210
</span></code></pre></div><p>Lo anterior tiene la desventaja de poner al resto de pines como entrada, por
ahora no es un problema, pero no es la forma correcta, en otra entrada se
dará la forma correcta.</p>
<p>Seguimos adelante y tenemos otra asignación, PORTB es otro registro, de igual
forma asumiremos por ahora que es una variable, controla el estado del pin,
el estado puede ser 0 para bajo o 1 para alto, en síntesis cuando el pin se
configura en alto tendrá 5 volts y cuando se configura en bajo tendrá 0 volts,
cuando necesitemos encender el led lo configuramos como alto con</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C">PORTB <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">&lt;&lt;</span>PB5;
<span style="color:#75715e">//que es exactamente igual a
</span><span style="color:#75715e"></span>PORTB <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>b00100000;
</code></pre></div><p>¿y si queremos ponerlo en bajo?, por ahora solo esto,</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C">PORTB <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
<span style="color:#75715e">//que es exactamente igual a
</span><span style="color:#75715e"></span>PORTB <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>b00000000;
</code></pre></div><p>Siguiendo con el programa, entramos al ciclo infinito en donde la parte
interesante es la función <em>_delay_ms()</em>, la función se explica por si misma,
cuando se llama toma el control de la ejecución del programa y espera la
cantidad de tiempo indicada en milisegundos, 1000 para este ejemplo, pasado este
tiempo la función termina y sigue con la ejecución del programa.</p>
<p>El programa se queda en este bucle encendiendo y apagando el led cada dos
segundos.</p>
<h2 id="compilando">
  Compilando
  <a class="anchor" href="#compilando">#</a>
</h2>
<p>Si no tenemos instalado avr_gcc, en una terminal:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Bash" data-lang="Bash">$ sudo dnf install avr-gcc
</code></pre></div><p>El proceso de compilación es simple, abrimos una terminal, nos dirigimos al
directorio donde
se encuentra nuestro fichero y escribimos:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Bash" data-lang="Bash">$ avr-gcc -mmcu<span style="color:#f92672">=</span>atmega328p blinky.c
</code></pre></div><p>El compilador generará un archivo ejecutable en formato elf: a.out,
sin embargo se requiere convertir este fichero a otro formato antes de
poder grabarlo en el microcontrolador. El archivo a.out contiene información
adicional a las instrucciones del programa, para &ldquo;filtrar&rdquo; la información
relevante:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Bash" data-lang="Bash">$ avr-objcopy -O ihex a.out blinky.hex
</code></pre></div><p>La herramienta <em>avr-objcopy</em> extrae las instrucciones y las coloca en el
fichero blinky.hex.</p>
<h2 id="grabando">
  Grabando
  <a class="anchor" href="#grabando">#</a>
</h2>
<p>Finalmente utilizamos la herramienta <em>avrdude</em> para grabar el programa</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Bash" data-lang="Bash">$ avrdude -c arduino -P /dev/ttyACM0 -p m328p -U flash:w:blinky.hex
</code></pre></div><p>Un par de segundos después el led del arduino comenzara a parpadear cada dos
segundos.</p>
<p>El parámetro -P /dev/ttyACM0 indica el puerto, desafortunadamente no siempre
es el mismo, también puede ser /dev/ttyUSB0 o algún otro, pero por lo general
es alguno de esos dos.</p>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>

 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#escribiendo-el-programa">Escribiendo el programa</a></li>
    <li><a href="#compilando">Compilando</a></li>
    <li><a href="#grabando">Grabando</a></li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>

</html>












