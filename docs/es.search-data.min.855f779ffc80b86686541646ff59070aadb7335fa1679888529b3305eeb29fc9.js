'use strict';(function(){const b={cache:!0};b.doc={id:'id',field:['title','content'],store:['title','href','section']};const a=FlexSearch.create('balance',b);window.bookSearchIndex=a,a.add({id:0,href:'/eleckia/docs/workstation/',title:"Estaci√≥n de trabajo",section:"Docs",content:"Hay que trabajar, hay que aprender, hay que comer, hay que descansar y tambi√©n hay que jugar, esas son las bases del entrenamiento del maestro Roshi para tener una buena condici√≥n.\n-Kame Sennin.\n"}),a.add({id:1,href:'/eleckia/docs/avr/',title:"Programaci√≥n Avr en C.",section:"Docs",content:"Una l√≠nea de Othello sobre un bebedor, ahora un hombre sensible; por el alcohol se convierte en bestia, eso lo explica todo.\nBarney G√≥mez.\n"}),a.add({id:2,href:'/eleckia/docs/avr/registros/',title:"Registros",section:"Programaci√≥n Avr en C.",content:"Registros y Acceso #  Registros #  ¬øQu√© son los registros?, un registro es un espacio en memoria que guarda informaci√≥n, tan simple como eso. En el mundo de los microcontroladores un registro guarda la informaci√≥n que define el comportamiento del microcontrolador.\nCada perif√©rico cuenta con varios registros, listos para ser modificados y le√≠dos para adaptarlos a la soluci√≥n de un problema en particular.\nEn la arquitectura avr de 8 bits, los registros son de 8 bits, algunos registros se presentan como de 16 bits, pero en realidad son 2 registros de 8 bits, el tama√±o lo indica el bus de datos que en avr es de 8 bits, en otras arquitecturas donde el bus es m√°s grande los registros son de otros tama√±os.\nLa programaci√≥n de sistemas embebidos mucho tiene que ver con modificar registros, esta es la principal diferencia aunque no la √∫nica con respecto a programa en software de alto nivel.\nAcceso #  Entendido lo que es un registro, veamos como modificarlo.\nYa hemos utilizado registros, por ejemplo DDRB, data direction register del puerto B, establece a los pines como entrada o salida:\n//Establece el pin 5 del puerto B como salida y el resto como entradas DDRB = 0b00100000; sin embargo la sintaxis 0bxxxx no es est√°ndar, √∫nicamente esta disponible via avr-libc, que es la biblioteca principal utilizada por avr-gcc, lo que implica que nuestro c√≥digo no sea portable si usamos esta sintaxis.\nOtra forma de abordar la asignaci√≥n es por medio de la notaci√≥n hexadecimal,\n//0b0010 0000; // 2 0	DDRB = 0x20; El n√∫mero binario se divide en dos cuartetos y cada uno representa un n√∫mero en hexadecimal, esto es cierto debido a las propiedades de las bases binarias y hexadecimal, es una forma estandarizada de asignaci√≥n y es ampliamente utilizada, operaciones con datos de 8 bits son f√°ciles pero cuando los registros son de 32 bits por ejemplo, las conversiones son m√°s complicadas y se suelen cometer errores, existe otra forma de abordar el problema\nbitwise Corrimiento a la izquierda #  El operador \u0026laquo; corrimiento a la izquierda es un gran aliado para resolver este problema:\n//0b0010 0000; DDRB = 1\u0026lt;\u0026lt;5; Recorre el n√∫mero a la izquierda del operador el n√∫mero de veces indicado a la derecha del operador, en este caso recorre el n√∫mero 1, 5 veces a la izquierda, el corrimiento se hace en la forma binaria del n√∫mero a la izquierda:\nDDRB = 3\u0026lt;\u0026lt;1; //Daria como resultado 0b110 (6 en decimal) no 30 en decimal  DDRB = 1\u0026lt;\u0026lt;PB5; //Lo que nos intersa es que el 1 quede en la posici√≥n PB5 Sin embargo el problema de modificar el resto de pines del registro persiste, veamos la soluci√≥n a este problema.\nEstablecer un bit #  El operado binario or | es perfecto para solucionar el problema, el operador |, opera en dos n√∫meros binarios con la regla:\n0 or 0 = 0 1 or 0 = 1 0 or 1 = 1 1 or 1 = 1 Por ejemplo, para los n√∫meros binarios, 100 y 010, el resultado de hacer un or bit a bit es\nbit2 bit1 bit0 1 0 0 or or or 0 1 0 -------------- 1 1 0 Resultado Asumiendo que el registro DDRB contiene el valor 0000 0111, es decir los 3 primeros bits est√°n configurados como salidas, requerimos hacer que el bit correspondiente a PB5 sea 1, sin modificar el resto, para ello usamos la sintaxis,\nDDRB = DDRB | (1\u0026lt;\u0026lt;PB5); //Es igual a DDRB = 0b00000111 | 0b00100000; //despues de hacer or, resulta DDRB = 0b00100111; //DDRB queda con el bit PB5 en 1 y el resto sin modificar Una notaci√≥n m√°s compacta y equivalente es:\nDDRB |= 1\u0026lt;\u0026lt;PB5; Tambi√©n es posible encadenar varios pines:\nDDRB |= 1\u0026lt;\u0026lt;PB5 | 1\u0026lt;\u0026lt;PB0 | 1\u0026lt;\u0026lt;PB3; Limpiar un bit #  Con limpiar un bit me refiero a ponerlo en cero, para ello el operador binario and \u0026amp; es el indicado, el operado \u0026amp; opera con dos n√∫meros binarios con la regla:\n0 and 0 = 0 0 and 1 = 0 1 and 0 = 0 1 and 1 = 1 Por ejemplo en los siguientes n√∫meros binarios el resultado es,\nbit2 bit1 bit0 1 0 0 and 0 1 0 -------------- 0 0 0 Resultado Otro operador (en este caso unario) importante es el complemento a uno ~, cambia el valor de 1 a 0 y de 0 a 1, por ejemplo:\n1010 ~ ----- 0101 Resultado Asumiendo que el registro DDRC contiene el n√∫mero 0b0010 0011, requerimos configurar el pin PC0 como entrada, asignar DDRC = 0 no es aceptable (colocar√≠a todos los pines como entrada), en su lugar usaremos el siguiente c√≥digo\nDDRC = DDRC \u0026amp; ~(1\u0026lt;\u0026lt;PC0); //Primero se realiza (1\u0026lt;\u0026lt;PC0), resulta DDRC = DDRC \u0026amp; ~0b00000001; //Ahora se aplica el operador complemento, resulta DDRC = DDRC \u0026amp; 0b11111110; //Operador And bit a bit, DDRC = 0b00100011 \u0026amp; 0b11111110; //Resulta DDRC = 0b00100010; De esta forma logramos establecer el pin requerido sin afectar el resto. Por supuesto tambi√©n se pueden limpiar varios pines:\nDDRC \u0026amp;= ~(1\u0026lt;\u0026lt;PC0 | 1\u0026lt;\u0026lt;PC1 | 1\u0026lt;\u0026lt;PC5); "}),a.add({id:3,href:'/eleckia/docs/avr/programando-avr-en-c-arreglos/',title:"Programando Avr en C. Arreglos.",section:"Programaci√≥n Avr en C.",content:"Los arreglos o arrays son elementos que permiten hacer colecciones de datos del tipo indicado, su uso es amplio en pr√°cticamente todos los lenguajes de programaci√≥n, en C los arreglos se declaran con la siguiente sintaxis,\ntipo_dato nombre_array[TAMA√ëO]; Por ejemplo para declarar un arreglo de 5 enteros llamado horas:\nint horas[5]; Para declarar un arreglo de 3 boleanos llamado respuestas:\n#include\u0026lt;stdbool.h\u0026gt; bool respuestas[3]; Los arreglos pueden ser de cualquier tipo de dato. El n√∫mero entre corchetes (par√©ntesis cuadrados) indica la cantidad de elementos que puede almacenar, en el caso del arreglo horas, este puede almacenar hasta 5 enteros, la forma de asignar los valores es la siguiente:\nint horas[5] = {1, 2, 1, 2, 3}; //o tambi√©n int horas[5]; horas[0] = 1; horas[1] = 2; horas[2] = 1; horas[3] = 2; horas[4] = 3; Ambas asignaciones resultaran en los mismos enteros para el arreglo, n√≥tese que cuando asignamos los valores, la primera posici√≥n es cero y no uno, esto implica que la √∫ltima posici√≥n sea cuatro y no cinco, si asign√°ramos horas[5] = 4; obtendr√≠amos un error en tiempo de ejecuci√≥n, este error es muy diferente de el error en tiempo de compilaci√≥n, de hecho el programa compilara sin error, pero si se intenta ejecutar dentro del microcontrolador la ejecuci√≥n sera err√°tica, probablemente el programa se reinicie al tratar de ejecutar la instrucci√≥n o tal vez se detenga en ese instante, o tal vez no pase nada, depende de la forma en que se organiza la memoria en el micro, por lo tanto hay que tener cuidado en no rebasar el indice, el m√°ximo es igual a el tama√±o menos uno.\nArreglos y apuntadores. #  Los arreglos y apuntadores tienen una relaci√≥n importante, el nombre de un arreglo es un apuntador que apunta a la direcci√≥n del primer elemento o elemento cero,\nint numeros[2] = {1, 4}; int a = *numeros + numeros[1]; //a contendra el valor de 5 A pesar de esta equivalencia, prefiero utilizar los corchetes cuando de arreglos se trata, esto me evita la sobrecargar de conceptos en la cabeza y me permite diferenciar claramente el prop√≥sito de un arreglo y el de un apuntador, con el arreglo quiero manejar una colecci√≥n de datos, mientras que con los apuntadores quiero manejar el acceso a objetos individuales.\n"}),a.add({id:4,href:'/eleckia/posts/principio-de-responsabilidad-unica-srp/',title:"Principio de responsabilidad √∫nica (SRP)",section:"Posts",content:"En el desarrollo √°gil, el principio de responsabilidad √∫nica es uno de los cinco principios fundamentales, el principio define lo siguiente:\nUn m√≥dulo debe tener un solo motivo para cambiar.\nY eso es todo, ¬øf√°cil no?, yo tambi√©n lo creo, ¬øqu√© es lo que creo?, no lo entiendo. Vamos por partes, las palabras son obvias, pero la frase es un poco ambigua, el meollo del asunto es claramente un solo motivo para cambiar, podemos apoyarnos en el nombre del principio, responsabilidad √∫nica, mmm parece ser que ambas frases se refieren a lo mismo, ¬øa qu√© mismo?, mmm, lo que esta claro es que un m√≥dulo solo debe tener una sola responsabilidad, por ejemplo suponiendo que requerimos un sistema que controle el movimiento de un robot m√≥vil, el robot puede ir hacia adelante, atr√°s y rotar las ruedas de direcci√≥n, una forma de visualizarlo es la siguiente,\nSeparaci√≥n obvia.\nSe sugiere una separaci√≥n de responsabilidades, en lugar de que el m√≥dulo robot_posici√≥n administre el avance, retroceso y giro, separamos las responsabilidades y las asignamos a nuevos m√≥dulos, esta separaci√≥n es lo primero que se me vino a la mente, ¬øpero esta separaci√≥n es la m√°s adecuada?, las repuesta no es evidente ni definitiva, es aqu√≠ donde recurrimos a la definici√≥n un solo motivo para cambiar, los m√≥dulos traslaci√≥n y rotaci√≥n cumplen con el principio srp, solo si al requerir una nueva caracter√≠stica, solo uno de los dos m√≥dulos necesita modificarse.\nSuponiendo que los requerimientos cambian y que se requiere que la velocidad a la que se mueve el robot hacia adelante y atr√°s sea controlable, es evidente que el m√≥dulo traslaci√≥n sera el √∫nico que cambie, por lo tanto la separaci√≥n que se realizo es adecuada y cumple con el principio srp.\nAhora suponiendo que la especificaci√≥n cambia, se desea que el robot tenga movimiento continuo, es decir que el robot avance hacia adelante o atr√°s mientras est√° rotando. Ahora nuestros m√≥dulos no cumplen con el principio, pues ambos deben ser modificados para alcanzar los nuevos requerimientos, este ser√° un buen momento para replantear nuestra anterior separaci√≥n en m√≥dulos, una refactorizaci√≥n nos da el siguiente modelo,\nDe esta manera velocidad solo se encarga de mover los motores avance y de retroceso, tren_de_giro se encarga de girar un motor de direcci√≥n o el ajuste necesario dependiendo de la forma del robot.\nCon esto quiero decir que los m√≥dulos deben agruparse de tal forma que las razones por las que cambian est√©n juntas, con esto logramos que al agregar nuevos cambios, solo debamos modificar el m√≠nimo de m√≥dulos.\n¬øY cuales son esas razones de cambio?, la respuesta es el cliente, el usuario, si el cliente del m√≥dulo hace una nueva especificaci√≥n que implique un cambio y para lograr la implementaci√≥n se requieren modificar m√°s de un m√≥dulo se debe replantear la forma y el tama√±o de los m√≥dulos.\nRepito, el objetivo del SRP es proveer una forma de \u0026ldquo;modularizar\u0026rdquo; el programa en base a peticiones de cambios, aunque exista la tentaci√≥n de agrupar m√≥dulos por forma, color, sabor, etc, que pudieran parecer m√°s naturales, agrupar por motivos de cambios, nos dar√° como resultado un software altamente √°gil en el sentido de nuevas caracter√≠sticas.\nEn el ejemplo anterior, ¬øque sentido tendr√≠a mezclar el c√≥digo de control de posici√≥n con el c√≥digo de control visi√≥n del robot?, si nosotros requerimos modificar el contraste o el brillo de la imagen, ¬øser√≠a necesario modificar la velocidad del robot?, las respuesta obvia es que no, sin embargo piensa que las c√°maras aveces son muy lentas, quiz√° requerimos tomar una imagen cuando el robot se acerque a un objeto, entonces si la c√°mara es lenta necesariamente requerimos bajar la velocidad, ni modo, es triste, pero debemos refactorizar los m√≥dulos en har√°s de lograr el objetivo.\nEl SRP es el principio m√°s sencillo de describir, pero el m√°s dif√≠cil de asimilar, requiere pr√°ctica, esfuerzo, experiencia y mucha meditaci√≥n.\n"}),a.add({id:5,href:'/eleckia/posts/solid/',title:"SOLID",section:"Posts",content:"_Soy malo y eso es bueno, yo jam√°s ser√© bueno y eso no es malo, no hay nadie que quiera ser adem√°s de mi. #  - Ralph el demoledor._\nSOLID #  Dentro del mundo de la programaci√≥n existen los famosos paradigmas de programaci√≥n, entre ellos: la programaci√≥n funcional, la programaci√≥n orientada a eventos, la programaci√≥n estructurada, la programaci√≥n orientada a objetos y otros m√°s. En esta fecha 2020, la programaci√≥n orientada a objetos sin duda domina la forma en que se escribe el software en general, vale la pena aprender este paradigma pues no ser√° raro encontrarnos con programas basados en √©l.\nEl √©xito de la programaci√≥n orientada a objetos, se basa en la abstracci√≥n de objetos, ¬øqu√© es la abstracci√≥n de objetos?, personalmente la defino como una combinaci√≥n entre imaginar, separar y simplificar, es decir tomamos un objeto real por ejemplo un motor, identificamos lo que nos interesa por ejemplo la velocidad y la direcci√≥n de giro y descartamos el resto de detalles, el tipo de motor, la potencia, la tensi√≥n de entrada, el par, marca, color, peso, etc, este motor que √∫nicamente gira a la velocidad y direcci√≥n indicada, es una abstracci√≥n de un motor real, esto que parece tan trivial tiene la cualidad de simplificar la forma en que se resuelven los problema, pues los humanos estamos adaptados a pensar en objetos abstractos.\nDentro de la programaci√≥n orientada a objetos han surgido diferentes corrientes de desarrollo, en los √∫ltimos a√±os el desarrollo √°gil gano una popularidad importante. En las catacumbas de un lugar de cuyo nombre no quiero acordarme, se reuni√≥ un grupo de programadores con gran experiencia en el desarrollo de software, conspirando en contra de la t√©cnicas tradicionales escribieron el manifiesto √°gil,\nhttps://agilemanifesto.org/iso/es/manifesto.html\nuna vez popularizado el desarrollo √°gil comenzaron a desarrollarse numerosas metodolog√≠as de trabajo, entre ellas: scrum, kaban, xp, tdd, etc, como mencione las personas funcionamos en base a abstracciones por lo que las metodolog√≠as √°giles pueden salir del mundo de la programaci√≥n e implementarse en otros rubros de la humanidad.\nPersonalmente yo no me sent√≠ seguro con mi c√≥digo hasta que aprend√≠ TDD (Test Driven Development), Desarrollo Guiado por Pruebas.\nAqu√≠ tratare de describir los cinco principios fundamentales del desarrollo √°gil, acu√±ados por Robert C. Martin, Agile Software Development, Principles, Patterns, and Practices. Es un excelente referencia para cualquiera que pretenda aprender a programar.\nSOLID es un acr√≥nimo formador por los cinco principios del desarrollo √°gil.\nS Single responsibility principle (Principio de responsabilidad √∫nica)\nO Open/closed principle (Principio Abierto/Cerrado)\nL Liskov substitution principle (Principio de sustituci√≥n de Liskov)\nI Interface segregation principle (Principio de segregaci√≥n de la interfaz)\nD Dependency inversion principle (Principio de inversi√≥n de dependencia)\nSi cumplimos con estos principios dentro de nuestro c√≥digo, entonces podemos decir que nuestro c√≥digo es √°gil\n Sigue mi blog #  Recibe nuevo contenido directamente en tu bandeja de entrada.\n[jetpack_subscription_form subscribe_placeholder=\u0026ldquo;Introduce tu direcci√≥n de correo electr√≥nico\u0026rdquo; show_subscribers_total=\u0026ldquo;false\u0026rdquo; button_on_newline=\u0026ldquo;false\u0026rdquo; submit_button_text=\u0026ldquo;Registrarse\u0026rdquo; custom_background_emailfield_color=\u0026ldquo;undefined\u0026rdquo; custom_background_button_color=\u0026ldquo;undefined\u0026rdquo; custom_text_button_color=\u0026ldquo;undefined\u0026rdquo; custom_font_size=\u0026ldquo;16\u0026rdquo; custom_border_radius=\u0026ldquo;0\u0026rdquo; custom_border_weight=\u0026ldquo;1\u0026rdquo; custom_border_color=\u0026ldquo;undefined\u0026rdquo; custom_padding=\u0026ldquo;15\u0026rdquo; custom_spacing=\u0026ldquo;10\u0026rdquo; submit_button_classes=\u0026quot;\u0026quot; email_field_classes=\u0026quot;\u0026quot; show_only_email_and_button=\u0026ldquo;true\u0026rdquo; ]\n"}),a.add({id:6,href:'/eleckia/posts/electronica/',title:"Electr√≥nica",section:"Posts",content:"Ah, ¬øpero que oigo?, una intromisi√≥n, debe ser #  Lisa Simpson, la respuesta a una pregunta que\nnunca hizo nadie.\n-Ned Flanders\n Sigue mi blog #  Recibe nuevo contenido directamente en tu bandeja de entrada.\n[jetpack_subscription_form show_only_email_and_button=\u0026ldquo;true\u0026rdquo; custom_background_button_color=\u0026ldquo;undefined\u0026rdquo; custom_text_button_color=\u0026ldquo;undefined\u0026rdquo; submit_button_text=\u0026ldquo;Suscribir\u0026rdquo; submit_button_classes=\u0026ldquo;undefined\u0026rdquo; show_subscribers_total=\u0026ldquo;false\u0026rdquo; ]\n"}),a.add({id:7,href:'/eleckia/docs/avr/programando-avr-en-c-apuntadores-punteros-pointers-ii-apuntadores-dobles/',title:"Programando Avr en C.- Apuntadores, punteros, pointers III. Apuntadores Dobles.",section:"Programaci√≥n Avr en C.",content:"Los apuntadores suenan bastante complejos, nuestro cerebro amplifica su complejidad, pero al igual que cualquier otra variable su funcionamiento es simple,\ntipo ** nombre_apuntador; a que me refiero con apuntador doble, a un apuntador que guarda direcciones de otros apuntadores de su mismo tipo,\nchar caracter1 = 'a'; char caracter2 = 'b'; char \\* letra = \u0026amp;caracter1; char \\*\\* apuntador\\_doble = \u0026amp;letra; \\*apuntador\\_doble = \u0026amp;caracter2; //ahora letra apunta a la direcci√≥n de caracter2, //\\*letra es 'b' el prop√≥sito evidente de los apuntadores dobles, es cambiar el valor a donde apuntan apuntadores simples,\nint \\* pointer1=NULL; int \\* pointer2=NULL; void updatePointers(int \\*\\* a, int \\*\\* b) { \\*a = direction\\_1; \\*b = direction\\_2; } //ahora los apuntadores apuntan a las //direcciones en direction\\_n Esta aplicaci√≥n es muy sencilla, la usaremos con frecuencia.\n"}),a.add({id:8,href:'/eleckia/docs/avr/programando-avr-en-c-apuntadores-punteros-pointers-ii-apuntadores-a-funciones/',title:"Programando Avr en C.- Apuntadores, punteros, pointers II. Apuntadores a funciones.",section:"Programaci√≥n Avr en C.",content:"Como ya he dicho un apuntador es una variable que apunta a direcciones de memoria, tambi√©n hemos mencionado que los apuntadores deben ser especificados sobre el tipo, cuando las funciones se compilan se les asigna una direcci√≥n en memoria, ¬øexistir√°n apuntadores a funciones?, la respuesta es afirmativa, la sintaxis es un poco rara,\ntipo (*nombre_apuntador)(argumento1, argumento2, ..., argumento_n); al igual que los apuntadores comunes, los apuntadores a funciones deben ser especificados con el tipo de dato que regresan, entre parentesis se coloca el operador * seguido del nombre del apuntador, finalmente se especifican los par√°metros)\nint (\\*operacion)(int a, int b); int suma(int a, int b) { return a + b; } int resta(int a, int b) { return a - b; } int a = 5; int b = 10; if(condicion) operacion = suma; else operacion = resta; int c = operacion(a , b); /\\* S√≠ condici√≥n es verdadera c contendr√° 15 de \\* lo contrario c contendr√° -5 \\*/ gracias a los apuntadores a funciones, tambi√©n es posible pasar funciones como argumentos de otras funciones,\nint operadorBinario(int (\\*operation)(int a, int b), int c, int d) { return operation(c,d); } int resultado = operadorBinario(suma, 5, 10); //resultado es igual a 15 resultado = operadorBinario(resta, 5, 10); //resultado = -5; Esta caracter√≠stica nos ayudara a mejorar la calidad del c√≥digo.\n"}),a.add({id:9,href:'/eleckia/docs/avr/programando-avr-en-c-apuntadores-punteros-pointers/',title:"Programando Avr en C.- Apuntadores, punteros, pointers I.",section:"Programaci√≥n Avr en C.",content:"Los apuntadores (pienso que esta es la traducci√≥n m√°s acertada), tambi√©n conocidos como punteros o pointers en ingles, es un tipo de dato caracter√≠stico de lenguajes de bajo nivel y algunos de nivel medio, C por supuesto cuenta con tal tipo de dato.\nUn apuntador es una variable cuyo tipo de dato almacena direcciones de memoria, tan simple como eso. Aunque una direcci√≥n de memoria puede ser interpretada como un entero, es mejor pensar que una direcci√≥n de memoria es un tipo de dato diferente, un tipo de dato de tipo apuntador.\nLos apuntadores son temidos y exaltados, por buenas razones, el problema es que los apuntadores sirven para gran cantidad de aplicaciones y da la impresi√≥n de que debes conocerlas todas, por supuesto no es as√≠, se puede usar apuntadores de forma efectiva sin tener todo el bagaje t√©cnico alrededor, e ir aprendiendo gradualmente los pormenores. El secreto esta en auto limitarse y ser disciplinado.\nla sintaxis para declarar un apuntador es la siguiente\ntipo_a_donde_apunta * nombre_apuntador; un apuntador que apunta a una variable de tipo entero es diferente a un apuntador que apunta a una variable de tipo car√°cter,\nchar a; int b; int * apuntador1; // solo puede apuntar hacia b, apuntar hacia a implica un error Operador addressOff \u0026amp; #  Para almacenar la direcci√≥n de una variable primero debemos obtener su direcci√≥n, para ello contamos con el operador \u0026amp;,\nint b = 0; int * apuntador = \u0026amp;b; //apuntador ahora contiene la direcci√≥n de memoria de b Operador de indirecci√≥n * #  ¬øPara que se usa un apuntador?, como mencione las aplicaciones son amplias, pero la base es la misma, se trata de acceder al contenido guardado en una direcci√≥n de memoria de manera indirecta. Una vez establecido un apuntador, usamos el operador de indirecci√≥n para acceder al contenido a donde apunta.\nint b = 0; int * apuntador = \u0026amp;b; *apuntador = 10; //ahora b contiene el valor 10 y no 0. Una de las aplicaciones m√°s importantes es el paso de par√°metros a funciones, cuya intensi√≥n sea modificar tales par√°metros, por ejemplo\nint a = 5; int b= 3; //Se pasan dos apuntadores intercambiar(\u0026amp;a, \u0026amp;b); //pasar \u0026amp;a, es equivalente a crear un apuntador //int *apuntador = \u0026amp;a y escribir intercambiar(apuntador, \u0026amp;b); //ahora a = 3 y b = 5; void intercambiar(int * v1, int * v2) { int tmp = *v1;//tmp = valor guardado en la //direcci√≥n a donde apunta v1 *v1 = *v2; *v2 = tmp; } Usaremos ampliamente la forma de la funci√≥n intercambiar, por ahora es suficiente con este conocimiento sobre apuntadores, por supuesto m√°s adelante veremos otras aplicaciones.\n"}),a.add({id:10,href:'/eleckia/posts/contacto/',title:"Contacto",section:"Posts",content:"Hablemos üëã. No dudes en ponerte en contacto con nosotros mediante la informaci√≥n de contacto a continuaci√≥n, o env√≠anos un mensaje mediante el formulario.\nPonte en contacto con nosotros #  Calle Ejemplo, 10\nCiudad, 10100\nEspa√±a\ncorreoelectronico@ejemplo.com\n(+34) 399 555 234\nEnv√≠anos un mensaje #  "}),a.add({id:11,href:'/eleckia/posts/gpio-atmega328p/',title:"GPIO atmega328p.",section:"Posts",content:"_Si, se nos acabo la duela y pintamos la tierra, ¬øqu√© trucazo no? #  Moe Szyslak_\n Sigue mi blog #  Recibe nuevo contenido directamente en tu bandeja de entrada.\n[jetpack_subscription_form subscribe_placeholder=\u0026ldquo;Direcci√≥n de correo electr√≥nico\u0026rdquo; show_subscribers_total=\u0026ldquo;false\u0026rdquo; button_on_newline=\u0026ldquo;true\u0026rdquo; submit_button_text=\u0026ldquo;Suscribir\u0026rdquo; custom_background_emailfield_color=\u0026ldquo;undefined\u0026rdquo; custom_background_button_color=\u0026ldquo;undefined\u0026rdquo; custom_text_button_color=\u0026ldquo;undefined\u0026rdquo; custom_font_size=\u0026ldquo;16\u0026rdquo; custom_border_radius=\u0026ldquo;0\u0026rdquo; custom_border_weight=\u0026ldquo;1\u0026rdquo; custom_border_color=\u0026ldquo;undefined\u0026rdquo; custom_padding=\u0026ldquo;15\u0026rdquo; custom_spacing=\u0026ldquo;10\u0026rdquo; submit_button_classes=\u0026ldquo;has-text-color has-background-color has-background has-primary-background-color\u0026rdquo; email_field_classes=\u0026quot;\u0026quot; show_only_email_and_button=\u0026ldquo;true\u0026rdquo; ]\n"}),a.add({id:12,href:'/eleckia/docs/avr/programando-avr-en-c-el-flujo-del-programa-if-else-if-else/',title:"Programando Avr en C.- El flujo del programa, if, else, if else.",section:"Programaci√≥n Avr en C.",content:"Definimos el flujo del programa como, la ruta que toma la ejecuci√≥n del mismo, imaginemos que tenemos una lista de tareas que debemos ejecutar, digamos, tarea 1, tarea 2, tarea 3, \u0026hellip;, tarea n, ya vimos que podemos abstraer tareas como funciones, entonces simplemente podemos agregar cada una de las funciones en orden para ejecutarlas,\nint main(void) { tarea1(); tarea2(); tarea3(); tarean(); return 0; } pero que pasa si queremos ejecutar alguna de estas tareas solo si se cumple una condici√≥n, digamos, solo si se pulsa un bot√≥n determinado, o solo si el resultado de una operaci√≥n satisface alg√∫n requerimiento.\nPara ello contamos con la palabra if, si se cumple una condici√≥n, el c√≥digo dentro de sus llaves se ejecutara, de lo contrario el programa continuara despu√©s de la llave de cierre,\nint main(void) { tarea1(); if(condicion){ //si condici√≥n es verdadera tarea2(); //se ejecutaran √©sta dos tareas tarea3(); } tarea4(); //Aqu√≠ continua tarean(); return 0; } tambi√©n es posible agregar la palabra else, para controlar el flujo cuando la condici√≥n es falsa\nint main(void) { tarea1(); if(condicion){ //si condici√≥n es verdadera tarea2(); //se ejecutara √©sta tarea }else{ tarea3(); //si condici√≥n es falsa, ejecuta √©sta tarea } tarea4(); tarean(); return 0; } agregar m√°s sentencias nos permite un control aun m√°s preciso.\nint main(void) { tarea1(); if(condicion == 0){ //si condici√≥n es igual a 0 tarea2(); //se ejecutara √©sta tarea }else if(condicion == 1){ tarea3(); //si condici√≥n igual a 1, ejecuta √©sta tarea }else{ tarea4(); //si no se cumple ninguna de las anteriores } tarean(); return 0; } es importante se√±alar que la ejecuci√≥n es en orden descendente, si tenemos varios if else y en m√°s de uno se cumple la condici√≥n, solo se ejecutara el primero que la cumpla en orden descendente.\nint main(void) { tarea1(); if(true){ tarea2(); //se ejecutara √©sta tarea }else if(true){ tarea3(); //No se ejecuta }else{ tarea4(); //No se ejecuta } tarean(); //una vez ejecutada tarea2, el programa continua aqu√≠ return 0; } "}),a.add({id:13,href:'/eleckia/docs/avr/programando-avr-en-c-constantes/',title:"Programando Avr en C.- Constantes",section:"Programaci√≥n Avr en C.",content:"Las constantes son de gran utilidad en la programaci√≥n, a diferencia de las variables, las constantes no pueden cambiar su valor.\nLas dos formas m√°s comunes de definir constantes son con la palabra reservada const y con la directiva define.\nLa palabra const #  Agregando la palabra const a la declaraci√≥n de una variable, esta se convierte en constate, sin embargo tambi√©n debe asignarle el valor al momento de la declaraci√≥n;\nuint8_t const NUMERO = 10; //Declaraci√≥n de una constante NUMERO = 1; //error, no se puede reasignar Sin embargo el uso m√°s cotidiano que tiene la palabra const es en los argumentos de funciones,\nint8_t suma(int8_t const sumando1, int8_t const sumando2); Directiva define #  Entre otras cosas, la directiva define puede ser usada para definir constantes;\n#define NUMERO 10 cuando el programa se compilar, la palabra NUMERO, se reemplaza por el n√∫mero 10,\n#define PRIMERO 5 int8_t = 5 + PRIMERO; al compilar, sera reemplazado por\nint8_t = 5 + 5; Enum #  Los enum son un tipo de dato que nos facilit√° la creaci√≥n de colecciones de constantes, su sintaxis es\nenum NOMBRE{CONSTANTE1 = 0, CONSTANTE2, CONSTANTE3 = 5, CONSTANTE4}; de esta forma CONSTANTE1 es una variable de tipo enum NOMBRE y contiene el valor de 0, CONSTANTE2 contiene el valor 1 y CONSTANTE3 tiene el valor de 5 y CONSTANTE4 tiene el valor de 6.\nenum numeros{CERO, UNO, DOS}; a = CERO + UNO + DOS; //a contiene el n√∫mero 3 ¬øPor qu√© usar constantes? #  Hay dos conceptos al utilizar constantes, ser constante y querer ser constante.\nSer constante se refiere a declarar una constante expl√≠citamente por ejemplo el n√∫mero PI, SQRT2, etc.\nQuerer ser constante, se refiere a evitar que las variables cambien por accidente su valor, por ejemplo las funciones suele recibir par√°metros constantes, se busca evitar que los par√°metros cambien su valor, esto tomara sentido cuando comentemos los apuntadores en entradas posteriores.\nMuchos lenguajes de programaci√≥n nuevos, definen a las variables como constantes (inmutable) y es el usuario quien expl√≠citamente declara una variable como variable (mutable), la raz√≥n principal como se menciona es reducir la posibilidad de a√±adir errores de programaci√≥n.\n"}),a.add({id:14,href:'/eleckia/docs/avr/control_flujo/',title:"Control de flujo (if, while, for)",section:"Programaci√≥n Avr en C.",content:"Control de flujo #  El control de flujo es el pilar de la programaci√≥n estructurada, a pesar de que el paradigma de la programaci√≥n estructurada pueda considerarse anticuada para algunos, lo cierto es que la soluci√≥n de los algoritmos siempre requiere control de flujo; condicionales y repeticiones, antes de adentrarnos en el tema, revisemos el tipo de dato booleano.\nTipo de dato Booleano #  Otro tipo de datos b√°sico es el tipo booleano, aunque por raro que parezca en C, no exist√≠a este tipo de dato originalmente, actualmente se requiere incluir la biblioteca;\n#include \u0026lt;stdbool.h\u0026gt;El tipo de dato bool puede contener √∫nicamente dos valores, verdadero(true) o falso(false), la sintaxis es:\n#include\u0026lt;stdbool.h\u0026gt;//Para declarar una variable bool un_nombre; //Para definir un valor un_nombre = true; un_nombre = false; Para asumir la carencia del tipo de dato bool, C que cualquier valor diferente de 0o NULL es verdadero, sin embargo es mejor utilizar expl√≠citamente los valores true o false para denotar valores booleanos, por razones de legibilidad.\nOperadores booleanos #  Como el nombre sugiere, los operadores booleanos operan sobre tipos de dato booleanos y dan como resultado un booleano.\nEl operador and (\u0026amp;\u0026amp;) probablemente es el m√°s utilizado,\ntrue \u0026amp;\u0026amp; true //Resulta true true \u0026amp;\u0026amp; false //Resulta false false \u0026amp;\u0026amp; true //Resulta false false \u0026amp;\u0026amp; false //Resulta false El operador or (||)\ntrue || true //Resulta true true || false //Resulta true false || true //Resulta true false || false //Resulta false El operador de negaci√≥n (!)\n!false //Resulta true !true //Resulta false Operadores de comparaci√≥n #  Los operadores de comparaci√≥n, comparan dos expresiones y eval√∫an el resultado como falso o verdadero.\nIgualdad:\n10 == 10 //true \u0026#39;a\u0026#39; == \u0026#39;b\u0026#39; //false Diferencia:\n10 != 10 //false \u0026#39;a\u0026#39; != \u0026#39;b\u0026#39; //true Menor que:\n10 \u0026lt; 11 //true 10 \u0026lt; 10 //false Mayor que:\n10 \u0026gt; 11 //false 11 \u0026gt; 10 //true Menor o igual que:\n10 \u0026lt;= 11 //true 10 \u0026lt;= 10 //true Mayor o igual que:\n10 \u0026gt;= 11 //false 10 \u0026gt;= 10 //true Condicionales, if, else #  El termino control de flujo se deriva de los diagramas de flujo, una t√©cnica gr√°fica de dise√±o de programas estructurados, en ellos existe un bloque llamado if, el cual tiene la capacidad de decidir la siguiente acci√≥n en base a una condici√≥n, en C:\nbool condicional; if(condicional){ //Ejecuta este c√≥digo si condicional es verdadero } el complemento de if es else:\nbool condicional; if(condicional){ //Ejecuta este c√≥digo si condicional es verdadero }else{ //Ejecuta este c√≥digo si condicional es falso } tambi√©n es posible hacer comparaciones intermedias:\nif(condicion1){ //Ejecuta este c√≥digo si condicion1 es verdadera }else if(condicion2{ //Ejecuta este c√≥digo si condicion1 es falso y si condicion2 es verdadera }else if(condicion3){ //Ejecuta este c√≥digo si condicion1 y condicion2 son falsos y condicion3 	//es verdadera }else{ //Ejecuta este c√≥digo si todas las condiciones son falsas } Debe resaltarse que la evaluaci√≥n de las condiciones se detiene cuando se encuentra la primera condici√≥n verdadera.\nCiclos, while, for #  La repetici√≥n de acciones se logra de varias formas, pero lo m√°s com√∫n es utilizar los ciclos while y for.\nWhile #  El ciclo while repite el c√≥digo dentro de sus llaves mientras una condici√≥n sea verdadera:\nbool condicion = true; while(condicion){ //Repite estas lineas de c√≥digo 	//mientras condici√≥n sea verdadera } Simple y f√°cil de entender, otra forma de hacer repeticiones es por medio del ciclo for.\nFor #  "}),a.add({id:15,href:'/eleckia/docs/avr/funciones/',title:"Funciones",section:"Programaci√≥n Avr en C.",content:"Funciones en C #  Las funciones son caracter√≠sticas fundamentales de cualquier lenguaje de programaci√≥n, inclusive existe un paradigma de programaci√≥n llamado programaci√≥n funcional, veamos brevemente como funcionan las funciones en C. Una funci√≥n tiene la siguiente sintaxis en C,\ntipo_de_retorno nombre_de_funcion(tipo_dato argumento_n) { ... hacer_tareas ... return un_objeto_del_tipo_de_retorno; } Las funciones son usadas como una forma de separar o estratificar tareas, pueden recibir \u0026ldquo;n\u0026rdquo; cantidad de argumentos y pueden retornar o no un valor, un ejemplo sencillo, definimos la funci√≥n suma,\nint8_t suma(int8_t sumando1, int8_t sumando2) { int8_t resultado = sumando1 + sumando2; return resultado; } Es importante aclarar que el valor de retorno debe ser del mismo tipo que el tipo de retorno declarada en la funci√≥n, en este caso un entero de 8 bits.\nEsta funci√≥n simplemente suma los dos argumentos pasados en ella, definida la funci√≥n es posible llamarla desde main o cualquier otra funci√≥n:\nint main(void) { int8_t numero = suma(3,2); //ahora numero contiene 5 } Al ejecutarse, la variable numero contendr√° el valor de 5.\nDeclaraci√≥n vs Definici√≥n #  Ahora que sabemos definir funciones sencillas, escribamos un programa donde se define la funci√≥n:\n#include\u0026lt;stdint.h\u0026gt; //Para int8_t  int main(void) { int8_t numero = suma(2,3); return 0; } int8_t suma(int8_t sumando1, int8_t sumando2) { int8_t resultado = sumando1 + sumando2; return resultado; } Compilamos y nos dar√° un error:\nprogram.c: In function ‚Äòint main()‚Äô: program.c:5:25: error: ‚Äòsuma‚Äô was not declared in this scope int8_t numero = suma(2,3); El error indica que la funci√≥n main no puede encontrar a la funci√≥n sum, En C hay dos conceptos fundamentales que indican la existencia de un s√≠mbolo:\n Declaraci√≥n, Indica al compilador la existencia de un s√≠mbolo, de tal forma que el compilador pueda seguir sin la necesidad de conocer los detalles del s√≠mbolo.  int8_t funcion1(void); //Declaraci√≥n de una funci√≥n char letra; //Declaraci√≥n de una variable char A las funciones declaradas se les suele llamar prototipos, la declaraci√≥n de variables no recibe un nombre en particular,\n Definici√≥n, Se indica al compilador en que espacio se encuentra y que tama√±o tiene.  letra = \u0026#39;b\u0026#39;;	//Definici√≥n de una variable prefiamente declarada char vocal = \u0026#39;o\u0026#39;; //Declaraci√≥n y definici√≥n de una variable int8_t suma(void) //Definici√≥n y Declaraci√≥n de una funci√≥n, {	//Si la funci√≥n fue previamente declarada solo se define 	return 1 + 2; } En nuestro c√≥digo la funci√≥n suma se declara y define al final del fichero, ¬øpor qu√© nos indica un error de declaraci√≥n?, El compilador analiza el c√≥digo linea por linea de arriba hacia abajo, cuando llega a la funci√≥n main, aun no ha encontrado ning√∫n s√≠mbolo con el nombre suma, la soluci√≥n es tan simple como escribir el prototipo una o varias l√≠neas antes de la funci√≥n main.\nint8_t suma(int8_t sumando1, int8_t sumando2); int main(void) { Con esto el compilador estar√° feliz de hacer su trabajo, en otra etapa de compilaci√≥n encontrara la definici√≥n de la funci√≥n y har√° el trabajo necesario para asignar su direcci√≥n de memoria y su tama√±o.\nEn las siguientes entradas entenderemos las ventajas que se obtiene de esta separaci√≥n entre prototipo(declaraci√≥n) y la definici√≥n.\nPar√°metros y retorno #  Par√°metros #  Los par√°metros sirven para enviar datos a las funciones, aunque una interpretaci√≥n m√°s √∫til es que las funciones operan sobre los datos, una funci√≥n puede recibir cualquier cantidad de par√°metros, el limite es el tama√±o de memoria, sin embargo lo deseable es que las funciones reciban pocos o ning√∫n par√°metros, algunos ejemplos:\nint8_t suma(float sumando1, float sumando2); int8_t factorial(int8_t numero); int8_t contador(char * palabra); //apuntador tipo char int8_t simbolo(char letra); int8_t mesActual(void); //el tipo void(vacio) indica que no hay par√°metros Retorno #  Las funciones pueden retornar uno o ning√∫n par√°metro por medio de la palabra return, al igual que los par√°metros de entrada puede ser de cualquier tipo:\nint8_t suma(); char * palabras(); void encender(); //Sin retorno char ultimaLetra(); int * lista(); Llamada a funciones #  Las funciones pueden ser llamadas dentro de cualquier otra funci√≥n, incluso existe una t√©cnica llamada recursividad donde una funci√≥n se llama a si misma entrando en una especie de ciclo, aunque es una t√©cnica maravillosa es poco utilizada en sistemas embebidos, principalmente por:\n La raz√≥n m√°s importante: es una t√©cnica altamente elegante que esta reservada para gente altamente sofisticada y de buen gusto. Otra raz√≥n menos importante es que los microcontroladores carecen de la memoria suficiente para almacenar todas las variables de llamadas sucesivas a una funci√≥n.  Para llamar a una funci√≥n basta con indicar su nombre, pasar los argumentos y guardar el retorno si es necesario.\nvoid funcion1(void) { int numero = suma(3, 5); //Hacer tareas con numero } "}),a.add({id:16,href:'/eleckia/docs/perifericos/gpio/biblioteca7/',title:"Api Display Siete Segmentos",section:"GPIO",content:"Api para un display de siete segmentos #  Escribamos una biblioteca/api sencilla que nos permita configurar un n√∫mero en un display de 7 segmentos, el circuito es el siguiente,\nConexi√≥n Arduino-Display #  Contamos con un display de c√°todo com√∫n por lo tanto cada segmento se enciende con un voltaje alto en el pin correspondiente, es decir para encender el segmento \u0026ldquo;A\u0026rdquo; debemos configurar el pin digital D2 en alto. Evitamos la conexi√≥n en los pines D0 y D1, debido a que estos est√°n conectados al convertidor serial-usb, y pueden provocar problemas para subir el c√≥digo a la tarjeta.\nComo primer paso debemos incluir la biblioteca \u0026ldquo;avr/io.h\u0026rdquo;, para tener acceso a los puertos de GPIOx de entrada/salida, cuyos registros asociados son DDRx, PORTx, PINx.\n#include\u0026lt;avr/io.h\u0026gt;Ahora declaramos la funci√≥n principal, recordemos que la funci√≥n principal es llamada autom√°ticamente cuando el programa es ejecutado,\nint main(void) { return 0; } Dentro de las llaves del main configuramos los pines adecuados como salidas, para hacerlo requerimos saber a que pines del microcontrolador corresponden los pines del Arduino,\nfuente:(http://www.chicoree.fr/w/Arduino_sur_ATmega328P)\nEn la anterior imagen observamos la correspondencia entre los pines del Arduino y los del microcontrolador, por ejemplo el pin digital D2 es en realidad el pin PD2 del atmega328p, por ejemplo el pin digital D8 es en realidad el pin PB0 del atmega328p. Configuramos el registro DDRB y DDRD como salidas,\nDDRB |= 1\u0026lt;\u0026lt;PB0; DDRD |= 1\u0026lt;\u0026lt;PD2 | 1\u0026lt;\u0026lt;PD3 | 1\u0026lt;\u0026lt;PD4 | 1\u0026lt;\u0026lt;PD5 | 1\u0026lt;\u0026lt;PD6 | 1\u0026lt;\u0026lt;PD7; Ahora solo encendemos los leds, poniendo en alto los pines requeridos, por ejemplo para el n√∫mero cinco, encendemos los segmentos a,c,d,f,g.\nPara ello escribimos a los puertos PORTB y PORTD los pines indicados\nPORTB |= 1\u0026lt;\u0026lt;PB0; PORTD |= 1\u0026lt;\u0026lt;PD2 | 1\u0026lt;\u0026lt;PD4 | 1\u0026lt;\u0026lt;PD5 | 1\u0026lt;\u0026lt;PD7; El c√≥digo completo luce como el siguiente,\n#include\u0026lt;avr/io.h\u0026gt; int main(void) { DDRB |= 1\u0026lt;\u0026lt;PB0; DDRD |= 1\u0026lt;\u0026lt;PD2 | 1\u0026lt;\u0026lt;PD3 | 1\u0026lt;\u0026lt;PD4 | 1\u0026lt;\u0026lt;PD5 | 1\u0026lt;\u0026lt;PD6 | 1\u0026lt;\u0026lt;PD7; PORTB |= 1\u0026lt;\u0026lt;PB0 ; PORTD |= 1\u0026lt;\u0026lt;PD2 | 1\u0026lt;\u0026lt;PD4 | 1\u0026lt;\u0026lt;PD5 | 1\u0026lt;\u0026lt;PD7; return 0; } Compilamos y subimos.\nEl \u0026ldquo;estilo\u0026rdquo; en que hemos escrito nuestro programa es coloquialmente llamado hardcoding, debido a que nosotros especificamos tanto los valores como el flujo, usualmente lo que queremos es que el programa calcule los valores y elija el flujo, imaginemos que ahora requerimos una secuencia de n√∫meros en serie, comenzado con 1 y terminando en 9 y repetir esta secuencia 1000 veces, seria un poco tedioso cambiar uno por uno los estados de los segmentos, para evitar este trabajo nos apoyaremos en funciones y sentencias de flujo.\nBiblioteca #  Nuestro anterior programa sirve para dos cosas, para nada y para la basura, no hay ninguna diferencia con respecto a conectar los pines del display directamente a Vcc, requerimos funcionalidad, que el microcontrolador haga lo adecuado para mostrar cualquier n√∫mero indicado, con una interfaz del tipo\ndisplay7_showNumber(3); //Muestra el n√∫mero 3 en el display de esta forma podemos realizar una secuencia de n√∫meros\nint main(void) { while(1){ display7_showNumber(0); //delay  display7_showNumber(1); //delay  . . . display7_showNumber(9); //delay  } } El display mostrara los n√∫meros del 0 al 9 en orden ascendente, nuestro objetivo entonces es definir la funci√≥n display7_showNumber(short const number).\nAunque en este problema sencillo podemos programar la soluci√≥n de forma monol√≠tica(un solo fragmento de c√≥digo), es de utilidad desarrollarlo en forma modular, como en la siguiente figura\nDe tal forma que podemos utilizarla dentro de nuestra aplicaci√≥n con un simple include, pensar en forma modular tiene grandes ventajas y conforme crece el proyecto se vuelve la √∫nica forma sostenible de escribir c√≥digo,\nPara nuestro prop√≥sito un m√≥dulo es un ente de software que aglutina las las caracter√≠sticas:\n Responsabilidad √∫nica, solo realiza una tarea. D√©bilmente acoplado, Dos m√≥dulos est√°n d√©bilmente acoplados si ambos desconocen los detalles de implementaci√≥n del otro. Altamente cohesivo, Un m√≥dulo es altamente cohesivo si utiliza la totalidad de sus miembros, para realizar sus tareas.  La definici√≥n de m√≥dulo es un poco vol√°til, cada autor lo llama diferente, algunos indican que una clase es equivalente a un m√≥dulo, algunos indican que un conjunto de clases es un m√≥dulo, otros les llaman entidades, componentes, o paquetes. Para este prop√≥sito cuando digo m√≥dulo me refiero al conjunto de un fichero .h con su o sus respectivos ficheros .c.\nUna bonita interfaz para nuestro modulo puede ser\nvoid display7_init(void); void display7_showNumber(int8_t number); Elegir buenos nombres es una parte fundamental para que nuestro c√≥digo sea de alta calidad, estoy seguro que al leer las funciones anteriores de inmediato formaste una idea de lo que hacen y a que pertenecen.\nNi tardos ni perezosos comenzamos con la crea del m√≥dulo, declaramos la interfaz del m√≥dulo en un fichero display7.h:\n#ifndef DISPLAY7_H #define DISPLAY7_H  #include \u0026lt;stdint.h\u0026gt; void display7_init(void); void display7_showNumber(int8_t number); #endif// DISPLAY7_H Comenzar√© con la funci√≥n display7_showNumber, pues actualmente no tengo idea de que requiero inicializar en la otra funci√≥n, r√°pidamente defino la funci√≥n dentro de un fichero display7.c:\n#include \u0026#34;display7.h\u0026#34; void display7_showNumber(int8_t number) { } Enfoc√°ndonos en la funci√≥n requerimos que number sea traducida a un formato donde los pines puedan ser establecidos, supongamos que siempre number = 1, bastar√≠a con:\n#include\u0026lt;avr/io.h\u0026gt; void display7_showNumber(int8_t number) { PORTD |= 1\u0026lt;\u0026lt;PD3 | 1\u0026lt;\u0026lt;PD4; } Ahora consideremos el caso en que number puede ser uno o siete,\nvoid display7_showNumber(int8_t number) { if(number == 1) PORTD |= 1\u0026lt;\u0026lt;PD3 | 1\u0026lt;\u0026lt;PD4; else if(number == 7) PORTD |= 1\u0026lt;\u0026lt;PD3 | 1\u0026lt;\u0026lt;PD4 | 1\u0026lt;\u0026lt;PD2; } Parece la direcci√≥n correcta, sin embargo, si primero se muestra siete, ya no ser√° posible mostrar un uno, el problema habla y nos esta diciendo que requerimos implementar la funcionalidad de establecer los pines y de borrar los pines complementarios. Se proponen dos funciones adicionales:\nstatic void setPins(uint8_t pins); static void clearPins(uint8_t pins); void display7_showNumber(int8_t number) { if(number == 1){ setPins(1\u0026lt;\u0026lt;PD3 | 1\u0026lt;\u0026lt;PD4); clearPins(1\u0026lt;\u0026lt;PD3 | 1\u0026lt;\u0026lt;PD4); } else if(number == 7){ setPins(1\u0026lt;\u0026lt;PD3 | 1\u0026lt;\u0026lt;PD4 | 1\u0026lt;\u0026lt;PD2); clearPins(1\u0026lt;\u0026lt;PD3 | 1\u0026lt;\u0026lt;PD4 | 1\u0026lt;\u0026lt;PD2); } } static void setPins(uint8_t pins) { PORTD |= pins; } static void clearPins(uint8_t pins) { PORTD \u0026amp;= ~pins; } El c√≥digo tiene dos problemas graves, el primero es que comienza a verse algo de repetici√≥n, este es un dogma de la programaci√≥n:\nLa repetici√≥n de ideas, es el origen de todos los males\nEl segundo es que no todos los pines est√°n en el puerto D, hay uno en el B.\nSolucionemos r√°pidamente el primer problema:\nvoid display7_showNumber(int8_t number) { uint8_t pins; if(number == 1) pins = 1\u0026lt;\u0026lt;PD3 | 1\u0026lt;\u0026lt;PD4; else if(number == 7) pins = 1\u0026lt;\u0026lt;PD3 | 1\u0026lt;\u0026lt;PD4 | 1\u0026lt;\u0026lt;PD2; setPins(pins); clearPins(pins); } Lo anterior tiene un nombre, se llama refactoring, algunos le dicen refactorizar pero evidentemente es una palabra que no existe, el refactoring tiene sus reglas y directrices, es un t√≥pico relativamente avanzado que tocaremos en otra entrada, para quien desee adelantarse, tiene disponible Refactoring de Martin Fowler.\nEl segundo problema no es tan sencillo de atacar, no hay forma de diferencia PB0 de PD0, ambos son un cero, para esta configuraci√≥n de pines tenemos suerte, solo hay PB0 y podemos trabajar con una condicional sobre el, pero deber√≠amos buscar una forma m√°s generalizada:\nstatic void setPins(uint8_t pins) { PORTD |= pins; if(pins \u0026amp; (1\u0026lt;\u0026lt;PB0)) PORTB |= 1\u0026lt;\u0026lt;PB0; } static void clearPins(uint8_t pins) { PORTD \u0026amp;= ~pins; if(pins \u0026amp; (1\u0026lt;\u0026lt;PB0)) PORTB \u0026amp;= ~(1\u0026lt;\u0026lt;PB0); } No me da buenas sensaciones pero funciona, m√°s adelante lo intentaremos de nuevo, por ahora agreguemos un caso m√°s, cuando number puede ser tambi√©n cuatro:\nvoid display7_showNumber(int8_t number) { uint8_t pins; if(number == 1) pins = 1\u0026lt;\u0026lt;PD3 | 1\u0026lt;\u0026lt;PD4; else if(number == 7) pins = 1\u0026lt;\u0026lt;PD3 | 1\u0026lt;\u0026lt;PD4 | 1\u0026lt;\u0026lt;PD2; else if(number == 4) pins = 1\u0026lt;\u0026lt;PD3 | 1\u0026lt;\u0026lt;PD4 | 1\u0026lt;\u0026lt;PB0 | 1\u0026lt;\u0026lt;PD7; setPins(pins); clearPins(pins); } Esos if\u0026rsquo;s se ven horribles y faltan m√°s, ¬øhabr√° alguna forma de quitarlos?, actualmente representamos los segmentos como sigue:\n0b76543210 FEDCBA0G Si sabemos que a cada valor de number le corresponde una y solo una representaci√≥n de segmentos, entonces ¬øno podr√≠amos guardar los \u0026ldquo;patrones\u0026rdquo; que le corresponde a cada valor de number?, por supuesto, a eso se le conoce como lookup table o tabla de consulta, hay muchas formas de implementarla pero la m√°s sencilla es por medio de un arreglo:\nconst uint8_t segments_table[] ={ 1\u0026lt;\u0026lt;PD2 | 1\u0026lt;\u0026lt;PD3 | 1\u0026lt;\u0026lt;PD4 | 1\u0026lt;\u0026lt;PD5 | 1\u0026lt;\u0026lt;PD6 | 1\u0026lt;\u0026lt;PD7, //0 	1\u0026lt;\u0026lt;PD3 | 1\u0026lt;\u0026lt;PD4, //1 	1\u0026lt;\u0026lt;PD2 | 1\u0026lt;\u0026lt;PD3 | 1\u0026lt;\u0026lt;PD5 | 1\u0026lt;\u0026lt;PD6 | 1\u0026lt;\u0026lt;PB0, //2 	1\u0026lt;\u0026lt;PD2 | 1\u0026lt;\u0026lt;PD3 | 1\u0026lt;\u0026lt;PD4 | 1\u0026lt;\u0026lt;PD5 | 1\u0026lt;\u0026lt;PB0, //3 	. . . }; void display7_showNumber(int8_t number) { uint8_t pins = segments_table[number]; setPins(pins); clearPins(pins); } Ahora si, se ve simple y claro. ¬øQu√© pasar√≠a si el usuario introduce un n√∫mero m√°s grande que el tama√±o del arreglo?, claramente habr√≠a un error, debemos protegernos de valores inadecuados:\nvoid display7_showNumber(int8_t number) { if(number \u0026lt; 0 || number \u0026gt; 9) return ; uint8_t pins = segments_table[number]; setPins(pins); clearPins(pins); } Si se introduce un n√∫mero incorrecto, la funci√≥n simplemente lo ignora.\nYa sabemos que lo √∫nico que requerimos inicializar, son los pines en la funci√≥n display7_init\nvoid display7_init(void) { DDRD |= 1\u0026lt;\u0026lt;PD2 | 1\u0026lt;\u0026lt;PD3 | 1\u0026lt;\u0026lt;PD4 | 1\u0026lt;\u0026lt;PD5 | 1\u0026lt;\u0026lt;PD6 | 1\u0026lt;\u0026lt;PD7; DDRB |= 1\u0026lt;\u0026lt;PB0; } Solo nos queda incluir la biblioteca dentro del main:\n#include \u0026#34;display7.h\u0026#34;#define F_CPU 16000000UL #include \u0026lt;util/delay.h\u0026gt; int main(void) { display7_init(); int i = 0; while(1){ display7_showNumber(i); _delay_ms(1000); i++; if(i \u0026gt; 9) i = 0; } } Compilando el programa con:\n$ avr-gcc -mmcu=atmega328p -Wall -Os display7.c main.c Obtengo los siguientes resultados:\n$ avr-size --mcu=atmega328p --format=avr a.out AVR Memory Usage ---------------- Device: atmega328p Program: 260 bytes (0.8% Full) (.text + .data + .bootloader) Data: 8 bytes (0.4% Full) (.data + .bss + .noinit) Lo que es fant√°stico, pues no hemos utilizado ni el 1% de la memoria flash y una miserable cantidad de memoria ram.\nDesafortunadamente esa biblioteca es muy concreta, depende directamente de la asignaci√≥n de pines indicada en el esquem√°tico, cualquier cambio en alguno de los pines deriva en cambiar tres funciones y la tabla.\nGeneralizando m√°s #  Algo que me gustar√≠a es que se pueda indicar los pines al inicializar la biblioteca:\nvoid display7_init(int8_t A, int8_t B, int8_t C, int8_t D, int8_t E, int8_t F, int8_t G, int8_t dot); Se requiere una forma de guardar los pines ingresados por el usuario, un arreglo ser√° suficiente:\n#define TOTAL_PINS 8 uint8_t pins_table[TOTAL_PINS]; void display7_init(int8_t A, int8_t B, int8_t C, int8_t D, int8_t E, int8_t F, int8_t G, int8_t dot) { pins_table[0] = A; pins_table[1] = B; pins_table[2] = C; pins_table[3] = D; pins_table[4] = E; pins_table[5] = F; pins_table[6] = G; pins_table[7] = dot; } Desde el punto de vista del compilador no hay forma de saber a que gpio corresponde cada pin, debemos especificar la correspondencia, otra lookup table es necesaria:\nenum {portB, portC, portD}; const int8_t gpio_table[][2] = { {-1, -1}, //pin 1 	{portD, PD0}, {portD, PD1}, {portD, PD2}, {portD, PD3}, {portD, PD4}, {-1, -1}, //Vcc 	{-1, -1}, //Gnd 	{portB, PB6}, {portB, PB7}, {portD, PD5}, {portD, PD6}, {portD, PD7}, {portB, PB0}, //pin 14 	{portB, PB1}, {portB, PB2}, {portB, PB3}, {portB, PB4}, {portB, PB5}, {-1, -1}, //AVcc 	{-1, -1}, //ARef 	{-1, -1}, //Gnd 	{portC, PC0}, {portC, PC1}, {portC, PC2}, {portC, PC3}, {portC, PC4}, {portC, PC5}, //pin 28 }; Ahora contamos con toda la informaci√≥n necesaria. Registrados los pines, es necesario configurarlos como salidas, se propone:\nvoid display7_init(int8_t A, int8_t B, int8_t C, int8_t D, int8_t E, int8_t F, int8_t G, int8_t dot) { pins_table[0] = A; pins_table[1] = B; pins_table[2] = C; pins_table[3] = D; pins_table[4] = E; pins_table[5] = F; pins_table[6] = G; pins_table[7] = dot; pinsAsOutput(); } static void pinsAsOutput(void) { for(int i = 0; i\u0026lt;TOTAL_PINS; i++){ if(gpio_table[pins_table[i]][0] == portB) DDRB |= gpio_table[pins_table[i]][1]; else if(gpio_table[pins_table[i]][0] == portC) DDRC |= gpio_table[pins_table[i]][1]; else if(gpio_table[pins_table[i]][0] == portD) DDRD |= gpio_table[pins_table[i]][1]; } } Tan solo nos queda establecer y limpiar, se propone modificar los patrones de los segmentos a la forma:\n0b76543210 .GFEDCBA es decir:\nconst uint8_t segments_table[] = { //0b76543210 	// .GFEDCBA 	0xFC, //0 	0x60, //1 	0xDA, //2 	0xF2, //3 	0x66, //4 	0xB6, //5 	0xBE, //6 	0xE0, //7 	0xFE, //8 	0xE6, //9 }; Para establecer cada segmento se recorren los pines registrados y si el correspondiente bit est√° en alto, se establece el pin:\nstatic void setPins(uint8_t pins) { for(int i = 0; i\u0026lt;TOTAL_PINS; i++){ if((pins\u0026amp;(1\u0026lt;\u0026lt;i)) == 0) continue; if(gpio_table[pins_table[i]][0] == portB) PORTB |= 1\u0026lt;\u0026lt;gpio_table[pins_table[i]][1]; else if(gpio_table[pins_table[i]][0] == portC) PORTC |= 1\u0026lt;\u0026lt;gpio_table[pins_table[i]][1]; else if(gpio_table[pins_table[i]][0] == portD) PORTD |= 1\u0026lt;\u0026lt;gpio_table[pins_table[i]][1]; } } static void clearPins(uint8_t pins) { for(int i = 0; i\u0026lt;TOTAL_PINS; i++){ if((pins\u0026amp;(1\u0026lt;\u0026lt;i)) == 0) continue; if(gpio_table[pins_table[i]][0] == portB) PORTB \u0026amp;= ~(1\u0026lt;\u0026lt;gpio_table[pins_table[i]][1]); else if(gpio_table[pins_table[i]][0] == portC) PORTC \u0026amp;= ~(1\u0026lt;\u0026lt;gpio_table[pins_table[i]][1]); else if(gpio_table[pins_table[i]][0] == portD) PORTD \u0026amp;= ~(1\u0026lt;\u0026lt;gpio_table[pins_table[i]][1]); } } Funciona pero es horriblemente feo, hagamos una lookup table para quitar esos espantosos if\u0026rsquo;s:\nvolatile uint8_t * port_table[] = { \u0026amp;PORTB, \u0026amp;PORTC, \u0026amp;PORTD }; static void setPins(uint8_t pins) { volatile uint8_t * port_register; for(int i = 0; i\u0026lt;TOTAL_PINS; i++){ if((pins\u0026amp;(1\u0026lt;\u0026lt;i)) == 0) continue; port_register = port_table[gpio_table[pins_table[i]][0]]; *port_register |= 1\u0026lt;\u0026lt;gpio_table[pins_table[i]][1]; } } static void clearPins(uint8_t pins) { volatile uint8_t * port_register; for(int i = 0; i\u0026lt;TOTAL_PINS; i++){ if((pins\u0026amp;(1\u0026lt;\u0026lt;i)) == 0) continue; port_register = port_table[gpio_table[pins_table[i]][0]]; *port_register \u0026amp;= ~(1\u0026lt;\u0026lt;gpio_table[pins_table[i]][1]); } } volatile uint8_t * ddr_table[] = { \u0026amp;DDRB, \u0026amp;DDRC, \u0026amp;DDRD }; static void pinsAsOutput(void) { volatile uint8_t * dir_register; for(int i = 0; i\u0026lt;TOTAL_PINS; i++){ dir_register = ddr_table[gpio_table[pins_table[i]][0]]; *dir_register |= 1\u0026lt;\u0026lt;gpio_table[pins_table[i]][1]; } } Aunque se ve un poco m√°s simple, no deja de ser mala idea anidar indices de esa forma, algo un poco m√°s decente es lo siguiente:\nstatic void setPins(uint8_t pins) { volatile uint8_t * port_register; int8_t pin_number; int8_t port; int8_t pin; for(int i = 0; i\u0026lt;TOTAL_PINS; i++){ if((pins\u0026amp;(1\u0026lt;\u0026lt;i)) == 0) continue; pin_number = pins_table[i]; port = gpio_table[pin_number][0]; pin = gpio_table[pin_number][1]; port_register = port_table[port]; *port_register |= 1\u0026lt;\u0026lt;pin; } } creo que se entiende mejor. Pero sigue sin satisfacerme, ma√±osamente he dejado una l√≠nea para resaltar algo muy importante, esta funci√≥n esta haciendo dos tareas.\n1.- Revisa las coincidencias entre el segmento y el bit.\n2.- Establece el bit en el puerto.\nPara mayor claridad y mejor \u0026ldquo;mantenibilidad\u0026rdquo;, propongo poner la segunda tarea en otra funci√≥n.\nstatic void setPin(int8_t pin_number); static void setPins(uint8_t pins) { int8_t pin_number; for(int i = 0; i\u0026lt;TOTAL_PINS; i++){ if((pins\u0026amp;(1\u0026lt;\u0026lt;i)) == 0) continue; pin_number = pins_table[i]; setPin(pin_number); } } static void setPin(int8_t pin_number) { int8_t port = gpio_table[pin_number][0]; int8_t pin = gpio_table[pin_number][1]; volatile uint8_t * port_register = port_table[port]; *port_register |= 1\u0026lt;\u0026lt;pin; } Mucho mejor, ahora la funci√≥n setPins no tiene nada que ver con los pines del microcontrolador, propongo cambiar el nombre setSegments y la tabla de pins_table a segments_pins_table. Por supuesto tambi√©n ser requiere una funci√≥n clearPin:\nstatic void setPin(int8_t pin_number) { int8_t port = gpio_table[pin_number][0]; int8_t pin = gpio_table[pin_number][1]; volatile uint8_t * port_register = port_table[port]; *port_register |= 1\u0026lt;\u0026lt;pin; } static void clearPin(int8_t pins) { int8_t port = gpio_table[pin_number][0]; int8_t pin = gpio_table[pin_number][1]; volatile uint8_t * port_register = port_table[port]; *port_register \u0026amp;= ~(1\u0026lt;\u0026lt;pin); } La repetici√≥n es evidente, se propone condensar las dos funciones en una sola y renombrarla:\ntypedef enum {LOW=0, HIGH} PIN_LEVEL; static void setPinLevel(int8_t pin_number, PIN_LEVEL level) { int8_t port = gpio_table[pin_number][0]; int8_t pin = gpio_table[pin_number][1]; volatile uint8_t * port_register = port_table[port]; if(level == LOW) *port_register \u0026amp;= ~(1\u0026lt;\u0026lt;pin); else if(level == HIGH) *port_register |= 1\u0026lt;\u0026lt;pin; } Se ve bien. Lo mismo pasa con las renombradas setSegments y clearSegments, tambi√©n se propone condensar ambas funciones:\nstatic void setSegments(uint8_t pins) { int8_t pin_number; for(int i = 0; i\u0026lt;TOTAL_PINS; i++){ pin_number = segments_pins_table[i]; if((pins\u0026amp;(1\u0026lt;\u0026lt;i)) == 0) setPinLevel(pin_number, LOW); else setPinLevel(pin_number, HIGH); } } Fant√°stico. As√≠ como existe una funci√≥n que indica el nivel de un pin, la funci√≥n pinsAsOutput nos pide a gritos una funci√≥n setPinDirection:\nstatic void setPinLevel(int8_t pin_number, PIN_LEVEL level) { int8_t port = gpio_table[pin_number][0]; int8_t pin = gpio_table[pin_number][1]; volatile uint8_t * port_register = port_table[port]; if(level == LOW) *port_register \u0026amp;= ~(1\u0026lt;\u0026lt;pin); else if(level == HIGH) *port_register |= 1\u0026lt;\u0026lt;pin; } typedef enum {INPUT=0, OUTPUT}PIN_DIR; static void setPinDirection(int8_t pin_number, PIN_DIR direction) { int8_t port = gpio_table[pin_number][0]; int8_t pin = gpio_table[pin_number][1]; volatile uint8_t * port_register = dir_table[port]; if(direction == INPUT) *port_register \u0026amp;= ~(1\u0026lt;\u0026lt;pin); else if(direction == OUTPUT) *port_register |= 1\u0026lt;\u0026lt;pin; } Casi son id√©nticas, podr√≠a aplicarse el mismo razonamiento y condensarlas pero una funci√≥n con m√°s de dos par√°metros es muy desagradable, pero m√°s importante estas funciones se utilizar√°n en dos contextos totalmente diferentes, prefiero dejarlas separadas.\nAprovechando la nueva funci√≥n se hace refactoring en pinsAsOutput:\nstatic void pinsAsOutput(void) { int8_t pin; for(int i = 0; i\u0026lt;TOTAL_PINS; i++){ pin = segments_pins_table[i]; setPinDirection(pin, OUTPUT); } } Vamos bien. Finalmente se modifica display7_showNumber para que utilice las nuevas funciones:\nvoid display7_showNumber(int8_t number) { if(number \u0026lt; 0 || number \u0026gt; 9) return; uint8_t pins = segments_table[number]; setSegments(pins); } El trabajo es hecho, pero hay algo m√°s que debe hacerse.\nCeder la responsabilidad #  Actualmente las tablas y las funciones se ven como sigue:\nuint8_t segments_pins_table[TOTAL_PINS]; const uint8_t segments_table[]; void display7_showNumber(int8_t number); static void setSegments(uint8_t pins); void display7_init(int8_t A, int8_t B, int8_t C, int8_t D, int8_t E, int8_t F, int8_t G, int8_t dot); static void pinsAsOutput(void); const int8_t gpio_table[][2]; volatile uint8_t * port_table[]; volatile uint8_t * ddr_table[]; static void setPinLevel(int8_t pin_number, PIN_LEVEL level); static void setPinDirection(int8_t pin_number, PIN_DIR direction); Nuevamente de forma explicita dej√© un espacio para resaltar que las funciones de arriba √∫nicamente utilizan las tablas superiores, mientras que las dos funciones de bajo solo utilizan las tres tablas de abajo. Dicho en forma elegante las tablas y funciones de arriba son altamente cohesivas entre ellas, y las funciones y las tablas de abajo son altamente cohesivas entre ellas, es absolutamente necesarios dividir el m√≥dulo en dos, por lo que se propone trasladar las tablas y funciones de abajo a un nuevo par de ficheros, gpio.h y gpio.c:\n#ifndef GPIO_H #define GPIO_H  #include \u0026lt;stdint.h\u0026gt; typedef enum {LOW=0, HIGH} PIN_LEVEL; typedef enum {INPUT=0, OUTPUT}PIN_DIR; void setPinLevel(int8_t pin_number, PIN_LEVEL level); void setPinDirection(int8_t pin_number, PIN_DIR direction); #endif// GPIO_H #include \u0026#34;gpio.h\u0026#34;#include \u0026lt;avr/io.h\u0026gt; enum {portB, portC, portD}; const int8_t gpio_table[][2] = { {-1, -1}, //pin 1 	{portD, PD0}, {portD, PD1}, {portD, PD2}, {portD, PD3}, {portD, PD4}, {-1, -1}, //Vcc 	{-1, -1}, //Gnd 	{portB, PB6}, {portB, PB7}, {portD, PD5}, {portD, PD6}, {portD, PD7}, {portB, PB0}, //pin 14 	{portB, PB1}, {portB, PB2}, {portB, PB3}, {portB, PB4}, {portB, PB5}, {-1, -1}, //AVcc 	{-1, -1}, //ARef 	{-1, -1}, //Gnd 	{portC, PC0}, {portC, PC1}, {portC, PC2}, {portC, PC3}, {portC, PC4}, {portC, PC5}, //pin 28 }; volatile uint8_t * port_table[] = { \u0026amp;PORTB, \u0026amp;PORTC, \u0026amp;PORTD }; volatile uint8_t * ddr_table[] = { \u0026amp;DDRB, \u0026amp;DDRC, \u0026amp;DDRD }; void setPinLevel(int8_t pin_number, PIN_LEVEL level) { int8_t port = gpio_table[pin_number][0]; int8_t pin = gpio_table[pin_number][1]; volatile uint8_t * port_register = port_table[port]; if(level == LOW) *port_register \u0026amp;= ~(1\u0026lt;\u0026lt;pin); else if(level == HIGH) *port_register |= 1\u0026lt;\u0026lt;pin; } void setPinDirection(int8_t pin_number, PIN_DIR direction) { int8_t port = gpio_table[pin_number][0]; int8_t pin = gpio_table[pin_number][1]; volatile uint8_t * port_register = port_table[port]; if(direction == INPUT) *port_register \u0026amp;= ~(1\u0026lt;\u0026lt;pin); else if(direction == OUTPUT) *port_register |= 1\u0026lt;\u0026lt;pin; } Compilando y midiendo el tama√±o obtengo:\n$ avr-size --format=avr --mcu=atmega328p a.out AVR Memory Usage ---------------- Device: atmega328p Program: 612 bytes (1.9% Full) (.text + .data + .bootloader) Data: 88 bytes (4.3% Full) (.data + .bss + .noinit) No est√° mal, sacrificamos un poco de memoria en favor de la portabilidad.\nComentarios finales #  Ahora contamos con dos m√≥dulos que deber√≠an verse de la siguiente forma:\n. ‚îú‚îÄ‚îÄ display7 ‚îÇ¬†‚îú‚îÄ‚îÄ include ‚îÇ¬†‚îÇ¬†‚îî‚îÄ‚îÄ display7.h ‚îÇ¬†‚îî‚îÄ‚îÄ src ‚îÇ¬†‚îî‚îÄ‚îÄ display7.c ‚îú‚îÄ‚îÄ gpio ‚îÇ¬†‚îú‚îÄ‚îÄ include ‚îÇ¬†‚îÇ¬†‚îî‚îÄ‚îÄ gpio.h ‚îÇ¬†‚îî‚îÄ‚îÄ src ‚îÇ¬†‚îî‚îÄ‚îÄ gpio.c ‚îî‚îÄ‚îÄ main.c 6 directories, 5 files De esta manera display7 puede usar el m√≥dulo gpio simplemente con incluirlo, pero no solo eso, un m√≥dulo led, buzzer o cualquiera que requiera utilizar los puertos gpio, queda habilitado para poder usarlos, sin tener que preocuparse por los registros, mejor aun, gpio puede ser adaptado r√°pidamente a cualquier otro avr cambiando √∫nicamente las tablas de pines. Por supuesto display7 tambi√©n puede ser incluido dentro de cualquier otro m√≥dulo que lo requiera.\nComparando las dos versiones, es evidente que la segundo es mucho m√°s compleja, tomo mucho m√°s tiempo y se cometieron m√°s errores, adem√°s ocupa m√°s recursos y es m√°s lenta. ¬øVale la pena realizar la sobrecarga de trabajo?, la respuesta no es simple, pienso que vale la pena cuando no existe un m√≥dulo que ya lo haga, si ya existe no pierdas el tiempo y √∫salo, si no existe y solo vas a realizar un proyecto con ese dispositivo, olv√≠dalo no vale la pena \u0026ldquo;harcodea\u0026rdquo;, si no existe y vas a utilizar de forma regular esa caracter√≠sticas, vale totalmente la pena, la verdad es muy bonito que cuando requieres comenzar un proyecto ya tengas tus bibliotecas de los perif√©ricos listas y no tengas que andar buscando registros y pines en el data sheet.\nm√≥dulo gpio\nm√≥dulo display7\n"}),a.add({id:17,href:'/eleckia/posts/electronica-basica-display-de-7-segmentos/',title:"Electr√≥nica b√°sica.- Display de 7 segmentos.",section:"Posts",content:"Un display de 7 segmentos es un arreglo de leds distribuidos de una manera determinada, 8 leds en total, el display de 7 segmentos tiene el prop√≥sito de mostrar caracteres, usualmente n√∫meros pero tambi√©n puede mostrar letras.\nDisplay 7 segmentos\nel circuito equivalente es muy sencillo,\nC√°todo com√∫n\nesta configuraci√≥n es llamada c√°todo com√∫n, puesto que el c√°todo de todos los diodos est√° en corto circuito, es una buena caracter√≠stica pues tenemos un solo pin para todos los c√°todos y podemos usar un solo cable para la conexi√≥n en lugar de ocho.\n√Ånodo com√∫n\nLa configuraci√≥n de √°nodo com√∫n es similar a la de c√°todo com√∫n salvo que los √°nodos son los que est√°n conectados en corto.\nEl dispositivo cuenta con nueve terminales (aveces diez, dos dedicadas para el com√∫n) una para el com√∫n y el resto para los ocho leds, para el c√°todo com√∫n; la terminal com√∫n se conecta a tierra y los leds se encienden con voltaje alto, por el contrario para el √°nodo com√∫n; la terminal com√∫n se conecta a Vcc y los leds se encienden con voltaje bajo.\nCada terminal es simplemente un led, por lo tanto para usarlo debemos agregar una resistencia para limitar la corriente, para nuestro atmega328p; resistencias para cada led de 330 $latex \\Omega$ o un poco mayores son suficientes. Cada led sera alimentado por 10[mA], si todos los leds se encienden al mismo tiempo, en total tenemos 80[mA], por lo que nuestro microcontrolador puede manejarlos sin problema, recordemos que la corriente m√°xima provista por el microcontrolador es de 200[mA] por todos los pines y 40[mA] en cada pin.\n"}),a.add({id:18,href:'/eleckia/posts/electronica-basica-led-y-su-resistencia/',title:"Electr√≥nica b√°sica.- Led y su resistencia.",section:"Posts",content:"La ley de Ohm es una herramienta fundamental en la electr√≥nica, en esta ocasi√≥n vamos a calcular la resistencia adecuada para que un diodo pueda operar de forma segura.\nAntes que nada definamos que es un diodo, sin entrar en detalles, un diodo es un dispositivo que permite el flujo de corriente en una sola direcci√≥n, cuenta con dos terminales, el √°nodo y el c√°todo, la regla es que si se conecta un voltaje alto al √°nodo y uno bajo al c√°todo, entonces fluye corriente, esta operaci√≥n del diodo se conoce como polarizaci√≥n directa, si se invierten las conexiones se dice que el diodo esta polarizado en inversa y no fluye corriente. Un circuito simple se muestra en la figura,\nCircuito con Diodo\nAhora reemplazamos el diodo por su circuito equivalente,\nDiodo en Directa\nLa resistencia \u0026ldquo;interna\u0026rdquo; del diodo es muy peque√±a por lo que podemos despreciarla, no debemos olvidar que este circuito es un modelo, el modelo funciona bien porque representa el comportamiento del diodo, no significa que dentro del diodo exista una resistencia y una fuente de voltaje, el valor de la fuente de voltaje varia de diodo a diodo, debemos verificar la hoja de datos para ver que voltaje tiene el diodo en cuesti√≥n, en algunos casos el voltaje es peque√±o comparado con el resto de voltajes y simplemente se desprecia, modelandolo como un simple corto circuito.\nEn el caso de la polarizaci√≥n inversa el circuito es aun m√°s simple\nDiodo en Inversa\nes un circuito abierto y no hay circulaci√≥n de corriente.\nLed. #  Un led es un diodo que tiene la capacidad de emitir luz, el voltaje del diodo led es mayor que el voltaje de otro tipo de diodos, siendo el rojo el mas peque√±o alrededor de 1.8 [V] y el azul el m√°s grande alrededor de 4.8 [V], esto para leds de 5mm, sin embargo esto valores cambian seg√∫n el tama√±o del led, lo mejor es revisar en la hoja de datos del diodo en cuesti√≥n.\nUn led generalmente se acompa√±a de una resistencia conectada en serie, ¬øpara qu√©?, la respuesta es simple, para limitar su corriente, entendamos que es un corto circuito.\nPartiendo del circuito anterior, tenemos una fuente en serie con una resistencia, recordemos que la corriente es\n$latex i = \\frac{V}{R}$\nun corto se entiende como una conexi√≥n el√©ctrica de cero resistencia entre dos terminales. De esta forma los puntos A y B en el esquema est√°n en corto, dicho de otra manera no hay resistencia entre ellos, esto implica que la corriente puede fluir totalmente entre estos dos puntos, Las terminales C y D no est√°n en corto pues hay una resistencia entre ellas, ¬øque pasar√≠a si quitamos la resistencia?, pues tendr√≠amos a las terminales C y D en corto y las consecuencias serian desastrosas. de la ley de Ohm tenemos $latex i = \\frac{V}{0} = \\infty$, las fuentes no pueden otorgar energ√≠a infinita, est√°n dise√±ada para dar una corriente especifica, si se sobrepasa el limite se da√±aran, es por eso que nunca debes juntar las terminales de una fuente.\nRegresando a nuestro diodo led, ¬øqu√© pasar√≠a si no colocamos una resistencia entre el diodo y la fuente?,\nDiodo en corto\ncomo dijimos la resistencia del modelo del diodo es muy peque√±a por lo tanto la fuente y el diodo est√°n pr√°cticamente en corto, es decir fluir√° una gran cantidad de corriente desde la fuente hacia el diodo, si se tiene suerte el diodo se quemara y se abrir√° el circuito, si tienes un mal d√≠a tu fuente se da√±ara tambi√©n, los diodos est√°n fabricados para trabajar a un cierta corriente, en el caso de los diodos peque√±os de 5mm la corriente suele estar alrededor de los 10[mA], en el caso de los diodos led de iluminaci√≥n es com√∫n encontrar corrientes de 300[mA]. Calculemos r√°pidamente la resistencia de un led de 5mm rojo de 1.8[V] y 10[mA], que se desea conectar a una fuente de 5[V]. El circuito es el siguiente.\nde la ley de Ohm\n$latex V = Ri$\ndividiendo ambos lados entre la corriente\n$latex \\frac{V}{i} = R \\frac{i}{i} = R$\npara la resistencia R\n$latex R = \\frac{V_R}{i}$\ny la aplicamos a la resistencia R, recordemos que la corriente es un flujo, por lo tanto la corriente que pasa por la resistencia es la misma que pasa por el led, sabemos que el voltaje en la terminal positiva de la resistencia es 5V y el voltaje en la terminal negativa de la resistencia es 1.8V (estamos despreciando la resistencia interna del diodo), por lo tanto el voltaje que hay entre las terminales de la resistencia R es\n$latex V_R = (5 - 1.8) [V] = 3.2[V]$\nsabemos que la corriente de operaci√≥n del led es de 10[mA], por lo tanto la resistencia adecuada debe ser\n$latex R = \\frac{3.2[V]}{10[mA]} = \\frac{3.2[V]}{0.010[A]} = 320 \\Omega$\nla resistencia comercial m√°s cercana es de 330 Ohms, usaremos esa, la corriente disminuir√° una cantidad marginal.\n¬øY si quiero a√±adir un led adicional a la misma fuente?, podemos a√±adir el led de forma paralela al led ya existen y recalcular la resistencia.\nLeds en paralelo\nEl c√°lculo es id√©ntico salvo que ahora la corriente es el doble, pues se requiere satisfacer la corriente de cada diodo $latex i = i_{D1} + i_{D2} = 20[mA]$, la resistencia necesaria es $latex R = 160 \\Omega$, el problema es que la resistencia disipara m√°s potencia, que significa que se calentara m√°s. Un m√©todo m√°s recomendado es conectar una segunda rama (con diodo y resistencia incluidos), en paralelo a la fuente,\nDiodos con resistencia en paralelo\nde esta forma las dos resistencias son iguales a 330 Ohms. Podemos conectar tantas ramas en paralelo como deseemos, el limite es la capacidad de corriente de nuestra fuente, hay que recordar que el limite de un pin del atmega328p es de 40[mA].\n"}),a.add({id:19,href:'/eleckia/posts/bloque-reutilizable-sin-titulo-2/',title:"res",section:"Posts",content:"La ley de Ohm es una herramienta fundamental en la electr√≥nica, en esta ocasi√≥n vamos a calcular la resistencia adecuada para que un diodo pueda operar de forma segura.\nAntes que nada definamos que es un diodo, sin entrar en detalles, un diodo es un dispositivo que permite el flujo de corriente en una sola direcci√≥n, cuenta con dos terminales, el √°nodo y c√°todo, la regla es que si se conecta un voltaje alto al √°nodo y uno bajo al c√°todo, entonces fluye corriente, esta operaci√≥n del diodo se conoce como polarizaci√≥n directa, si se invierten las conexiones se dice que el diodo esta polarizado en inversa y no fluye corriente. Un circuito simple se muestra en la figura,\nCircuito con Diodo\nAhora reemplazamos el diodo por su circuito equivalente,\nDiodo en Directa\nLa resistencia \u0026ldquo;interna\u0026rdquo; del diodo es muy peque√±a por lo que podemos despreciarla, no debemos olvidar que este circuito es un modelo, este modelo funciona bien porque representa el comportamiento del diodo, no significa que dentro del diodo exista una resistencia y una fuente de voltaje, el valor de la fuente de voltaje varia de diodo a diodo, debemos verificar la hoja de datos para ver que voltaje tiene el diodo en cuesti√≥n, en algunos casos el voltaje es peque√±o comparado con el resto de voltajes y simplemente se desprecia, modelando el diodo como un simple corto circuito.\nEn el caso de la polarizaci√≥n inversa el circuito es aun m√°s simple\nDiodo en Inversa\nes un circuito y no hay circulaci√≥n de corriente.\nLed. #  Un led es un diodo que tiene la capacidad de emitir luz, el voltaje del diodo led es mayor que el voltaje de otro tipo de diodos, siendo el rojo el mas peque√±o alrededor de 1.8 [V] y el azul el m√°s grande alrededor de 4.8 [V], esto para leds de 5mm, sin embargo esto valores cambian seg√∫n el tama√±o del led, lo mejor es revisar en la hoja de datos del diodo en cuesti√≥n.\nUn led generalmente se acompa√±a de una resistencia conectada en serie, ¬øpara qu√©?, la respuesta es simple, para limitar su corriente, entendamos que es un corto circuito.\nPartiendo del circuito anterior, tenemos una fuente en serie con una resistencia, recordemos que la corriente es\n$latex i = \\frac{V}{R}$\nun corto se entiende como una conexi√≥n el√©ctrica de cero resistencia entre dos terminales. De esta forma los puntos A y B en el esquema est√°n en corto, dicho de otra manera no hay resistencia entre ellos, esto implica que la corriente puede fluir totalmente entre estos dos puntos, Las terminales C y D no est√°n en corto pues hay una resistencia entre ellas, ¬øque pasar√≠a si quitamos la resistencia?, pues tendr√≠amos a las terminales C y D en corto y las consecuencias serian desastrosas. de la ley de Ohm tenemos $latex i = \\frac{V}{0} = \\infty$, las fuentes no pueden otorgar energ√≠a infinita, est√°n dise√±ada para dar una corriente establecida de corriente, si se sobrepasa el limite se da√±aran, es por eso que nunca debes juntar las terminales de una fuente.\nRegresando a nuestro diodo led, ¬øqu√© pasar√≠a si no colocamos una resistencia entre el diodo y la fuente?,\nDiodo en corto\ncomo dijimos la resistencia del modelo del diodo es muy peque√±a por lo tanto la fuente y el diodo est√°n en corto, es decir fluir√° una gran cantidad de corriente desde la fuente hacia el diodo, si se tiene suerte el diodo se quemara y se abrir√° el circuito, si tienes un mal d√≠a tu fuente se da√±ara tambi√©n, los diodos est√°n fabricados para trabajar a un cierta corriente, en el caso de los diodos peque√±os de 5mm la corriente suele estar alrededor de los 10[mA], en el caso de los diodos led de iluminaci√≥n es com√∫n encontrar corrientes de 300[mA]. Calculemos r√°pidamente la resistencia de un led de 5mm rojo de 1.8[V] y 10[mA], que se desea conectar a una fuente de 5[V]. El circuito es el siguiente.\nde la ley de Ohm despejando la resistencia se tiene\n$latex R = \\frac{V_R}{i}$\ny la aplicamos a la resistencia R, recordemos que la corriente es un flujo, por lo tanto la corriente que pasa por la resistencia es la misma que pasa por el led, sabemos que el voltaje en la terminal positiva de la resistencia es 5V y el voltaje en la terminal negativa de la resistencia es 1.8V (estamos despreciando la resistencia interna del diodo), por lo tanto el voltaje que hay entre las terminales de la resistencia R es\n$latex V_R = (5 - 1.8) [V] = 3.2[V]$\nsabemos que la corriente de operaci√≥n del led es de 10mA, por lo tanto la resistencia adecuada debe ser\n$latex R = \\frac{3.2[V]}{10[mA]} = \\frac{3.2[V]}{0.010[A]} = 320 \\Omega$\nla resistencia comercial m√°s cercana es de 330 Ohms, usaremos esa, la corriente disminuir√° una cantidad marginal.\n¬øY si quiero a√±adir un led adicional a la misma fuente?, podemos a√±adir el led de forma paralela al led ya existen y recalcular la resistencia.\nLeds en paralelo\nEl c√°lculo es id√©ntico salvo que ahora la corriente es el doble, pues se requiere satisfacer la corriente de cada diodo $latex i = i_{D1} + i_{D2} = 20[mA]$, la resistencia necesaria es $latex R = 160 \\Omega$, el problema es que la resistencia disipara m√°s potencia, que significa que se calentara m√°s. Un m√©todo m√°s recomendado es conectar una segunda rama con diodo y resistencia incluidos en paralelo a la fuente,\nDiodos con resistencia en paralelo\nde esta forma las dos resistencias son iguales a 330 Ohms. Podemos conectar tantas ramas en paralelo que deseemos, el limite es la capacidad de corriente de nuestra fuente, hay que recordar que el limite de un pin del atmega328p es de 40[mA].\n"}),a.add({id:20,href:'/eleckia/docs/avr/primitivos/',title:"Variables y tipos",section:"Programaci√≥n Avr en C.",content:"Variables y tipos primitivos #  El lenguaje de programaci√≥n C, es un lenguaje de tipado est√°tico, esto quiere decir que nosotros debemos indicar el tipo de dato que guarda una variable.\n¬øQu√© es una variable?, puede decirse que una variable es un espacio en memoria que guarda un valor determinado, y ¬øqu√© es un tipo?, por tipo de se entiende a una indicaci√≥n hacia el compilador de como se utilizar√° el dato. En C existen los siguientes tipos, tambi√©n llamados tipos primitivos:\n int, enteros almacenan valores enteros, como: 1, 2, -100, 0b11111, 0x32, \u0026hellip; float o double, de punto Flotante, cantidades con decimales como: 1.111, 3.141598, -1.4142, \u0026hellip; char, Caracter. \u0026lsquo;a\u0026rsquo;, \u0026lsquo;y\u0026rsquo;, ' \u0026lsquo;, \u0026lsquo;\\n\u0026rsquo;, \u0026hellip; *, Apuntador, almacena direcciones de memoria.  Existen tipos adicionales pero son variantes de las anteriores, como dijimos para declarar una variable debemos especificar su tipo, esto se hace con la siguiente sintaxis,\ntipo nombre_de_variable; //Una variable entera llamado numero int numero; //Una variable de tipo car√°cter llamada letra char letra; //Una variable de tipo punto flotante llamada cantidad double cantidad; //Un apuntador de tipo entero llamado signal int * signal; ¬øF√°cil no?, pero en la vida nada es f√°cil :D.\nEl tama√±o de los enteros, stdint.h #  Un problema importante es que el tama√±o de los enteros depende del compilador y de otros factores como la arquitectura del microcontrolador, en el caso de los microcontroladores avr de 8 bits, el tama√±o de los enteros declarados con int es 2 bytes, sin embargo en microcontroladores cortex-m suelen ser de 4 bytes, esto provoca que el c√≥digo sea dif√≠cil de portar entre una plataforma y otra, afortunadamente podemos hacer el c√≥digo m√°s portable con la biblioteca stdint.h, con ella podemos especificar el tama√±o de los enteros:\n#include \u0026lt;stdint.h\u0026gt; //entero de 8 bits llamado ocho int8_t ocho; int16_t dieciseis; int32_t treintaydos; Con esto tenemos la seguridad de que los enteros tendr√°n el mismo tama√±o en ambas arquitecturas o en cualquier otra que soporte la biblioteca(la mayor√≠a).\n8 bits pueden almacenar desde -128 a 127 16 bits pueden almacenar desde -32768 a 32767 32 bits pueden almacenar desde -2147483648 a 2147483647 64 bits pueden almacenar desde -9,223,372,036,854,775,808 a 9,223,372,036,854,775,807 Nosotros evitaremos utilizar la declaraci√≥n com√∫n en favor de la declaraci√≥n provista por la biblioteca stdint.h cuando de manipulaci√≥n de registros se trate.\nEl tipo char #  El tipo char sirve para guardar caracteres tiene un tama√±o de 8 bits, es muy com√∫n ver programas donde un tipo char guarda el valor de un registro:\n//variable de tipo char llamada registro que guarda el valor de DDRB; char registro = DDRB; Es preferible guardar el valor de los registros en variable enteras de 8 bits, principalmente por motivos de legibilidad, pero tambi√©n por portabilidad.\n¬øY las palabras? #  En C no existe el tipo string como en otros lenguajes, ciertamente el manejo de strings o mejor dicho de cadenas de caracteres es m√°s doloroso.\nLos strings se representan como arreglos de caracteres (los arreglos se detallan en otra entrada), los arreglos son espacios conjuntos de memoria, un string por lo tanto no es m√°s que una serie de caracteres que son declarados de forma contigua:\nchar palabra[] = \u0026#34;Hola mundo\u0026#34;; //otra forma char * otra = \u0026#34;Adios mundo\u0026#34;; El tipo char puede almacenar los caracteres descritos por el c√≥digo ASCII, incluidos los de control, por ejemplo el car√°cter nulo \u0026lsquo;\\0\u0026rsquo;, o el tabulador \u0026lsquo;\\t\u0026rsquo;, el uso de caracteres suele estar limitado a los dispositivos capaces de mostrarlos, como pantallas por ejemplo.```\nAlgunas personas utilizan el puerto serial para enviar comandos por medio de caracteres, sin embargo es un m√©todo ineficiente, imagina que queremos enviar el n√∫mero 200 desde un microcontrolador a una PC, podr√≠as usar el puerto serial y enviar un \u0026lsquo;2\u0026rsquo;, \u0026lsquo;0\u0026rsquo; y \u0026lsquo;0\u0026rsquo;, cada uno es un car√°cter y tiene un tama√±o de 8 bits, en total son 3x8 bits, sin embargo el n√∫mero 200 puede almacenarse sin problemas en solo 8 bits, ahora supongamos que queremos enviar el n√∫mero 2,000,000,000, enviarlo car√°cter por car√°cter requerir√≠a 8x10 bits, 80 bits, cuando perfectamente ese n√∫mero puede ser almacenado en un entero de 32 bits.\nDouble y float #  El tipo double almacena n√∫meros con punto decimal, por medio de una representaci√≥n de punto flotante. En el lenguaje C moderno para arquitecturas de 64 bits float esta en desuso, sin embargo en microcontroladores avr de 8 bits float y double se implementan igual, ambas tienen un tama√±o de 32 bits.\nLa aritmetica de punto floate es costosa y se realiza por software, otras arquitecturas como los cortex-m4 tienen hardware dedicado para punto flotante, sin embargo es pronto para preocuparse por el rendimiento, sugiero no preocuparse tanto por el comentario anterior.\nApuntadores #  Los apuntadores son la herramienta m√°s poderosa del lenguaje C y tambi√©n la m√°s peligrosa, har√© una entrada dedicada a Apuntadores.\n"}),a.add({id:21,href:'/eleckia/docs/perifericos/gpio/gpio/',title:"Puertos de entrada/salida de prop√≥sito general (GPIO)",section:"GPIO",content:"Puertos de entrada/salida de prop√≥sito general. #  Cando pensamos en programar microcontroladores, lo que queremos es hacer que el mundo se mueva, controlar un motor, un relevador, una lampara, altavoz, etc. Para ello los microcontroladores cuentan con una serie de perif√©ricos. A grandes rasgos un perif√©rico puede definirse como: una interfaz que permite al microcontrolador comunicarse con el exterior, en esta entrada describiremos los puertos de entrada/salida de prop√≥sito general; GPIOx.\nSeg√∫n la hoja de datos el atmega328p tiene hasta 23 pines programables, cada uno con la posibilidad de ser programado individualmente, Arduino Uno tiene 20 pines disponibles, pues 2 est√°n destinados al reloj y el otro est√° destinado al pin de reset.\nLos pines est√°n agrupados en puertos, en el atmega328 contamos con tres puertos disponibles, PORTB, PORTC, PORTD, de manera gen√©rica los llamamos PORTx, cada uno de estos puertos cuentan con tres registros asociados, DDRx, PORTx, PINx, donde \u0026ldquo;x\u0026rdquo; es el puerto(B, C, D), estos nueve registros nos permiten configurar y acceder a los valores de cada uno de los pines del microcontrolador.\nLos pines en el microcontrolador tienen un nombre del tipo Pxn, donde x es el puerto y n es √©l n√∫mero de pin, el pin PB0 y el pin PD7, son el pin 0 y el pin 7 del puerto B y del puerto D respectivamente.\nConfigurar un Pin como Salida. #  La primera necesidad que se resuelve al programar un microcontrolador es encender y apagar un dispositivo externo, todos los pines que corresponden a alguno de los puertos gpio pueden establecerse como salidas, establecer un pin como salida implica dotar a ese pin de la capacidad de entregar o recibir corriente el√©ctrica, cada unos de los pines del atmega328p puede entregar un m√°ximo de 20[mA] y un total de 200[mA] entre todos, esto es bastante aunque no lo parezca, la mayor√≠a de las veces tomaremos alrededor de 1[mA] de cada pin o menos, el objetivo de un microcontrolador es controlar, no dotar de potencia a los dispositivos, cuando se requiere m√°s potencia como para manejar un motor grande, se recurre a electronica adicional dedicada a ese rubro.\nSuponiendo que requerimos encender un led (un led requiere alrededor de 10[mA]) que est√° conectado al pin PB4, Debemos indicarle al registro DDRB que requerimos el pin PB4 como salida:\nDDRB |= 1\u0026lt;\u0026lt;PB4; Para mayores detalles sobre como establecer un bit\nEstablecer el estado cuando el pin es configurado como salida. #  Cuando un pin es configurado como salida, puede entregar/recibir potencia, poquita, pero suficiente para mover al mundo, para ello se requiere establecer el estado del pin, asumiendo que tenemos conectado un led al pin PB4 y que dicho pin esta configurado como salida en el registro DDRB, entonces podemos establecer el estado del pin en el registro PORTB, donde un cero es nivel bajo(0 V) y un uno es nivel alto (5 V).\n//Led encendido PORTB |= 1\u0026lt;\u0026lt;PB4; //Led apagado PORTB \u0026amp;= ~(1\u0026lt;\u0026lt;PB4); Toggle #  Algo muy curioso es que sin un pin esta configurado como salida y se escribe al registro correspondiente de entrada, el pin hace un toggle o un xor, suponiendo que el pin PD1 se encuentre configurado como salida:\nPINB |= 1\u0026lt;\u0026lt;PD1; //El pin se pone en estado alto si estaba en bajo PINB |= 1\u0026lt;\u0026lt;PD1; //El pin se pone en estado bajo si estaba en alto Este es un comportamiento t√≠pico y raro pero √∫til de los avr de 8 bits.\nConfigurar un Pin como Entrada. #  Para poder hacer acciones m√°s complejas requerimos que nuestro microcontrolador pueda \u0026ldquo;sentir\u0026rdquo; al mundo, los pines de nuestro microcontrolador pueden configurarse para que se pueda interpretar el estado de un pin, establecido por un elemento externo (como un bot√≥n pulsador). Para ello tambi√©n se utiliza el registro DDRx, pero en esta ocasi√≥n el pin a ser configurado se establece con un cero.\nDDRC \u0026amp;= ~(1\u0026lt;\u0026lt;PC0); //Pin PC0 como entrada Establecer un pin como entrada implica que el pin es incapaz de recibir y entregar corriente, esto es muy bueno pues el dispositivo que esta enviando los pulsos requiere un gasto de energ√≠a m√≠nimo, por otro lado el pin se vuelve extremadamente sensible a cualquier impulso incluso a las ondas electromagn√©ticas generadas por diferentes fuentes, como lamparas o televisores. Se dice que el pin del microcontrolador esta configurado en modo de alta impedancia. La mayor√≠a de los microcontroladores cuentan con una resistencia de pull up que resuelve este problema.\nResistencia de Pull up. #  Para evitar que el pin configurado como entrada se vuelva loco con solo mirarlo, basta con habilitar una resistencia de pull up en el pin, la resistencia se puede poner de forma externa o habilitar la resistencia interna que el microcontrolador trae para este prop√≥sito, la resistencia de pull up no es m√°s que una resistencia conectada entre el pin y Vcc(5[V] en condiciones normales), de tal forma que el pin se \u0026ldquo;ancla\u0026rdquo; al voltaje de Vcc. La resistencia de pull up tiene un valor grande no se requiere de mucha potencia para \u0026ldquo;desanclar\u0026rdquo; el pin de Vcc por parte del dispositivo que env√≠a la se√±al.\nPara habilitar la resistencia interna de pull up, asumiendo que el pin PC0 se encuentra configurado como entrada:\nPORTC |= 1\u0026lt;\u0026lt;PC0; //PC0 con resistencia de pullUp Desafortunadamente el atmega328p no cuenta con resistencia de pull down.\nLeer el estado de un pin. #  Cuando requerimos leer el estado del pin, utilizamos el registro PINx, contiene el estado de cada unos de los pines del puerto, Para censar al pin, debemos configurarlo como entrada en el registro DDRx.\nPara leer el estado del pin PC3, asumiendo que PC3 esta conectado a 5V y que PC3 esta configurado como entrada en DDRC (con un cero),\nuint8_t entrada = PINC \u0026amp; (1\u0026lt;\u0026lt;PC3); //Es igual a entrada = 0bxxxx1xxx \u0026amp; 0b00001000; //donde las x pueden ser 0 o 1 //aplicando and bit a bit resulta en entrada = 0b00001000; //entrada es exactamente igual a entrada = 8; //si PC0 estuvera conectado a tierra, //entrada resultar√≠a en entrada = 0bxxxx0xxx \u0026amp; 0b00001000; //aplicando and bit a bit resulta en entrada =0b00000000; //o entrada = 0; "}),a.add({id:22,href:'/eleckia/posts/electronica-basica-voltaje-corriente-resistencia-y-ley-de-ohm/',title:"Electr√≥nica B√°sica.- Voltaje, Corriente, resistencia y ley de Ohm.",section:"Posts",content:"Cuando la gente de computaci√≥n escucha las palabras en el titulo de esta entrada, suele entrar en p√°nico y no es para menos, el an√°lisis de circuitos el√©ctricos puede llegar a ser muy complejo; sin embargo la electr√≥nica descansa sobre una ley simple, la ley de Ohm,\n$latex V = iR$\nla ley de Ohm relaciona el voltaje con la corriente y la resistencia; pero esto no nos dice nada si no entendemos estos t√©rminos, comencemos con el voltaje, tambi√©n llamado tensi√≥n o potencial el√©ctrico, en la f√≠sica,\nE_l voltaje se define como la cantidad de trabajo necesaria para mover una carga desde el infinito hasta un punto determinado_.\nAhora que ya sabes y entendiste claramente el voltaje pasemos con lo siguiente (es broma obviamente), la definici√≥n no nos sirve pues se aleja demasiado de la parte pr√°ctica, una forma m√°s laxa y √∫til de interpretarlo es;\nEl voltaje es una fuente de energ√≠a el√©ctrica que impulsa a la corriente el√©ctrica a fluir a trav√©s de un circuito el√©ctrico.\nEsta definici√≥n no rigurosa pero nos es de gran utilidad, por la definici√≥n y por la ley de Ohm, su unidad de medida es el Volt [V], si el voltaje es muy grande la corriente que puede proveer la fuente es de mayor intensidad, por el contrario si el voltaje es negativo, \u0026ldquo;absorbe\u0026rdquo; corriente el√©ctrica.\n¬øPero qu√© es la corriente el√©ctrica?, pues no es m√°s que un flujo de cargas el√©ctricas, flujo de electrones a trav√©s de un medio, usualmente un conductor, pero puede ser incluso a trav√©s del aire form√°ndose un arco el√©ctrico cuando hay voltaje muy alto, su unidad de medida es el Ampere [A], se le representa con un s√≠mbolo \u0026ldquo;i\u0026rdquo; en el esquema a continuaci√≥n, la direcci√≥n de la corriente va de voltaje alto a voltaje bajo; o si solo hay una fuente va de la terminal positiva a tierra (una forma com√∫n de referirse al voltaje o potencial 0[V]).\nDirecci√≥n de la corriente\nUna resistencia es un elemento que se opone a el paso de la corriente, si colocamos en un circuito el√©ctrico un resistencia de 10 Ohms, la corriente que pasa por ella seria mucho mayor que si coloc√°ramos una resistencia de 1000 Ohms.\nPor ejemplo, tenemos una fuente de 5V, una resistencia de 330 Ohms conectada entre sus terminales, ¬øQu√© corriente pasa por la resistencia?\nsabemos que $latex V = i R$, dividiendo ambos lados entre la resistencia\n$latex \\frac{V}{R} = \\frac{iR}{R}$\npor lo tanto, la corriente es\n$latex i = \\frac{V}{R}$\n$latex = \\frac{5}{330}=0.015 [A] = 15 [mA]$\n¬øPor qu√© es importante conocer la corriente?, debido a que cada pin de nuestro microcontrolador tiene poca capacidad de entregar o recibir potencia, dicho de otra forma la corriente que sale de cada pin est√° limitada, para el atmega328p la corriente m√°xima de cada pin es de 40mA y la corriente entre todos los pines no debe ser superior a 200mA, sobrepasar este limite implica da√±ar el microcontrolador, para manejar corrientes grandes mayores a 10[mA] utilizaremos componentes externos.\n"}),a.add({id:23,href:'/eleckia/posts/que-son-los-registros-en-un-microcontrolador/',title:"¬øQu√© son los registros en un microcontrolador?",section:"Posts",content:"Hemos hablado acerca de los registros en anteriores entradas, vamos a profundizar un poco en el tema.\nPara entender un registro, definamos que es un bit, la palabra tiene varias acepciones, para nuestro prop√≥sito un bit es la representaci√≥n de un valor binario, este puede ser 1 o 0. Entonces un registro es sencillamente un conjunto de bits, en nuestro microcontrolador atmega328p, existen registros de 8bits, en otras arquitecturas como los cortex-m los registros son de 32 bits, algunos como el msp de texas instruments, tienen registros de 16 bits.\n¬øEs mejor 32 que 8 bits?, no realmente, la diferencia radica en que un sistema de 32 bits requiere un bus de 32 bits, un bus podr√≠a definirse como un conjunto paralelo de cables que comunica los registros con alg√∫n otro elemento, en otras palabras un bus de 32 bits comunica mayor informaci√≥n por cada ciclo, a priori esto es bueno, sin embargo las instrucciones que tambi√©n viajan por este bus, no necesariamente ocupan los 32 bits, esto deriva en programas m√°s grandes para las arquitecturas de 32 bits. Hoy por hoy las arquitecturas de 32 bits son muy populares, siendo incluso m√°s baratas y eficientes que sus contrapartes de 8 bits, la gran ventaja de los 8 bits radica en su facilidad y simpleza.\nSiguiendo con los registros, programar un microcontrolador se resume a modificar los registros, ya comentamos el registro DDRx, donde x es un puerto determinado (haremos una serie especifica sobre puertos), modificar dicho registro nos permite establecer el comportamiento de cada uno de los pines pertenecientes a dicho puerto. A lo largo de las entradas iremos revisando varios de los registros y explicaremos las implicaciones que se tienen al modificarlos. En realidad DDRx es un nemot√©cnico no un registro, cuando escribimos DDRB, realmente estamos escribiendo algo similar a *(0xfa020121029120), una vez que estudiemos los apuntadores detallaremos que es lo anterior, adelanto que el n√∫mero entre par√©ntesis es la direcci√≥n del registro).\nEl tema de los registros tiene una gran exposici√≥n cuando se programa en ensamblador, el ensamblador es un lenguaje muy estimulante de aprender y el ensamblador de avr es muy limpio y sencillo, quiz√° en el futuro expliquemos un poco.\n"}),a.add({id:24,href:'/eleckia/docs/avr/iniciando/',title:"Programando Avr en C.- Blinky",section:"Programaci√≥n Avr en C.",content:"Comenzando con avr y C #  Para iniciar en la programaci√≥n de dispositivos avr, se requieren algunas cosas:\n Un compilador de C y sus utilidades para avr:  Aunque existen varios compiladores disponibles, avr_gcc es el que se encuentra en la mayor√≠a de los proyectos.   Un editor de texto:  Nuevamente hay muchas opciones, en lo personal prefiero vim.   avrdude, este programa nos ayuda a subir el c√≥digo al microcontrolador.  Escribiendo el programa #  Comenzamos creando un fichero llamado blinky.c, dentro del cual agregamos:\n#include \u0026lt;avr/io.h\u0026gt;La directiva \u0026ldquo;include\u0026lt;\u0026gt; copia el contenido del fichero indicado, en nuestro fichero blinky.c, en este caso copia el contenido del fichero io.h que se encuentra dentro del directorio avr, no nos interesa la ubicaci√≥n del directorio avr, el compilador sabe donde se encuentra y lo incluye de manera autom√°tica. Lo que si nos interesa saber es que incluir el fichero io.h nos permite acceder a los registros que controlan los pines del microcontrolador.\nPosteriormente tenemos la funci√≥n main:\nint main(void) { return 0; } La funci√≥n main es un ente importante, cuando el programa se ejecuta, la funci√≥n main es llamada autom√°ticamente, el c√≥digo dentro de las llaves se ejecutara l√≠nea por l√≠nea, lo que est√© fuera de dicha funci√≥n deber√° ser llamado expl√≠citamente para poder ejecutarse. Por definici√≥n la funci√≥n main retorna un entero al finalizar y en el caso de microcontroladores no suele recibir argumentos por eso la palabra void (m√°s adelante analizaremos la estructura de las funciones).\nDespu√©s viene el superloop,\nint main(void) { while(1){ //tareas 	} return 0; } El superloop es un ciclo infinito que se ejecuta dentro del main, en general las tareas deben definirse dentro del loop de tal forma que se repitan una y otra vez.\nFinalmente tenemos un retorno, como nuestro programa se queda \u0026ldquo;ciclado\u0026rdquo; dentro del while, nunca alcanzaremos esta l√≠nea, sin embargo es conveniente poner esta l√≠nea o el compilador nos dar√° una advertencia.\nYa estamos un poco m√°s familiarizados con la estructura del programa, ahora si analicemos el programa Blink,\n#include\u0026lt;avr/io.h\u0026gt;#include\u0026lt;util/delay.h\u0026gt; int main(void) { DDRB = 1\u0026lt;\u0026lt;PB5; PORTB = 0; while(1){ PORTB = 1\u0026lt;\u0026lt;PB5; _delay_ms(1000); PORTB = 0; _delay_ms(1000); } return 0; } Al inicio tenemos dos directivas include, la primera io.h, nos permite acceder a los registros de los puertos de nuestro microcontrolador, en este caso el puerto B, har√© una entrada especifica para este tema, la segunda delay.h nos permite usar la funci√≥n _delay_ms, que como deducir√°s nos permite crear un tiempo muerto.\nIniciamos con la funci√≥n main y lo primero que tenemos es una asignaci√≥n, te preguntaras que es DDRB, para entenderlo primero debo explicar que es un registro y lo explicare en una entrada dedicada, por ahora vamos a decir que DDRB es una variable a secas, a esta variable le asignamos el resultado de una operaci√≥n 1\u0026laquo;PB5, el s√≠mbolo \u0026ldquo;\u0026laquo;\u0026rdquo; es un operado binario llamado left shift o corrimiento a la izquierda, indica que el n√∫mero a la izquierda sera recorrido el n√∫mero de veces que tiene a la derecha en binario, por ejemplo\n3 en binario es 0b0011 Aplicar un corrimiento a la izquierda en una unidad implica: 3\u0026lt;\u0026lt;1 es exactamente igual a: 0b0011\u0026lt;\u0026lt;1 y da como resultado 0b0110 en decimal 6 En nuestro caso, casi siempre usaremos un 1 a la izquierda del operador, por lo tanto\n1 en binario es 0b1 1\u0026lt;\u0026lt;1 da como resultado 0b10 1\u0026lt;\u0026lt;2 da como resultado 0b100 1\u0026lt;\u0026lt;3 da como resultado 0b1000 1\u0026lt;\u0026lt;7 da como result. 0b10000000 Realmente no nos interesa el valor en decimal, lo que nos interesa es donde queda posicionado el 1, al final de la operaci√≥n con 1\u0026laquo;2, el 1 queda posicionado en la tercera de derecha a izquierda, con 1\u0026laquo;7, queda en la octava de derecha a izquierda.\n¬øPara que es esto?, DDRB es una \u0026ldquo;variable\u0026rdquo; que le indica al microcontrolador si el pin es de entrada o de salida, si el bit es cero, el pin operara como entrada, de lo contrario opera como salida. DDRB contiene 8 bits y cada bit corresponde a un pin de nuestro microcontrolador, al inicio contiene el valor binario 0b0000 0000, si revisas la hoja de datos de tu microcontrolador te dar√°s cuenta que los pines est√°n rotulados con las leyendas PA0, PB0, PC0, PA1, etc, estos son los \u0026ldquo;nombres\u0026rdquo; de los pines y A,B,C, es el puerto al que pertenecen, por lo tanto el pin 5 del puerto B se llama PB5.\nEl pin PB5 esta conectado al led de nuestra tarjeta, hay que decirle a DDRB que ponga el pin 5 como salida, tan f√°cil como:\nDDRB = 1\u0026lt;\u0026lt;PB5; //que es exactamente igual a DDRB = 0b00100000; //bit 76543210 Lo anterior tiene la desventaja de poner al resto de pines como entrada, por ahora no es un problema, pero no es la forma correcta, en otra entrada se dar√° la forma correcta.\nSeguimos adelante y tenemos otra asignaci√≥n, PORTB es otro registro, de igual forma asumiremos por ahora que es una variable, controla el estado del pin, el estado puede ser 0 para bajo o 1 para alto, en s√≠ntesis cuando el pin se configura en alto tendr√° 5 volts y cuando se configura en bajo tendr√° 0 volts, cuando necesitemos encender el led lo configuramos como alto con\nPORTB = 1\u0026lt;\u0026lt;PB5; //que es exactamente igual a PORTB = 0b00100000; ¬øy si queremos ponerlo en bajo?, por ahora solo esto,\nPORTB = 0; //que es exactamente igual a PORTB = 0b00000000; Siguiendo con el programa, entramos al ciclo infinito en donde la parte interesante es la funci√≥n _delay_ms(), la funci√≥n se explica por si misma, cuando se llama toma el control de la ejecuci√≥n del programa y espera la cantidad de tiempo indicada en milisegundos, 1000 para este ejemplo, pasado este tiempo la funci√≥n termina y sigue con la ejecuci√≥n del programa.\nEl programa se queda en este bucle encendiendo y apagando el led cada dos segundos.\nCompilando #  Si no tenemos instalado avr_gcc, en una terminal:\n$ sudo dnf install avr-gcc El proceso de compilaci√≥n es simple, abrimos una terminal, nos dirigimos al directorio donde se encuentra nuestro fichero y escribimos:\n$ avr-gcc -mmcu=atmega328p blinky.c El compilador generar√° un archivo ejecutable en formato elf: a.out, sin embargo se requiere convertir este fichero a otro formato antes de poder grabarlo en el microcontrolador. El archivo a.out contiene informaci√≥n adicional a las instrucciones del programa, para \u0026ldquo;filtrar\u0026rdquo; la informaci√≥n relevante:\n$ avr-objcopy -O ihex a.out blinky.hex La herramienta avr-objcopy extrae las instrucciones y las coloca en el fichero blinky.hex.\nGrabando #  Finalmente utilizamos la herramienta avrdude para grabar el programa\n$ avrdude -c arduino -P /dev/ttyACM0 -p m328p -U flash:w:blinky.hex Un par de segundos despu√©s el led del arduino comenzara a parpadear cada dos segundos.\nEl par√°metro -P /dev/ttyACM0 indica el puerto, desafortunadamente no siempre es el mismo, tambi√©n puede ser /dev/ttyUSB0 o alg√∫n otro, pero por lo general es alguno de esos dos.\n"}),a.add({id:25,href:'/eleckia/posts/bloque-reutilizable-sin-titulo/',title:"save",section:"Posts",content:"El siguiente paso obvio es analizar el programa Blink, sin embargo aqu√≠ no usaremos las bibliotecas de Arduino, usaremos c√≥digo c para dispositivos AVR, entonces ¬øpara que tanto problema instalando la maquina virtual y Arduino?, simplemente porque utilizaremos la infraestructura ya hecha para nuestro prop√≥sito, abrimos el ejemplo Blink y reemplazamos el c√≥digo por:\n#include\u0026lt;avr/io.h\u0026gt; #include\u0026lt;util/delay.h\u0026gt; int main(void) { DDRB = 1 \u0026lt;\u0026lt; PB5; PORTB = 0; while(1){ PORTB |= 1 \u0026lt;\u0026lt; PB5; \\_delay\\_ms(1000); PORTB \u0026amp;= ~(1\u0026lt;\u0026lt;PB5); \\_delay\\_ms(1000); } } compilamos y subimos el c√≥digo, el comportamiento es exactamente el mismo, pero el c√≥digo es totalmente C y no C++, tambi√©n evitamos el uso de las bibliotecas de Arduino en favor de las avr. Esto se nota de inmediato en el tama√±o del programa, mientras que nuestro c√≥digo usa 108 Bytes, el c√≥digo de Arduino usa 924 Bytes, esto realmente no es determinante, en un proyecto complejo y grande usar una biblioteca u otra no tendr√° gran impacto en el tama√±o final. En realidad las Arduino usa como base las bibliotecas avr. Este peque√±o hola mundo, da para comentar muchas cosas, no te preocupes por no entender el c√≥digo iremos desglos√°ndolo en las siguientes entradas, tambi√©n mostrare como liberarnos del IDE y por si fuera poco como liberarnos de la tarjeta.\n¬øPor qu√© no usar unicamente Arduino para todo?, la verdad es que la √∫nica raz√≥n verdadera y valida es que no me gusta, otras razones menos validas son:\n Te limita a un pu√±ado de microcontroladores.- Dentro de la familia de los microcontroladores avr apenas unos cuantos son utilizados para las tarjetas Arduino, existen ports a otras arquitecturas y micros, pero suelen ser limitadas, quiz√° lo que requieres realizar sea un programa muy sencillo, quiz√° no necesites toda la potencia que te ofrece un atmega328p, tal vez lo que necesites sea un attiny13(hiper barato y peque√±o), por el contrario tal vez requieres algo muy r√°pido y potente como un amr cortex m7, o un risc V, no siempre tenemos a disponibilidad las bibliotecas de Arduino, pienso que es importante saber hacer tus propias bibliotecas y adaptarlas a un hardware cambiante. Te obliga a usar C++, aunque es posible enlazar bibliotecas de C++ en C, es un proceso un poco traum√°tico, el problema de C++ es que es muy dif√≠cil de leer, el ejemplo cl√°sico es el siguiente  struct unaEstructura primero = nuevoNumero(); struct unaEstructura segundo = nuevoNumero(); // C a = primero.num + segundo.num; //En C esto tiene un significado obvio // C++ a = primero + segundo; //A priori no sabemos que esta pasando aqu√≠ pudiera parecer una trivialidad, pero de igual forma sucede con varias otras situaciones, realmente es una cuesti√≥n de simple gusto, C++ es un lenguaje muy potente, si te sientes c√≥modo con √©l √∫salo y expl√≥talo al m√°ximo.\n El entorno en general es precario. No se puede tener todo, si es f√°cil tiene que haber un costo, el costo es que no tenemos herramientas de debugging, el editor es horrible, no se adapta muy bien a los proyectos colaborativos, no hay control de versiones.  Sin embargo hay muchas cosas buenas que no se encuentran en ning√∫n otro ambiente, por lo tanto debemos equilibrar nuestras preferencias en aras de obtener el mejor rendimiento y calidad.\n"}),a.add({id:26,href:'/eleckia/docs/workstation/arduino/',title:"Arduino",section:"Estaci√≥n de trabajo",content:"Arduino #  Arduino se compone tanto de software como de hardware, miremos un poco el hardware.\nHardware #  El Arduino Uno (placa de desarrollo), cuenta con un puerto usb, por el que se alimenta la placa; enviamos y recibimos datos, este puerto esta conectado a un circuito integrado FTDI que no es m√°s que un convertidor serial-usb, igualmente este convertidor se conecta a unos pines espec√≠ficos del microcontrolador. Lo importante a destacar es que esta conexi√≥n ya esta hecha y es perfectamente funcional, permitiendo la conexi√≥n entre la placa y pc sin mayores complicaciones, esta es sin duda la gran caracter√≠stica que dio paso al √©xito, una plataforma lista para usarse sin necesidad de componentes adicionales.\nEl convertidor serial varia dependiendo de la versi√≥n de tu tarjeta, pero su comportamiento es similar en todas las versiones. Ahora nos enfocamos en conocer el microcontrolador,\nEl atmega328p es un microcontrolador avr de 8 bits con arquitectura RISC, no entraremos en detalles sobre la arquitectura. Quiz√° el par√°metro m√°s importante de un microcontrolador es la capacidad de memoria con la que cuenta, la asombrosa cantidad de 32KB de flash o memoria de programa y 2KB de ram, teniendo en cuenta que en este momento contamos con PCs regularmente de 8GB de ram y mayores de 1TB de almacenamiento, la memoria del atmega328p parecer√≠a poco, sin embargo se pueden hacer muchas cosas con ella y cuando digo muchas es muchas, adicionalmente cuenta con 1KB de memoria eeprom, en la cual podemos guardar datos y evitar que se pierdan cuando se corta la alimentaci√≥n.\nOtro par√°metro importante es la frecuencia a la que trabaja, siendo hasta 20MHz el m√°ximo posible, internamente cuenta con un oscilador que puede ser configurado hasta 8MHz, si queremos frecuencias mayores podemos conseguirlas conectado un oscilador externo, usualmente un reloj de cuarzo, la regla es que a mayor frecuencia mayor capacidad de procesamiento, pero mayor gasto de energ√≠a. En el caso del Arduino(tarjeta), tiene un reloj de 16MHz ya conectado, por lo que el entorno esta desarrollado con este reloj en mente.\nCuenta con 23 pines programables en la versi√≥n DIP y hasta 32 en la versi√≥n de montaje superficial.\nLos perif√©ricos con los que cuenta\n Timer con output compare ADC USART SPI I2C Y varias fuentes de interrupciones  Describir√© con mucho detalle los perif√©ricos en posteriores entradas.\nAdicionalmente la tarjeta cuenta con un par de hileras de pines donde podemos conectar componentes externos, un jack de alimentaci√≥n por el cual podemos conectar hasta 9V, finalmente un LED conectado al pin 13.\nSoftware #  En cuanto al software, Arduino es un conjunto de bibliotecas que nos permiten programar el microcontrolador de una manera simple y f√°cil, hay bibliotecas para muchos dispositivos, muy probablemente la soluci√≥n a una de tus necesidades o al menos la soluci√≥n parcial se encuentre en forma de biblioteca ya programada por alguien m√°s.\nSin Arduino #  Mi objetivo es exponer al microcontrolador per se m√°s que al ambiente Arduino en general, tan solo sacare provecho de la tarjeta.\n"}),a.add({id:27,href:'/eleckia/docs/workstation/estacion-de-trabajo/',title:"Estaci√≥n de trabajo",section:"Estaci√≥n de trabajo",content:"Estaci√≥n de trabajo #  No es obligatorio instalar Fedora, pero todos los ejemplos se har√°n desde este sistema operativo, eres libre de adaptar lo que aqu√≠ se mencione a tus circunstancias.\nPara poder trabajar a gusto es necesario disponer de un conjunto de herramientas adecuado, dejando de lado el tipo de computadora con la que se cuenta, lo importante es el sistema operativo, utilizaremos software libre, nuestro sistema operativo sera linux, concretamente Fedora, esta distribuci√≥n cuenta con los paquetes necesarios para desarrollar software c√≥modamente, as√≠ que si utilizas algo diferente comienza borrado tu disco duro e instala Fedora (obviamente esto es broma :D).\nLa manera m√°s sencilla de comenzar en este mundo (y la que seguiremos aqu√≠) es con linux + arduino, hablemos r√°pida y brevemente de ellos.\nLinux es una pieza de software que funciona como interfaz entre el hardware de una computadora (memoria, procesador, perif√©ricos, etc), en pocas palabras y de manera muy general, linux se encarga de administrar el hardware de una PC, por otro lado existe software (GNU y otros) que se comunica con linux para formar un sistema operativo, de ah√≠ surgen los sistemas GNU/Linux, a grandes rasgos el software GNU se encarga de administrar el sistema, envi√°ndole instrucciones a Linux (com√∫nmente llamado kernel o n√∫cleo) y este √∫ltimo las ejecuta en el hardware. Para el que este interesado en entender un poco m√°s sobre el origen y filosof√≠a de GNU/linux y el software libre, les recomiendo ver el documental \u0026ldquo;C√≥digo linux\u0026rdquo;, disponible en youtube en espa√±ol. Compa√±√≠as aprovechan este conjunto de software para crear distribuciones, en nuestro caso trabajaremos con la distribuci√≥n Fedora, patrocinada por Red Hat, disponible para su descarga gratuitamente.\nArduino es una plataforma de desarrollo, contiene tanto software como hardware, sera com√∫n referirnos de manera indistinta al software o hardware con la palabra Arduino, con respecto al hardware hay muchas versiones, siendo el \u0026ldquo;Arduino uno\u0026rdquo; el m√°s com√∫n y el que utilizaremos, este Arduino cuenta con un microcontrolador atmega328p, es un microcontrolador de la empresa Microchip, anteriormente le pertenec√≠a a Atmel, pero fue comprada por la anterior mencionada, el microcontrolador es de 8 bits y contiene numerosos perif√©ricos. Arduino es software libre pero tambi√©n hardware libre, esto implica que los clones funcionen de manera id√©ntica a el hardware original, aunque si puedes comprarlo original siempre es bueno apoyar a los creadores. En la parte de software Arduino cuenta con su propio entorno de desarrollo (aunque a mi me parece horrible) y cuenta con miles de bibliotecas listas para ser usadas en nuestros proyectos.\nLo que requerimos:\n-Instalar Fedora\n-Adquirir un Arduino\n-Instalar Arduino dentro de Fedora\nComencemos instalando Fedora, como mencionamos Fedora es un sistema operativo, por lo tanto requerimos instalarlo en nuestra PC, podemos instalar junto a nuestro sistema operativo actual, podemos reemplazar nuestro sistema operativo actual por Fedora o si ya utilizamos Fedora como sistema operativo principal no hay necesidad de reinstalarlo, la √∫ltima opci√≥n es instalarlo en una maquina virtual, si eres usuario windows probablemente esta opci√≥n es la m√°s adecuada para ti.\nUna maquina virtual es un entorno que permite ejecutar un sistema operativo adicional sobre uno ya en ejecuci√≥n, el sistema adicional se conoce como \u0026ldquo;huesped\u0026rdquo;(guess) y el que ya esta en ejecuci√≥n se le denomina \u0026ldquo;anfitri√≥n\u0026rdquo;(host), de esta manera podemos instalar Fedora sin la necesidad de modificar nuestro sistema operativo actual.\nInstalando VirtualBox #  Procedemos a instalar la maquina virtual, para ello visitamos el enlace https://www.virtualbox.org/\ny descargamos la versi√≥n m√°s reciente para nuestro sistema operativo anfitrion(probablemente windows), no entrare en detalles sobre como instalar virtual box puesto que cada sistema es diferente, pero confi√≥ en que sabes como instalar programas en tu sistema, para instalarlo en windows doble click sobre el ejecutable descargado, si eres usuario linux seguramente viene en los repositorios oficiales de tu distribuci√≥n.\nCreando la maquina virtual #  Ahora descargaremos Fedora, accedemos al enlace\nhttps://getfedora.org/es/\nexisten varias ediciones, elegimos Workstation y la descargamos, la descarga es una imagen .iso de alrededor de 2GB, una vez descargado procedemos a instalar.\nAbrimos Virtualbox y seleccionamos \u0026ldquo;nueva\u0026rdquo;\nSe abrir√° una nueva ventana escribimos \u0026ldquo;Fedora\u0026rdquo; en nombre, carpeta la dejamos por defecto, seleccionamos, tipo \u0026ldquo;Linux\u0026rdquo; y Versi√≥n \u0026ldquo;Fedora (64-bit)\u0026rdquo;, click en siguiente.\nAhora nos pide configurar la memoria, aqui aparece un control de deslizamiento, selecciona por lo menos 2GB y da click en siguiente.\nAhora nos pide configurar un nuevo disco duro, seleccionamos \u0026ldquo;Crear un disco virtual Ahora\u0026rdquo; y damos click en siguiente.\nTipo de archivo de disco duro, VDI, siguiente.\nAlmacenamiento en unidad de disco duro f√≠sica, Reservado din√°micamente, siguiente.\nUbicaci√≥n del archivo y tama√±o, dejamos la ubicaci√≥n por defecto y seleccionamos un tama√±o de 20GB, siguiente.\nHemos finalizado la creaci√≥n de la maquina virtual, procedemos a instalar Fedora en el siguiente post.\nInstalando Fedora dentro de VirtualBox #  Abrimos VirtualBox y seleccionamos la maquina virtual Fedora que creamos anteriormente, ahora damos click en Configuraci√≥n, se nos abrir√° una nueva ventana, seleccionamos Almacenamiento y en controlador IDE, seleccionamos Vaci√≥, a la derecha de unidad √≥ptica damos click en el icono de un disco azul y seleccionamos el .iso de Fedora que descargamos anteriormente, finalmente damos click en aceptar.\nSi tienes anfitri√≥n linux, ah√≠ mismo en configuraci√≥n seleccionamos Pantalla y cambiamos Controlador Gr√°fico a VBoxVGA y aumenta la memoria de video a por lo menos 64MB.\nNuevamente en Configuraci√≥n, ahora seleccionamos Sistema y en la pesta√±a Procesador, seleccionamos el n√∫mero de procesadores que tenemos, damos click en aceptar.\nNuestra maquina virtual, esta lista para arrancar y ya tiene el \u0026ldquo;disco\u0026rdquo; de instalaci√≥n insertado, procedemos a iniciarla con el icono Iniciar.\nArrancamos y la primer pantalla de selecci√≥n nos da tres opciones, seleccionamos la primera, Start Fedora, cuidado por defecto esta seleccionada la segunda opci√≥n.\nEsperamos a que el sistema inicie y tenemos una versi√≥n live de Fedora funcionando,\nEsta versi√≥n de Fedora es totalmente funcional, podemos jugar con ella, revisar los programas y menus, cambiar la resoluci√≥n, etc, sabedores de que los cambios que hagamos no se guardaran, cuando estemos listos damos click en Install to Hard Drive. Se abrir√° el asistente de instalaci√≥n Anaconda (puede que tarde unos minutos), aqu√≠ elegimos el idioma y la regi√≥n y damos click en continuar,\nseleccionamos nuestra distribuci√≥n de teclado(probablemente espa√±ol latinoamericano) y la zona horaria, click en Destino de la Instalaci√≥n, sin modificar nada damos click en Hecho en la esquina superior izquierda y comenzamos la instalaci√≥n.\nEsperamos unos minutos a que termine la instalaci√≥n y damos click en salir.\nApagamos la maquina virtual y removemos la imagen .iso de Fedora.\nIniciamos nuevamente la maquina virtual esta vez iniciara Fedora instalado, todo lo que hagamos ahora si se guardara, nos dar√° la bienvenida un asistente de configuraci√≥n donde nos pedir√° algunos datos, de ellos lo importante es el usuario y la contrase√±a, los cuales debemos recordar o en su defecto anotar. Una vez ingresados nuestro sistema estar√° listo para poder instalar Arduino.\nInstalando Arduino #  Ya casi estamos listos, damos click en Actividades y abrimos una terminal, la terminal puede ser intimidante, pero creeme una vez te acostumbres a ella la amaras.\nEn los sistemas linux tenemos diferentes tipos de usuarios cada uno de ellos con diferentes privilegios, el usuario con m√°s privilegios es el usuario root, puede hacer y deshacer el sistema, nuestro usuario por defecto tiene pocos privilegios para evitar que el usuario pueda romper el sistema por accidente. Al abrir la terminal tendremos algo similar a esto\n[eleckia@tuxin-lp ~]$ donde eleckia es el nombre de usuario que se eligi√≥, y tuxin-lp es el nombre que se le dio a la pc, delante del signo $, podemos escribir.\nDNF es el manejador de paquetes de Fedora, es una herramienta que nos permite actualizar, instalar y remover los programas y/o bibliotecas instaladas en nuestro sistema, para utilizarlo simplemente tecleamos\n[eleckia@tuxin-lp ~]$ dnf nos desplegara una enorme lista de las opciones disponibles para este comando, el que nos interesa por ahora es update, esta opci√≥n nos actualiza todos los paquetes a la √∫ltima versi√≥n disponible, tecleamos\n[eleckia@tuxin-lp ~]$ dnf update Error: Este comando debe ejecutarse como usuario root. el error nos indica que requerimos privilegios altos, la forma de escapar de la tiran√≠a el usuario root, es anteponer la palabra sudo,\n[eleckia@tuxin-lp ~]$ sudo dnf update nos pedir√° introducir la contrase√±a que creamos al iniciar Fedora por primera vez, la introducimos y nos desplegar√° la lista de actualizaciones disponibles, nos pedir√° confirmaci√≥n a lo que responderemos s. La primera vez que actualicemos, habr√° muchas actualizaciones, por lo que se tardara un poco, al terminar de actualizar, reiniciaremos el sistema y abriremos nuevamente una terminal, una vez hecho esto instalaremos Arduino por fin. Para instalarlo tan f√°cil como escribir lo siguiente:\n[eleckia@tuxin-lp ~]$ sudo dnf install arduino terminada la descarga e instalaci√≥n, ya tenemos disponible el software Arduino, hacemos click en actividades y lo ejecutamos, nos indicara que debemos agregar nuestro usuario a los grupos dialout y lock, le decimos que si e introducimos la contrase√±a del sistema, tenemos finalmente todo listo para comenzar a programar, tan solo nos falta conectar nuestro Arduino a un puerto usb.\nAnteriormente mencione que trabajaremos con Arduino uno, sin embargo debo confesar que cualquier Arduino de 8 bits es valido, de hecho ni siquiera es necesario instalar Fedora, puedes instalar Arduino en casi cualquier sistema operativo, la raz√≥n de instalar Fedora es que nos ofrece todas las herramientas de manera simple e inmediata, al estar dentro de una m√°quina virtual no debemos preocuparnos de da√±ar el sistema accidentalmente, yo har√© todo desde Fedora, por que es mi sistema instalado, pero sientete libre de utilizar lo que m√°s te acomode, eso si, si tienes alg√∫n problema con tu sistema no podre ayudarte puesto que yo no lo uso (windows). Lo mismo va para la tarjeta Arduino que utilices, funciona cualquiera, pero los registros de cada microcontrolador varian mucho, sobre todo de una arquitectura a otra, los microcontroladores de 8 bits no tiene nada que ver con los micros de 32 o 16 bits.\nNo es de mi inter√©s centrarme en Arduino, pero es la opci√≥n de aprendizaje m√°s adecuada y ser√≠a tonto no empezar con ella.\nLos lugares m√°s comunes para adquirir la tarjeta es ebay, amazon y mercadolibre, es tu elecci√≥n, tambi√©n requerimos algunos dispositivos como leds, resistencias, transistores, capacitores, etc, en el siguiente post daremos algunos detalles adicionales.\nFin #  Finalizamos esta serie de post iniciales con una lista de materiales recomendada, en ebay existen una gran variedad de paquetes donde se incluyen Arduinos, resistencias, capacitores, transistores y algunos sensores, basta con ir a ebay o mercadolibre y buscar kit Arduino, adquirir uno de ellos es un buen comienzo.\nIgualmente puedes adquirir kits de resistencias, capacitores y leds, adem√°s de jumpers, cables y un par de atmega328p DIP adicionales.\nCon esto podemos comenzar nuestro estudio, m√°s adelante requeriremos m√°s componentes, pero se mencionar√°n con forme se requieran.\n"}),a.add({id:28,href:'/eleckia/posts/about/',title:"About",section:"Posts",content:"This is an example of a page. Unlike posts, which are displayed on your blog‚Äôs front page in the order they‚Äôre published, pages are better suited for more timeless content that you want to be easily accessible, like your About or Contact information. Click the Edit link to make changes to this page or add another page.\n"})})()