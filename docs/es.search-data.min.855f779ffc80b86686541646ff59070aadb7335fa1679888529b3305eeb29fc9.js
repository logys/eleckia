'use strict';(function(){const b={cache:!0};b.doc={id:'id',field:['title','content'],store:['title','href','section']};const a=FlexSearch.create('balance',b);window.bookSearchIndex=a,a.add({id:0,href:'/eleckia/docs/workstation/',title:"Estación de trabajo",section:"Docs",content:"Hay que trabajar, hay que aprender, hay que comer, hay que descansar y también hay que jugar, esas son las bases del entrenamiento del maestro Roshi para tener una buena condición.\n-Kame Sennin.\n"}),a.add({id:1,href:'/eleckia/docs/avr/',title:"Programación Avr en C.",section:"Docs",content:"Una línea de Othello sobre un bebedor, ahora un hombre sensible; por el alcohol se convierte en bestia, eso lo explica todo.\nBarney Gómez.\n"}),a.add({id:2,href:'/eleckia/docs/avr/registros/',title:"Registros",section:"Programación Avr en C.",content:"Registros y Acceso #  Registros #  ¿Qué son los registros?, un registro es un espacio en memoria que guarda información, tan simple como eso. En el mundo de los microcontroladores un registro guarda la información que define el comportamiento del microcontrolador.\nCada periférico cuenta con varios registros, listos para ser modificados y leídos para adaptarlos a la solución de un problema en particular.\nEn la arquitectura avr de 8 bits, los registros son de 8 bits, algunos registros se presentan como de 16 bits, pero en realidad son 2 registros de 8 bits, el tamaño lo indica el bus de datos que en avr es de 8 bits, en otras arquitecturas donde el bus es más grande los registros son de otros tamaños.\nLa programación de sistemas embebidos mucho tiene que ver con modificar registros, esta es la principal diferencia aunque no la única con respecto a programa en software de alto nivel.\nAcceso #  Entendido lo que es un registro, veamos como modificarlo.\nYa hemos utilizado registros, por ejemplo DDRB, data direction register del puerto B, establece a los pines como entrada o salida:\n//Establece el pin 5 del puerto B como salida y el resto como entradas DDRB = 0b00100000; sin embargo la sintaxis 0bxxxx no es estándar, únicamente esta disponible via avr-libc, que es la biblioteca principal utilizada por avr-gcc, lo que implica que nuestro código no sea portable si usamos esta sintaxis.\nOtra forma de abordar la asignación es por medio de la notación hexadecimal,\n//0b0010 0000; // 2 0	DDRB = 0x20; El número binario se divide en dos cuartetos y cada uno representa un número en hexadecimal, esto es cierto debido a las propiedades de las bases binarias y hexadecimal, es una forma estandarizada de asignación y es ampliamente utilizada, operaciones con datos de 8 bits son fáciles pero cuando los registros son de 32 bits por ejemplo, las conversiones son más complicadas y se suelen cometer errores, existe otra forma de abordar el problema\nbitwise Corrimiento a la izquierda #  El operador \u0026laquo; corrimiento a la izquierda es un gran aliado para resolver este problema:\n//0b0010 0000; DDRB = 1\u0026lt;\u0026lt;5; Recorre el número a la izquierda del operador el número de veces indicado a la derecha del operador, en este caso recorre el número 1, 5 veces a la izquierda, el corrimiento se hace en la forma binaria del número a la izquierda:\nDDRB = 3\u0026lt;\u0026lt;1; //Daria como resultado 0b110 (6 en decimal) no 30 en decimal  DDRB = 1\u0026lt;\u0026lt;PB5; //Lo que nos intersa es que el 1 quede en la posición PB5 Sin embargo el problema de modificar el resto de pines del registro persiste, veamos la solución a este problema.\nEstablecer un bit #  El operado binario or | es perfecto para solucionar el problema, el operador |, opera en dos números binarios con la regla:\n0 or 0 = 0 1 or 0 = 1 0 or 1 = 1 1 or 1 = 1 Por ejemplo, para los números binarios, 100 y 010, el resultado de hacer un or bit a bit es\nbit2 bit1 bit0 1 0 0 or or or 0 1 0 -------------- 1 1 0 Resultado Asumiendo que el registro DDRB contiene el valor 0000 0111, es decir los 3 primeros bits están configurados como salidas, requerimos hacer que el bit correspondiente a PB5 sea 1, sin modificar el resto, para ello usamos la sintaxis,\nDDRB = DDRB | (1\u0026lt;\u0026lt;PB5); //Es igual a DDRB = 0b00000111 | 0b00100000; //despues de hacer or, resulta DDRB = 0b00100111; //DDRB queda con el bit PB5 en 1 y el resto sin modificar Una notación más compacta y equivalente es:\nDDRB |= 1\u0026lt;\u0026lt;PB5; También es posible encadenar varios pines:\nDDRB |= 1\u0026lt;\u0026lt;PB5 | 1\u0026lt;\u0026lt;PB0 | 1\u0026lt;\u0026lt;PB3; Limpiar un bit #  Con limpiar un bit me refiero a ponerlo en cero, para ello el operador binario and \u0026amp; es el indicado, el operado \u0026amp; opera con dos números binarios con la regla:\n0 and 0 = 0 0 and 1 = 0 1 and 0 = 0 1 and 1 = 1 Por ejemplo en los siguientes números binarios el resultado es,\nbit2 bit1 bit0 1 0 0 and 0 1 0 -------------- 0 0 0 Resultado Otro operador (en este caso unario) importante es el complemento a uno ~, cambia el valor de 1 a 0 y de 0 a 1, por ejemplo:\n1010 ~ ----- 0101 Resultado Asumiendo que el registro DDRC contiene el número 0b0010 0011, requerimos configurar el pin PC0 como entrada, asignar DDRC = 0 no es aceptable (colocaría todos los pines como entrada), en su lugar usaremos el siguiente código\nDDRC = DDRC \u0026amp; ~(1\u0026lt;\u0026lt;PC0); //Primero se realiza (1\u0026lt;\u0026lt;PC0), resulta DDRC = DDRC \u0026amp; ~0b00000001; //Ahora se aplica el operador complemento, resulta DDRC = DDRC \u0026amp; 0b11111110; //Operador And bit a bit, DDRC = 0b00100011 \u0026amp; 0b11111110; //Resulta DDRC = 0b00100010; De esta forma logramos establecer el pin requerido sin afectar el resto. Por supuesto también se pueden limpiar varios pines:\nDDRC \u0026amp;= ~(1\u0026lt;\u0026lt;PC0 | 1\u0026lt;\u0026lt;PC1 | 1\u0026lt;\u0026lt;PC5); "}),a.add({id:3,href:'/eleckia/docs/avr/programando-avr-en-c-arreglos/',title:"Programando Avr en C. Arreglos.",section:"Programación Avr en C.",content:"Los arreglos o arrays son elementos que permiten hacer colecciones de datos del tipo indicado, su uso es amplio en prácticamente todos los lenguajes de programación, en C los arreglos se declaran con la siguiente sintaxis,\ntipo_dato nombre_array[TAMAÑO]; Por ejemplo para declarar un arreglo de 5 enteros llamado horas:\nint horas[5]; Para declarar un arreglo de 3 boleanos llamado respuestas:\n#include\u0026lt;stdbool.h\u0026gt; bool respuestas[3]; Los arreglos pueden ser de cualquier tipo de dato. El número entre corchetes (paréntesis cuadrados) indica la cantidad de elementos que puede almacenar, en el caso del arreglo horas, este puede almacenar hasta 5 enteros, la forma de asignar los valores es la siguiente:\nint horas[5] = {1, 2, 1, 2, 3}; //o también int horas[5]; horas[0] = 1; horas[1] = 2; horas[2] = 1; horas[3] = 2; horas[4] = 3; Ambas asignaciones resultaran en los mismos enteros para el arreglo, nótese que cuando asignamos los valores, la primera posición es cero y no uno, esto implica que la última posición sea cuatro y no cinco, si asignáramos horas[5] = 4; obtendríamos un error en tiempo de ejecución, este error es muy diferente de el error en tiempo de compilación, de hecho el programa compilara sin error, pero si se intenta ejecutar dentro del microcontrolador la ejecución sera errática, probablemente el programa se reinicie al tratar de ejecutar la instrucción o tal vez se detenga en ese instante, o tal vez no pase nada, depende de la forma en que se organiza la memoria en el micro, por lo tanto hay que tener cuidado en no rebasar el indice, el máximo es igual a el tamaño menos uno.\nArreglos y apuntadores. #  Los arreglos y apuntadores tienen una relación importante, el nombre de un arreglo es un apuntador que apunta a la dirección del primer elemento o elemento cero,\nint numeros[2] = {1, 4}; int a = *numeros + numeros[1]; //a contendra el valor de 5 A pesar de esta equivalencia, prefiero utilizar los corchetes cuando de arreglos se trata, esto me evita la sobrecargar de conceptos en la cabeza y me permite diferenciar claramente el propósito de un arreglo y el de un apuntador, con el arreglo quiero manejar una colección de datos, mientras que con los apuntadores quiero manejar el acceso a objetos individuales.\n"}),a.add({id:4,href:'/eleckia/posts/principio-de-responsabilidad-unica-srp/',title:"Principio de responsabilidad única (SRP)",section:"Posts",content:"En el desarrollo ágil, el principio de responsabilidad única es uno de los cinco principios fundamentales, el principio define lo siguiente:\nUn módulo debe tener un solo motivo para cambiar.\nY eso es todo, ¿fácil no?, yo también lo creo, ¿qué es lo que creo?, no lo entiendo. Vamos por partes, las palabras son obvias, pero la frase es un poco ambigua, el meollo del asunto es claramente un solo motivo para cambiar, podemos apoyarnos en el nombre del principio, responsabilidad única, mmm parece ser que ambas frases se refieren a lo mismo, ¿a qué mismo?, mmm, lo que esta claro es que un módulo solo debe tener una sola responsabilidad, por ejemplo suponiendo que requerimos un sistema que controle el movimiento de un robot móvil, el robot puede ir hacia adelante, atrás y rotar las ruedas de dirección, una forma de visualizarlo es la siguiente,\nSeparación obvia.\nSe sugiere una separación de responsabilidades, en lugar de que el módulo robot_posición administre el avance, retroceso y giro, separamos las responsabilidades y las asignamos a nuevos módulos, esta separación es lo primero que se me vino a la mente, ¿pero esta separación es la más adecuada?, las repuesta no es evidente ni definitiva, es aquí donde recurrimos a la definición un solo motivo para cambiar, los módulos traslación y rotación cumplen con el principio srp, solo si al requerir una nueva característica, solo uno de los dos módulos necesita modificarse.\nSuponiendo que los requerimientos cambian y que se requiere que la velocidad a la que se mueve el robot hacia adelante y atrás sea controlable, es evidente que el módulo traslación sera el único que cambie, por lo tanto la separación que se realizo es adecuada y cumple con el principio srp.\nAhora suponiendo que la especificación cambia, se desea que el robot tenga movimiento continuo, es decir que el robot avance hacia adelante o atrás mientras está rotando. Ahora nuestros módulos no cumplen con el principio, pues ambos deben ser modificados para alcanzar los nuevos requerimientos, este será un buen momento para replantear nuestra anterior separación en módulos, una refactorización nos da el siguiente modelo,\nDe esta manera velocidad solo se encarga de mover los motores avance y de retroceso, tren_de_giro se encarga de girar un motor de dirección o el ajuste necesario dependiendo de la forma del robot.\nCon esto quiero decir que los módulos deben agruparse de tal forma que las razones por las que cambian estén juntas, con esto logramos que al agregar nuevos cambios, solo debamos modificar el mínimo de módulos.\n¿Y cuales son esas razones de cambio?, la respuesta es el cliente, el usuario, si el cliente del módulo hace una nueva especificación que implique un cambio y para lograr la implementación se requieren modificar más de un módulo se debe replantear la forma y el tamaño de los módulos.\nRepito, el objetivo del SRP es proveer una forma de \u0026ldquo;modularizar\u0026rdquo; el programa en base a peticiones de cambios, aunque exista la tentación de agrupar módulos por forma, color, sabor, etc, que pudieran parecer más naturales, agrupar por motivos de cambios, nos dará como resultado un software altamente ágil en el sentido de nuevas características.\nEn el ejemplo anterior, ¿que sentido tendría mezclar el código de control de posición con el código de control visión del robot?, si nosotros requerimos modificar el contraste o el brillo de la imagen, ¿sería necesario modificar la velocidad del robot?, las respuesta obvia es que no, sin embargo piensa que las cámaras aveces son muy lentas, quizá requerimos tomar una imagen cuando el robot se acerque a un objeto, entonces si la cámara es lenta necesariamente requerimos bajar la velocidad, ni modo, es triste, pero debemos refactorizar los módulos en harás de lograr el objetivo.\nEl SRP es el principio más sencillo de describir, pero el más difícil de asimilar, requiere práctica, esfuerzo, experiencia y mucha meditación.\n"}),a.add({id:5,href:'/eleckia/posts/solid/',title:"SOLID",section:"Posts",content:"_Soy malo y eso es bueno, yo jamás seré bueno y eso no es malo, no hay nadie que quiera ser además de mi. #  - Ralph el demoledor._\nSOLID #  Dentro del mundo de la programación existen los famosos paradigmas de programación, entre ellos: la programación funcional, la programación orientada a eventos, la programación estructurada, la programación orientada a objetos y otros más. En esta fecha 2020, la programación orientada a objetos sin duda domina la forma en que se escribe el software en general, vale la pena aprender este paradigma pues no será raro encontrarnos con programas basados en él.\nEl éxito de la programación orientada a objetos, se basa en la abstracción de objetos, ¿qué es la abstracción de objetos?, personalmente la defino como una combinación entre imaginar, separar y simplificar, es decir tomamos un objeto real por ejemplo un motor, identificamos lo que nos interesa por ejemplo la velocidad y la dirección de giro y descartamos el resto de detalles, el tipo de motor, la potencia, la tensión de entrada, el par, marca, color, peso, etc, este motor que únicamente gira a la velocidad y dirección indicada, es una abstracción de un motor real, esto que parece tan trivial tiene la cualidad de simplificar la forma en que se resuelven los problema, pues los humanos estamos adaptados a pensar en objetos abstractos.\nDentro de la programación orientada a objetos han surgido diferentes corrientes de desarrollo, en los últimos años el desarrollo ágil gano una popularidad importante. En las catacumbas de un lugar de cuyo nombre no quiero acordarme, se reunió un grupo de programadores con gran experiencia en el desarrollo de software, conspirando en contra de la técnicas tradicionales escribieron el manifiesto ágil,\nhttps://agilemanifesto.org/iso/es/manifesto.html\nuna vez popularizado el desarrollo ágil comenzaron a desarrollarse numerosas metodologías de trabajo, entre ellas: scrum, kaban, xp, tdd, etc, como mencione las personas funcionamos en base a abstracciones por lo que las metodologías ágiles pueden salir del mundo de la programación e implementarse en otros rubros de la humanidad.\nPersonalmente yo no me sentí seguro con mi código hasta que aprendí TDD (Test Driven Development), Desarrollo Guiado por Pruebas.\nAquí tratare de describir los cinco principios fundamentales del desarrollo ágil, acuñados por Robert C. Martin, Agile Software Development, Principles, Patterns, and Practices. Es un excelente referencia para cualquiera que pretenda aprender a programar.\nSOLID es un acrónimo formador por los cinco principios del desarrollo ágil.\nS Single responsibility principle (Principio de responsabilidad única)\nO Open/closed principle (Principio Abierto/Cerrado)\nL Liskov substitution principle (Principio de sustitución de Liskov)\nI Interface segregation principle (Principio de segregación de la interfaz)\nD Dependency inversion principle (Principio de inversión de dependencia)\nSi cumplimos con estos principios dentro de nuestro código, entonces podemos decir que nuestro código es ágil\n Sigue mi blog #  Recibe nuevo contenido directamente en tu bandeja de entrada.\n[jetpack_subscription_form subscribe_placeholder=\u0026ldquo;Introduce tu dirección de correo electrónico\u0026rdquo; show_subscribers_total=\u0026ldquo;false\u0026rdquo; button_on_newline=\u0026ldquo;false\u0026rdquo; submit_button_text=\u0026ldquo;Registrarse\u0026rdquo; custom_background_emailfield_color=\u0026ldquo;undefined\u0026rdquo; custom_background_button_color=\u0026ldquo;undefined\u0026rdquo; custom_text_button_color=\u0026ldquo;undefined\u0026rdquo; custom_font_size=\u0026ldquo;16\u0026rdquo; custom_border_radius=\u0026ldquo;0\u0026rdquo; custom_border_weight=\u0026ldquo;1\u0026rdquo; custom_border_color=\u0026ldquo;undefined\u0026rdquo; custom_padding=\u0026ldquo;15\u0026rdquo; custom_spacing=\u0026ldquo;10\u0026rdquo; submit_button_classes=\u0026quot;\u0026quot; email_field_classes=\u0026quot;\u0026quot; show_only_email_and_button=\u0026ldquo;true\u0026rdquo; ]\n"}),a.add({id:6,href:'/eleckia/posts/electronica/',title:"Electrónica",section:"Posts",content:"Ah, ¿pero que oigo?, una intromisión, debe ser #  Lisa Simpson, la respuesta a una pregunta que\nnunca hizo nadie.\n-Ned Flanders\n Sigue mi blog #  Recibe nuevo contenido directamente en tu bandeja de entrada.\n[jetpack_subscription_form show_only_email_and_button=\u0026ldquo;true\u0026rdquo; custom_background_button_color=\u0026ldquo;undefined\u0026rdquo; custom_text_button_color=\u0026ldquo;undefined\u0026rdquo; submit_button_text=\u0026ldquo;Suscribir\u0026rdquo; submit_button_classes=\u0026ldquo;undefined\u0026rdquo; show_subscribers_total=\u0026ldquo;false\u0026rdquo; ]\n"}),a.add({id:7,href:'/eleckia/docs/avr/programando-avr-en-c-apuntadores-punteros-pointers-ii-apuntadores-dobles/',title:"Programando Avr en C.- Apuntadores, punteros, pointers III. Apuntadores Dobles.",section:"Programación Avr en C.",content:"Los apuntadores suenan bastante complejos, nuestro cerebro amplifica su complejidad, pero al igual que cualquier otra variable su funcionamiento es simple,\ntipo ** nombre_apuntador; a que me refiero con apuntador doble, a un apuntador que guarda direcciones de otros apuntadores de su mismo tipo,\nchar caracter1 = 'a'; char caracter2 = 'b'; char \\* letra = \u0026amp;caracter1; char \\*\\* apuntador\\_doble = \u0026amp;letra; \\*apuntador\\_doble = \u0026amp;caracter2; //ahora letra apunta a la dirección de caracter2, //\\*letra es 'b' el propósito evidente de los apuntadores dobles, es cambiar el valor a donde apuntan apuntadores simples,\nint \\* pointer1=NULL; int \\* pointer2=NULL; void updatePointers(int \\*\\* a, int \\*\\* b) { \\*a = direction\\_1; \\*b = direction\\_2; } //ahora los apuntadores apuntan a las //direcciones en direction\\_n Esta aplicación es muy sencilla, la usaremos con frecuencia.\n"}),a.add({id:8,href:'/eleckia/docs/avr/programando-avr-en-c-apuntadores-punteros-pointers-ii-apuntadores-a-funciones/',title:"Programando Avr en C.- Apuntadores, punteros, pointers II. Apuntadores a funciones.",section:"Programación Avr en C.",content:"Como ya he dicho un apuntador es una variable que apunta a direcciones de memoria, también hemos mencionado que los apuntadores deben ser especificados sobre el tipo, cuando las funciones se compilan se les asigna una dirección en memoria, ¿existirán apuntadores a funciones?, la respuesta es afirmativa, la sintaxis es un poco rara,\ntipo (*nombre_apuntador)(argumento1, argumento2, ..., argumento_n); al igual que los apuntadores comunes, los apuntadores a funciones deben ser especificados con el tipo de dato que regresan, entre parentesis se coloca el operador * seguido del nombre del apuntador, finalmente se especifican los parámetros)\nint (\\*operacion)(int a, int b); int suma(int a, int b) { return a + b; } int resta(int a, int b) { return a - b; } int a = 5; int b = 10; if(condicion) operacion = suma; else operacion = resta; int c = operacion(a , b); /\\* Sí condición es verdadera c contendrá 15 de \\* lo contrario c contendrá -5 \\*/ gracias a los apuntadores a funciones, también es posible pasar funciones como argumentos de otras funciones,\nint operadorBinario(int (\\*operation)(int a, int b), int c, int d) { return operation(c,d); } int resultado = operadorBinario(suma, 5, 10); //resultado es igual a 15 resultado = operadorBinario(resta, 5, 10); //resultado = -5; Esta característica nos ayudara a mejorar la calidad del código.\n"}),a.add({id:9,href:'/eleckia/docs/avr/programando-avr-en-c-apuntadores-punteros-pointers/',title:"Programando Avr en C.- Apuntadores, punteros, pointers I.",section:"Programación Avr en C.",content:"Los apuntadores (pienso que esta es la traducción más acertada), también conocidos como punteros o pointers en ingles, es un tipo de dato característico de lenguajes de bajo nivel y algunos de nivel medio, C por supuesto cuenta con tal tipo de dato.\nUn apuntador es una variable cuyo tipo de dato almacena direcciones de memoria, tan simple como eso. Aunque una dirección de memoria puede ser interpretada como un entero, es mejor pensar que una dirección de memoria es un tipo de dato diferente, un tipo de dato de tipo apuntador.\nLos apuntadores son temidos y exaltados, por buenas razones, el problema es que los apuntadores sirven para gran cantidad de aplicaciones y da la impresión de que debes conocerlas todas, por supuesto no es así, se puede usar apuntadores de forma efectiva sin tener todo el bagaje técnico alrededor, e ir aprendiendo gradualmente los pormenores. El secreto esta en auto limitarse y ser disciplinado.\nla sintaxis para declarar un apuntador es la siguiente\ntipo_a_donde_apunta * nombre_apuntador; un apuntador que apunta a una variable de tipo entero es diferente a un apuntador que apunta a una variable de tipo carácter,\nchar a; int b; int * apuntador1; // solo puede apuntar hacia b, apuntar hacia a implica un error Operador addressOff \u0026amp; #  Para almacenar la dirección de una variable primero debemos obtener su dirección, para ello contamos con el operador \u0026amp;,\nint b = 0; int * apuntador = \u0026amp;b; //apuntador ahora contiene la dirección de memoria de b Operador de indirección * #  ¿Para que se usa un apuntador?, como mencione las aplicaciones son amplias, pero la base es la misma, se trata de acceder al contenido guardado en una dirección de memoria de manera indirecta. Una vez establecido un apuntador, usamos el operador de indirección para acceder al contenido a donde apunta.\nint b = 0; int * apuntador = \u0026amp;b; *apuntador = 10; //ahora b contiene el valor 10 y no 0. Una de las aplicaciones más importantes es el paso de parámetros a funciones, cuya intensión sea modificar tales parámetros, por ejemplo\nint a = 5; int b= 3; //Se pasan dos apuntadores intercambiar(\u0026amp;a, \u0026amp;b); //pasar \u0026amp;a, es equivalente a crear un apuntador //int *apuntador = \u0026amp;a y escribir intercambiar(apuntador, \u0026amp;b); //ahora a = 3 y b = 5; void intercambiar(int * v1, int * v2) { int tmp = *v1;//tmp = valor guardado en la //dirección a donde apunta v1 *v1 = *v2; *v2 = tmp; } Usaremos ampliamente la forma de la función intercambiar, por ahora es suficiente con este conocimiento sobre apuntadores, por supuesto más adelante veremos otras aplicaciones.\n"}),a.add({id:10,href:'/eleckia/posts/contacto/',title:"Contacto",section:"Posts",content:"Hablemos 👋. No dudes en ponerte en contacto con nosotros mediante la información de contacto a continuación, o envíanos un mensaje mediante el formulario.\nPonte en contacto con nosotros #  Calle Ejemplo, 10\nCiudad, 10100\nEspaña\ncorreoelectronico@ejemplo.com\n(+34) 399 555 234\nEnvíanos un mensaje #  "}),a.add({id:11,href:'/eleckia/posts/gpio-atmega328p/',title:"GPIO atmega328p.",section:"Posts",content:"_Si, se nos acabo la duela y pintamos la tierra, ¿qué trucazo no? #  Moe Szyslak_\n Sigue mi blog #  Recibe nuevo contenido directamente en tu bandeja de entrada.\n[jetpack_subscription_form subscribe_placeholder=\u0026ldquo;Dirección de correo electrónico\u0026rdquo; show_subscribers_total=\u0026ldquo;false\u0026rdquo; button_on_newline=\u0026ldquo;true\u0026rdquo; submit_button_text=\u0026ldquo;Suscribir\u0026rdquo; custom_background_emailfield_color=\u0026ldquo;undefined\u0026rdquo; custom_background_button_color=\u0026ldquo;undefined\u0026rdquo; custom_text_button_color=\u0026ldquo;undefined\u0026rdquo; custom_font_size=\u0026ldquo;16\u0026rdquo; custom_border_radius=\u0026ldquo;0\u0026rdquo; custom_border_weight=\u0026ldquo;1\u0026rdquo; custom_border_color=\u0026ldquo;undefined\u0026rdquo; custom_padding=\u0026ldquo;15\u0026rdquo; custom_spacing=\u0026ldquo;10\u0026rdquo; submit_button_classes=\u0026ldquo;has-text-color has-background-color has-background has-primary-background-color\u0026rdquo; email_field_classes=\u0026quot;\u0026quot; show_only_email_and_button=\u0026ldquo;true\u0026rdquo; ]\n"}),a.add({id:12,href:'/eleckia/docs/avr/programando-avr-en-c-el-flujo-del-programa-if-else-if-else/',title:"Programando Avr en C.- El flujo del programa, if, else, if else.",section:"Programación Avr en C.",content:"Definimos el flujo del programa como, la ruta que toma la ejecución del mismo, imaginemos que tenemos una lista de tareas que debemos ejecutar, digamos, tarea 1, tarea 2, tarea 3, \u0026hellip;, tarea n, ya vimos que podemos abstraer tareas como funciones, entonces simplemente podemos agregar cada una de las funciones en orden para ejecutarlas,\nint main(void) { tarea1(); tarea2(); tarea3(); tarean(); return 0; } pero que pasa si queremos ejecutar alguna de estas tareas solo si se cumple una condición, digamos, solo si se pulsa un botón determinado, o solo si el resultado de una operación satisface algún requerimiento.\nPara ello contamos con la palabra if, si se cumple una condición, el código dentro de sus llaves se ejecutara, de lo contrario el programa continuara después de la llave de cierre,\nint main(void) { tarea1(); if(condicion){ //si condición es verdadera tarea2(); //se ejecutaran ésta dos tareas tarea3(); } tarea4(); //Aquí continua tarean(); return 0; } también es posible agregar la palabra else, para controlar el flujo cuando la condición es falsa\nint main(void) { tarea1(); if(condicion){ //si condición es verdadera tarea2(); //se ejecutara ésta tarea }else{ tarea3(); //si condición es falsa, ejecuta ésta tarea } tarea4(); tarean(); return 0; } agregar más sentencias nos permite un control aun más preciso.\nint main(void) { tarea1(); if(condicion == 0){ //si condición es igual a 0 tarea2(); //se ejecutara ésta tarea }else if(condicion == 1){ tarea3(); //si condición igual a 1, ejecuta ésta tarea }else{ tarea4(); //si no se cumple ninguna de las anteriores } tarean(); return 0; } es importante señalar que la ejecución es en orden descendente, si tenemos varios if else y en más de uno se cumple la condición, solo se ejecutara el primero que la cumpla en orden descendente.\nint main(void) { tarea1(); if(true){ tarea2(); //se ejecutara ésta tarea }else if(true){ tarea3(); //No se ejecuta }else{ tarea4(); //No se ejecuta } tarean(); //una vez ejecutada tarea2, el programa continua aquí return 0; } "}),a.add({id:13,href:'/eleckia/docs/avr/programando-avr-en-c-constantes/',title:"Programando Avr en C.- Constantes",section:"Programación Avr en C.",content:"Las constantes son de gran utilidad en la programación, a diferencia de las variables, las constantes no pueden cambiar su valor.\nLas dos formas más comunes de definir constantes son con la palabra reservada const y con la directiva define.\nLa palabra const #  Agregando la palabra const a la declaración de una variable, esta se convierte en constate, sin embargo también debe asignarle el valor al momento de la declaración;\nuint8_t const NUMERO = 10; //Declaración de una constante NUMERO = 1; //error, no se puede reasignar Sin embargo el uso más cotidiano que tiene la palabra const es en los argumentos de funciones,\nint8_t suma(int8_t const sumando1, int8_t const sumando2); Directiva define #  Entre otras cosas, la directiva define puede ser usada para definir constantes;\n#define NUMERO 10 cuando el programa se compilar, la palabra NUMERO, se reemplaza por el número 10,\n#define PRIMERO 5 int8_t = 5 + PRIMERO; al compilar, sera reemplazado por\nint8_t = 5 + 5; Enum #  Los enum son un tipo de dato que nos facilitá la creación de colecciones de constantes, su sintaxis es\nenum NOMBRE{CONSTANTE1 = 0, CONSTANTE2, CONSTANTE3 = 5, CONSTANTE4}; de esta forma CONSTANTE1 es una variable de tipo enum NOMBRE y contiene el valor de 0, CONSTANTE2 contiene el valor 1 y CONSTANTE3 tiene el valor de 5 y CONSTANTE4 tiene el valor de 6.\nenum numeros{CERO, UNO, DOS}; a = CERO + UNO + DOS; //a contiene el número 3 ¿Por qué usar constantes? #  Hay dos conceptos al utilizar constantes, ser constante y querer ser constante.\nSer constante se refiere a declarar una constante explícitamente por ejemplo el número PI, SQRT2, etc.\nQuerer ser constante, se refiere a evitar que las variables cambien por accidente su valor, por ejemplo las funciones suele recibir parámetros constantes, se busca evitar que los parámetros cambien su valor, esto tomara sentido cuando comentemos los apuntadores en entradas posteriores.\nMuchos lenguajes de programación nuevos, definen a las variables como constantes (inmutable) y es el usuario quien explícitamente declara una variable como variable (mutable), la razón principal como se menciona es reducir la posibilidad de añadir errores de programación.\n"}),a.add({id:14,href:'/eleckia/docs/avr/control_flujo/',title:"Control de flujo (if, while, for)",section:"Programación Avr en C.",content:"Control de flujo #  El control de flujo es el pilar de la programación estructurada, a pesar de que el paradigma de la programación estructurada pueda considerarse anticuada para algunos, lo cierto es que la solución de los algoritmos siempre requiere control de flujo; condicionales y repeticiones, antes de adentrarnos en el tema, revisemos el tipo de dato booleano.\nTipo de dato Booleano #  Otro tipo de datos básico es el tipo booleano, aunque por raro que parezca en C, no existía este tipo de dato originalmente, actualmente se requiere incluir la biblioteca;\n#include \u0026lt;stdbool.h\u0026gt;El tipo de dato bool puede contener únicamente dos valores, verdadero(true) o falso(false), la sintaxis es:\n#include\u0026lt;stdbool.h\u0026gt;//Para declarar una variable bool un_nombre; //Para definir un valor un_nombre = true; un_nombre = false; Para asumir la carencia del tipo de dato bool, C que cualquier valor diferente de 0o NULL es verdadero, sin embargo es mejor utilizar explícitamente los valores true o false para denotar valores booleanos, por razones de legibilidad.\nOperadores booleanos #  Como el nombre sugiere, los operadores booleanos operan sobre tipos de dato booleanos y dan como resultado un booleano.\nEl operador and (\u0026amp;\u0026amp;) probablemente es el más utilizado,\ntrue \u0026amp;\u0026amp; true //Resulta true true \u0026amp;\u0026amp; false //Resulta false false \u0026amp;\u0026amp; true //Resulta false false \u0026amp;\u0026amp; false //Resulta false El operador or (||)\ntrue || true //Resulta true true || false //Resulta true false || true //Resulta true false || false //Resulta false El operador de negación (!)\n!false //Resulta true !true //Resulta false Operadores de comparación #  Los operadores de comparación, comparan dos expresiones y evalúan el resultado como falso o verdadero.\nIgualdad:\n10 == 10 //true \u0026#39;a\u0026#39; == \u0026#39;b\u0026#39; //false Diferencia:\n10 != 10 //false \u0026#39;a\u0026#39; != \u0026#39;b\u0026#39; //true Menor que:\n10 \u0026lt; 11 //true 10 \u0026lt; 10 //false Mayor que:\n10 \u0026gt; 11 //false 11 \u0026gt; 10 //true Menor o igual que:\n10 \u0026lt;= 11 //true 10 \u0026lt;= 10 //true Mayor o igual que:\n10 \u0026gt;= 11 //false 10 \u0026gt;= 10 //true Condicionales, if, else #  El termino control de flujo se deriva de los diagramas de flujo, una técnica gráfica de diseño de programas estructurados, en ellos existe un bloque llamado if, el cual tiene la capacidad de decidir la siguiente acción en base a una condición, en C:\nbool condicional; if(condicional){ //Ejecuta este código si condicional es verdadero } el complemento de if es else:\nbool condicional; if(condicional){ //Ejecuta este código si condicional es verdadero }else{ //Ejecuta este código si condicional es falso } también es posible hacer comparaciones intermedias:\nif(condicion1){ //Ejecuta este código si condicion1 es verdadera }else if(condicion2{ //Ejecuta este código si condicion1 es falso y si condicion2 es verdadera }else if(condicion3){ //Ejecuta este código si condicion1 y condicion2 son falsos y condicion3 	//es verdadera }else{ //Ejecuta este código si todas las condiciones son falsas } Debe resaltarse que la evaluación de las condiciones se detiene cuando se encuentra la primera condición verdadera.\nCiclos, while, for #  La repetición de acciones se logra de varias formas, pero lo más común es utilizar los ciclos while y for.\nWhile #  El ciclo while repite el código dentro de sus llaves mientras una condición sea verdadera:\nbool condicion = true; while(condicion){ //Repite estas lineas de código 	//mientras condición sea verdadera } Simple y fácil de entender, otra forma de hacer repeticiones es por medio del ciclo for.\nFor #  "}),a.add({id:15,href:'/eleckia/docs/avr/funciones/',title:"Funciones",section:"Programación Avr en C.",content:"Funciones en C #  Las funciones son características fundamentales de cualquier lenguaje de programación, inclusive existe un paradigma de programación llamado programación funcional, veamos brevemente como funcionan las funciones en C. Una función tiene la siguiente sintaxis en C,\ntipo_de_retorno nombre_de_funcion(tipo_dato argumento_n) { ... hacer_tareas ... return un_objeto_del_tipo_de_retorno; } Las funciones son usadas como una forma de separar o estratificar tareas, pueden recibir \u0026ldquo;n\u0026rdquo; cantidad de argumentos y pueden retornar o no un valor, un ejemplo sencillo, definimos la función suma,\nint8_t suma(int8_t sumando1, int8_t sumando2) { int8_t resultado = sumando1 + sumando2; return resultado; } Es importante aclarar que el valor de retorno debe ser del mismo tipo que el tipo de retorno declarada en la función, en este caso un entero de 8 bits.\nEsta función simplemente suma los dos argumentos pasados en ella, definida la función es posible llamarla desde main o cualquier otra función:\nint main(void) { int8_t numero = suma(3,2); //ahora numero contiene 5 } Al ejecutarse, la variable numero contendrá el valor de 5.\nDeclaración vs Definición #  Ahora que sabemos definir funciones sencillas, escribamos un programa donde se define la función:\n#include\u0026lt;stdint.h\u0026gt; //Para int8_t  int main(void) { int8_t numero = suma(2,3); return 0; } int8_t suma(int8_t sumando1, int8_t sumando2) { int8_t resultado = sumando1 + sumando2; return resultado; } Compilamos y nos dará un error:\nprogram.c: In function ‘int main()’: program.c:5:25: error: ‘suma’ was not declared in this scope int8_t numero = suma(2,3); El error indica que la función main no puede encontrar a la función sum, En C hay dos conceptos fundamentales que indican la existencia de un símbolo:\n Declaración, Indica al compilador la existencia de un símbolo, de tal forma que el compilador pueda seguir sin la necesidad de conocer los detalles del símbolo.  int8_t funcion1(void); //Declaración de una función char letra; //Declaración de una variable char A las funciones declaradas se les suele llamar prototipos, la declaración de variables no recibe un nombre en particular,\n Definición, Se indica al compilador en que espacio se encuentra y que tamaño tiene.  letra = \u0026#39;b\u0026#39;;	//Definición de una variable prefiamente declarada char vocal = \u0026#39;o\u0026#39;; //Declaración y definición de una variable int8_t suma(void) //Definición y Declaración de una función, {	//Si la función fue previamente declarada solo se define 	return 1 + 2; } En nuestro código la función suma se declara y define al final del fichero, ¿por qué nos indica un error de declaración?, El compilador analiza el código linea por linea de arriba hacia abajo, cuando llega a la función main, aun no ha encontrado ningún símbolo con el nombre suma, la solución es tan simple como escribir el prototipo una o varias líneas antes de la función main.\nint8_t suma(int8_t sumando1, int8_t sumando2); int main(void) { Con esto el compilador estará feliz de hacer su trabajo, en otra etapa de compilación encontrara la definición de la función y hará el trabajo necesario para asignar su dirección de memoria y su tamaño.\nEn las siguientes entradas entenderemos las ventajas que se obtiene de esta separación entre prototipo(declaración) y la definición.\nParámetros y retorno #  Parámetros #  Los parámetros sirven para enviar datos a las funciones, aunque una interpretación más útil es que las funciones operan sobre los datos, una función puede recibir cualquier cantidad de parámetros, el limite es el tamaño de memoria, sin embargo lo deseable es que las funciones reciban pocos o ningún parámetros, algunos ejemplos:\nint8_t suma(float sumando1, float sumando2); int8_t factorial(int8_t numero); int8_t contador(char * palabra); //apuntador tipo char int8_t simbolo(char letra); int8_t mesActual(void); //el tipo void(vacio) indica que no hay parámetros Retorno #  Las funciones pueden retornar uno o ningún parámetro por medio de la palabra return, al igual que los parámetros de entrada puede ser de cualquier tipo:\nint8_t suma(); char * palabras(); void encender(); //Sin retorno char ultimaLetra(); int * lista(); Llamada a funciones #  Las funciones pueden ser llamadas dentro de cualquier otra función, incluso existe una técnica llamada recursividad donde una función se llama a si misma entrando en una especie de ciclo, aunque es una técnica maravillosa es poco utilizada en sistemas embebidos, principalmente por:\n La razón más importante: es una técnica altamente elegante que esta reservada para gente altamente sofisticada y de buen gusto. Otra razón menos importante es que los microcontroladores carecen de la memoria suficiente para almacenar todas las variables de llamadas sucesivas a una función.  Para llamar a una función basta con indicar su nombre, pasar los argumentos y guardar el retorno si es necesario.\nvoid funcion1(void) { int numero = suma(3, 5); //Hacer tareas con numero } "}),a.add({id:16,href:'/eleckia/docs/perifericos/gpio/biblioteca7/',title:"Api Display Siete Segmentos",section:"GPIO",content:"Api para un display de siete segmentos #  Escribamos una biblioteca/api sencilla que nos permita configurar un número en un display de 7 segmentos, el circuito es el siguiente,\nConexión Arduino-Display #  Contamos con un display de cátodo común por lo tanto cada segmento se enciende con un voltaje alto en el pin correspondiente, es decir para encender el segmento \u0026ldquo;A\u0026rdquo; debemos configurar el pin digital D2 en alto. Evitamos la conexión en los pines D0 y D1, debido a que estos están conectados al convertidor serial-usb, y pueden provocar problemas para subir el código a la tarjeta.\nComo primer paso debemos incluir la biblioteca \u0026ldquo;avr/io.h\u0026rdquo;, para tener acceso a los puertos de GPIOx de entrada/salida, cuyos registros asociados son DDRx, PORTx, PINx.\n#include\u0026lt;avr/io.h\u0026gt;Ahora declaramos la función principal, recordemos que la función principal es llamada automáticamente cuando el programa es ejecutado,\nint main(void) { return 0; } Dentro de las llaves del main configuramos los pines adecuados como salidas, para hacerlo requerimos saber a que pines del microcontrolador corresponden los pines del Arduino,\nfuente:(http://www.chicoree.fr/w/Arduino_sur_ATmega328P)\nEn la anterior imagen observamos la correspondencia entre los pines del Arduino y los del microcontrolador, por ejemplo el pin digital D2 es en realidad el pin PD2 del atmega328p, por ejemplo el pin digital D8 es en realidad el pin PB0 del atmega328p. Configuramos el registro DDRB y DDRD como salidas,\nDDRB |= 1\u0026lt;\u0026lt;PB0; DDRD |= 1\u0026lt;\u0026lt;PD2 | 1\u0026lt;\u0026lt;PD3 | 1\u0026lt;\u0026lt;PD4 | 1\u0026lt;\u0026lt;PD5 | 1\u0026lt;\u0026lt;PD6 | 1\u0026lt;\u0026lt;PD7; Ahora solo encendemos los leds, poniendo en alto los pines requeridos, por ejemplo para el número cinco, encendemos los segmentos a,c,d,f,g.\nPara ello escribimos a los puertos PORTB y PORTD los pines indicados\nPORTB |= 1\u0026lt;\u0026lt;PB0; PORTD |= 1\u0026lt;\u0026lt;PD2 | 1\u0026lt;\u0026lt;PD4 | 1\u0026lt;\u0026lt;PD5 | 1\u0026lt;\u0026lt;PD7; El código completo luce como el siguiente,\n#include\u0026lt;avr/io.h\u0026gt; int main(void) { DDRB |= 1\u0026lt;\u0026lt;PB0; DDRD |= 1\u0026lt;\u0026lt;PD2 | 1\u0026lt;\u0026lt;PD3 | 1\u0026lt;\u0026lt;PD4 | 1\u0026lt;\u0026lt;PD5 | 1\u0026lt;\u0026lt;PD6 | 1\u0026lt;\u0026lt;PD7; PORTB |= 1\u0026lt;\u0026lt;PB0 ; PORTD |= 1\u0026lt;\u0026lt;PD2 | 1\u0026lt;\u0026lt;PD4 | 1\u0026lt;\u0026lt;PD5 | 1\u0026lt;\u0026lt;PD7; return 0; } Compilamos y subimos.\nEl \u0026ldquo;estilo\u0026rdquo; en que hemos escrito nuestro programa es coloquialmente llamado hardcoding, debido a que nosotros especificamos tanto los valores como el flujo, usualmente lo que queremos es que el programa calcule los valores y elija el flujo, imaginemos que ahora requerimos una secuencia de números en serie, comenzado con 1 y terminando en 9 y repetir esta secuencia 1000 veces, seria un poco tedioso cambiar uno por uno los estados de los segmentos, para evitar este trabajo nos apoyaremos en funciones y sentencias de flujo.\nBiblioteca #  Nuestro anterior programa sirve para dos cosas, para nada y para la basura, no hay ninguna diferencia con respecto a conectar los pines del display directamente a Vcc, requerimos funcionalidad, que el microcontrolador haga lo adecuado para mostrar cualquier número indicado, con una interfaz del tipo\ndisplay7_showNumber(3); //Muestra el número 3 en el display de esta forma podemos realizar una secuencia de números\nint main(void) { while(1){ display7_showNumber(0); //delay  display7_showNumber(1); //delay  . . . display7_showNumber(9); //delay  } } El display mostrara los números del 0 al 9 en orden ascendente, nuestro objetivo entonces es definir la función display7_showNumber(short const number).\nAunque en este problema sencillo podemos programar la solución de forma monolítica(un solo fragmento de código), es de utilidad desarrollarlo en forma modular, como en la siguiente figura\nDe tal forma que podemos utilizarla dentro de nuestra aplicación con un simple include, pensar en forma modular tiene grandes ventajas y conforme crece el proyecto se vuelve la única forma sostenible de escribir código,\nPara nuestro propósito un módulo es un ente de software que aglutina las las características:\n Responsabilidad única, solo realiza una tarea. Débilmente acoplado, Dos módulos están débilmente acoplados si ambos desconocen los detalles de implementación del otro. Altamente cohesivo, Un módulo es altamente cohesivo si utiliza la totalidad de sus miembros, para realizar sus tareas.  La definición de módulo es un poco volátil, cada autor lo llama diferente, algunos indican que una clase es equivalente a un módulo, algunos indican que un conjunto de clases es un módulo, otros les llaman entidades, componentes, o paquetes. Para este propósito cuando digo módulo me refiero al conjunto de un fichero .h con su o sus respectivos ficheros .c.\nUna bonita interfaz para nuestro modulo puede ser\nvoid display7_init(void); void display7_showNumber(int8_t number); Elegir buenos nombres es una parte fundamental para que nuestro código sea de alta calidad, estoy seguro que al leer las funciones anteriores de inmediato formaste una idea de lo que hacen y a que pertenecen.\nNi tardos ni perezosos comenzamos con la crea del módulo, declaramos la interfaz del módulo en un fichero display7.h:\n#ifndef DISPLAY7_H #define DISPLAY7_H  #include \u0026lt;stdint.h\u0026gt; void display7_init(void); void display7_showNumber(int8_t number); #endif// DISPLAY7_H Comenzaré con la función display7_showNumber, pues actualmente no tengo idea de que requiero inicializar en la otra función, rápidamente defino la función dentro de un fichero display7.c:\n#include \u0026#34;display7.h\u0026#34; void display7_showNumber(int8_t number) { } Enfocándonos en la función requerimos que number sea traducida a un formato donde los pines puedan ser establecidos, supongamos que siempre number = 1, bastaría con:\n#include\u0026lt;avr/io.h\u0026gt; void display7_showNumber(int8_t number) { PORTD |= 1\u0026lt;\u0026lt;PD3 | 1\u0026lt;\u0026lt;PD4; } Ahora consideremos el caso en que number puede ser uno o siete,\nvoid display7_showNumber(int8_t number) { if(number == 1) PORTD |= 1\u0026lt;\u0026lt;PD3 | 1\u0026lt;\u0026lt;PD4; else if(number == 7) PORTD |= 1\u0026lt;\u0026lt;PD3 | 1\u0026lt;\u0026lt;PD4 | 1\u0026lt;\u0026lt;PD2; } Parece la dirección correcta, sin embargo, si primero se muestra siete, ya no será posible mostrar un uno, el problema habla y nos esta diciendo que requerimos implementar la funcionalidad de establecer los pines y de borrar los pines complementarios. Se proponen dos funciones adicionales:\nstatic void setPins(uint8_t pins); static void clearPins(uint8_t pins); void display7_showNumber(int8_t number) { if(number == 1){ setPins(1\u0026lt;\u0026lt;PD3 | 1\u0026lt;\u0026lt;PD4); clearPins(1\u0026lt;\u0026lt;PD3 | 1\u0026lt;\u0026lt;PD4); } else if(number == 7){ setPins(1\u0026lt;\u0026lt;PD3 | 1\u0026lt;\u0026lt;PD4 | 1\u0026lt;\u0026lt;PD2); clearPins(1\u0026lt;\u0026lt;PD3 | 1\u0026lt;\u0026lt;PD4 | 1\u0026lt;\u0026lt;PD2); } } static void setPins(uint8_t pins) { PORTD |= pins; } static void clearPins(uint8_t pins) { PORTD \u0026amp;= ~pins; } El código tiene dos problemas graves, el primero es que comienza a verse algo de repetición, este es un dogma de la programación:\nLa repetición de ideas, es el origen de todos los males\nEl segundo es que no todos los pines están en el puerto D, hay uno en el B.\nSolucionemos rápidamente el primer problema:\nvoid display7_showNumber(int8_t number) { uint8_t pins; if(number == 1) pins = 1\u0026lt;\u0026lt;PD3 | 1\u0026lt;\u0026lt;PD4; else if(number == 7) pins = 1\u0026lt;\u0026lt;PD3 | 1\u0026lt;\u0026lt;PD4 | 1\u0026lt;\u0026lt;PD2; setPins(pins); clearPins(pins); } Lo anterior tiene un nombre, se llama refactoring, algunos le dicen refactorizar pero evidentemente es una palabra que no existe, el refactoring tiene sus reglas y directrices, es un tópico relativamente avanzado que tocaremos en otra entrada, para quien desee adelantarse, tiene disponible Refactoring de Martin Fowler.\nEl segundo problema no es tan sencillo de atacar, no hay forma de diferencia PB0 de PD0, ambos son un cero, para esta configuración de pines tenemos suerte, solo hay PB0 y podemos trabajar con una condicional sobre el, pero deberíamos buscar una forma más generalizada:\nstatic void setPins(uint8_t pins) { PORTD |= pins; if(pins \u0026amp; (1\u0026lt;\u0026lt;PB0)) PORTB |= 1\u0026lt;\u0026lt;PB0; } static void clearPins(uint8_t pins) { PORTD \u0026amp;= ~pins; if(pins \u0026amp; (1\u0026lt;\u0026lt;PB0)) PORTB \u0026amp;= ~(1\u0026lt;\u0026lt;PB0); } No me da buenas sensaciones pero funciona, más adelante lo intentaremos de nuevo, por ahora agreguemos un caso más, cuando number puede ser también cuatro:\nvoid display7_showNumber(int8_t number) { uint8_t pins; if(number == 1) pins = 1\u0026lt;\u0026lt;PD3 | 1\u0026lt;\u0026lt;PD4; else if(number == 7) pins = 1\u0026lt;\u0026lt;PD3 | 1\u0026lt;\u0026lt;PD4 | 1\u0026lt;\u0026lt;PD2; else if(number == 4) pins = 1\u0026lt;\u0026lt;PD3 | 1\u0026lt;\u0026lt;PD4 | 1\u0026lt;\u0026lt;PB0 | 1\u0026lt;\u0026lt;PD7; setPins(pins); clearPins(pins); } Esos if\u0026rsquo;s se ven horribles y faltan más, ¿habrá alguna forma de quitarlos?, actualmente representamos los segmentos como sigue:\n0b76543210 FEDCBA0G Si sabemos que a cada valor de number le corresponde una y solo una representación de segmentos, entonces ¿no podríamos guardar los \u0026ldquo;patrones\u0026rdquo; que le corresponde a cada valor de number?, por supuesto, a eso se le conoce como lookup table o tabla de consulta, hay muchas formas de implementarla pero la más sencilla es por medio de un arreglo:\nconst uint8_t segments_table[] ={ 1\u0026lt;\u0026lt;PD2 | 1\u0026lt;\u0026lt;PD3 | 1\u0026lt;\u0026lt;PD4 | 1\u0026lt;\u0026lt;PD5 | 1\u0026lt;\u0026lt;PD6 | 1\u0026lt;\u0026lt;PD7, //0 	1\u0026lt;\u0026lt;PD3 | 1\u0026lt;\u0026lt;PD4, //1 	1\u0026lt;\u0026lt;PD2 | 1\u0026lt;\u0026lt;PD3 | 1\u0026lt;\u0026lt;PD5 | 1\u0026lt;\u0026lt;PD6 | 1\u0026lt;\u0026lt;PB0, //2 	1\u0026lt;\u0026lt;PD2 | 1\u0026lt;\u0026lt;PD3 | 1\u0026lt;\u0026lt;PD4 | 1\u0026lt;\u0026lt;PD5 | 1\u0026lt;\u0026lt;PB0, //3 	. . . }; void display7_showNumber(int8_t number) { uint8_t pins = segments_table[number]; setPins(pins); clearPins(pins); } Ahora si, se ve simple y claro. ¿Qué pasaría si el usuario introduce un número más grande que el tamaño del arreglo?, claramente habría un error, debemos protegernos de valores inadecuados:\nvoid display7_showNumber(int8_t number) { if(number \u0026lt; 0 || number \u0026gt; 9) return ; uint8_t pins = segments_table[number]; setPins(pins); clearPins(pins); } Si se introduce un número incorrecto, la función simplemente lo ignora.\nYa sabemos que lo único que requerimos inicializar, son los pines en la función display7_init\nvoid display7_init(void) { DDRD |= 1\u0026lt;\u0026lt;PD2 | 1\u0026lt;\u0026lt;PD3 | 1\u0026lt;\u0026lt;PD4 | 1\u0026lt;\u0026lt;PD5 | 1\u0026lt;\u0026lt;PD6 | 1\u0026lt;\u0026lt;PD7; DDRB |= 1\u0026lt;\u0026lt;PB0; } Solo nos queda incluir la biblioteca dentro del main:\n#include \u0026#34;display7.h\u0026#34;#define F_CPU 16000000UL #include \u0026lt;util/delay.h\u0026gt; int main(void) { display7_init(); int i = 0; while(1){ display7_showNumber(i); _delay_ms(1000); i++; if(i \u0026gt; 9) i = 0; } } Compilando el programa con:\n$ avr-gcc -mmcu=atmega328p -Wall -Os display7.c main.c Obtengo los siguientes resultados:\n$ avr-size --mcu=atmega328p --format=avr a.out AVR Memory Usage ---------------- Device: atmega328p Program: 260 bytes (0.8% Full) (.text + .data + .bootloader) Data: 8 bytes (0.4% Full) (.data + .bss + .noinit) Lo que es fantástico, pues no hemos utilizado ni el 1% de la memoria flash y una miserable cantidad de memoria ram.\nDesafortunadamente esa biblioteca es muy concreta, depende directamente de la asignación de pines indicada en el esquemático, cualquier cambio en alguno de los pines deriva en cambiar tres funciones y la tabla.\nGeneralizando más #  Algo que me gustaría es que se pueda indicar los pines al inicializar la biblioteca:\nvoid display7_init(int8_t A, int8_t B, int8_t C, int8_t D, int8_t E, int8_t F, int8_t G, int8_t dot); Se requiere una forma de guardar los pines ingresados por el usuario, un arreglo será suficiente:\n#define TOTAL_PINS 8 uint8_t pins_table[TOTAL_PINS]; void display7_init(int8_t A, int8_t B, int8_t C, int8_t D, int8_t E, int8_t F, int8_t G, int8_t dot) { pins_table[0] = A; pins_table[1] = B; pins_table[2] = C; pins_table[3] = D; pins_table[4] = E; pins_table[5] = F; pins_table[6] = G; pins_table[7] = dot; } Desde el punto de vista del compilador no hay forma de saber a que gpio corresponde cada pin, debemos especificar la correspondencia, otra lookup table es necesaria:\nenum {portB, portC, portD}; const int8_t gpio_table[][2] = { {-1, -1}, //pin 1 	{portD, PD0}, {portD, PD1}, {portD, PD2}, {portD, PD3}, {portD, PD4}, {-1, -1}, //Vcc 	{-1, -1}, //Gnd 	{portB, PB6}, {portB, PB7}, {portD, PD5}, {portD, PD6}, {portD, PD7}, {portB, PB0}, //pin 14 	{portB, PB1}, {portB, PB2}, {portB, PB3}, {portB, PB4}, {portB, PB5}, {-1, -1}, //AVcc 	{-1, -1}, //ARef 	{-1, -1}, //Gnd 	{portC, PC0}, {portC, PC1}, {portC, PC2}, {portC, PC3}, {portC, PC4}, {portC, PC5}, //pin 28 }; Ahora contamos con toda la información necesaria. Registrados los pines, es necesario configurarlos como salidas, se propone:\nvoid display7_init(int8_t A, int8_t B, int8_t C, int8_t D, int8_t E, int8_t F, int8_t G, int8_t dot) { pins_table[0] = A; pins_table[1] = B; pins_table[2] = C; pins_table[3] = D; pins_table[4] = E; pins_table[5] = F; pins_table[6] = G; pins_table[7] = dot; pinsAsOutput(); } static void pinsAsOutput(void) { for(int i = 0; i\u0026lt;TOTAL_PINS; i++){ if(gpio_table[pins_table[i]][0] == portB) DDRB |= gpio_table[pins_table[i]][1]; else if(gpio_table[pins_table[i]][0] == portC) DDRC |= gpio_table[pins_table[i]][1]; else if(gpio_table[pins_table[i]][0] == portD) DDRD |= gpio_table[pins_table[i]][1]; } } Tan solo nos queda establecer y limpiar, se propone modificar los patrones de los segmentos a la forma:\n0b76543210 .GFEDCBA es decir:\nconst uint8_t segments_table[] = { //0b76543210 	// .GFEDCBA 	0xFC, //0 	0x60, //1 	0xDA, //2 	0xF2, //3 	0x66, //4 	0xB6, //5 	0xBE, //6 	0xE0, //7 	0xFE, //8 	0xE6, //9 }; Para establecer cada segmento se recorren los pines registrados y si el correspondiente bit está en alto, se establece el pin:\nstatic void setPins(uint8_t pins) { for(int i = 0; i\u0026lt;TOTAL_PINS; i++){ if((pins\u0026amp;(1\u0026lt;\u0026lt;i)) == 0) continue; if(gpio_table[pins_table[i]][0] == portB) PORTB |= 1\u0026lt;\u0026lt;gpio_table[pins_table[i]][1]; else if(gpio_table[pins_table[i]][0] == portC) PORTC |= 1\u0026lt;\u0026lt;gpio_table[pins_table[i]][1]; else if(gpio_table[pins_table[i]][0] == portD) PORTD |= 1\u0026lt;\u0026lt;gpio_table[pins_table[i]][1]; } } static void clearPins(uint8_t pins) { for(int i = 0; i\u0026lt;TOTAL_PINS; i++){ if((pins\u0026amp;(1\u0026lt;\u0026lt;i)) == 0) continue; if(gpio_table[pins_table[i]][0] == portB) PORTB \u0026amp;= ~(1\u0026lt;\u0026lt;gpio_table[pins_table[i]][1]); else if(gpio_table[pins_table[i]][0] == portC) PORTC \u0026amp;= ~(1\u0026lt;\u0026lt;gpio_table[pins_table[i]][1]); else if(gpio_table[pins_table[i]][0] == portD) PORTD \u0026amp;= ~(1\u0026lt;\u0026lt;gpio_table[pins_table[i]][1]); } } Funciona pero es horriblemente feo, hagamos una lookup table para quitar esos espantosos if\u0026rsquo;s:\nvolatile uint8_t * port_table[] = { \u0026amp;PORTB, \u0026amp;PORTC, \u0026amp;PORTD }; static void setPins(uint8_t pins) { volatile uint8_t * port_register; for(int i = 0; i\u0026lt;TOTAL_PINS; i++){ if((pins\u0026amp;(1\u0026lt;\u0026lt;i)) == 0) continue; port_register = port_table[gpio_table[pins_table[i]][0]]; *port_register |= 1\u0026lt;\u0026lt;gpio_table[pins_table[i]][1]; } } static void clearPins(uint8_t pins) { volatile uint8_t * port_register; for(int i = 0; i\u0026lt;TOTAL_PINS; i++){ if((pins\u0026amp;(1\u0026lt;\u0026lt;i)) == 0) continue; port_register = port_table[gpio_table[pins_table[i]][0]]; *port_register \u0026amp;= ~(1\u0026lt;\u0026lt;gpio_table[pins_table[i]][1]); } } volatile uint8_t * ddr_table[] = { \u0026amp;DDRB, \u0026amp;DDRC, \u0026amp;DDRD }; static void pinsAsOutput(void) { volatile uint8_t * dir_register; for(int i = 0; i\u0026lt;TOTAL_PINS; i++){ dir_register = ddr_table[gpio_table[pins_table[i]][0]]; *dir_register |= 1\u0026lt;\u0026lt;gpio_table[pins_table[i]][1]; } } Aunque se ve un poco más simple, no deja de ser mala idea anidar indices de esa forma, algo un poco más decente es lo siguiente:\nstatic void setPins(uint8_t pins) { volatile uint8_t * port_register; int8_t pin_number; int8_t port; int8_t pin; for(int i = 0; i\u0026lt;TOTAL_PINS; i++){ if((pins\u0026amp;(1\u0026lt;\u0026lt;i)) == 0) continue; pin_number = pins_table[i]; port = gpio_table[pin_number][0]; pin = gpio_table[pin_number][1]; port_register = port_table[port]; *port_register |= 1\u0026lt;\u0026lt;pin; } } creo que se entiende mejor. Pero sigue sin satisfacerme, mañosamente he dejado una línea para resaltar algo muy importante, esta función esta haciendo dos tareas.\n1.- Revisa las coincidencias entre el segmento y el bit.\n2.- Establece el bit en el puerto.\nPara mayor claridad y mejor \u0026ldquo;mantenibilidad\u0026rdquo;, propongo poner la segunda tarea en otra función.\nstatic void setPin(int8_t pin_number); static void setPins(uint8_t pins) { int8_t pin_number; for(int i = 0; i\u0026lt;TOTAL_PINS; i++){ if((pins\u0026amp;(1\u0026lt;\u0026lt;i)) == 0) continue; pin_number = pins_table[i]; setPin(pin_number); } } static void setPin(int8_t pin_number) { int8_t port = gpio_table[pin_number][0]; int8_t pin = gpio_table[pin_number][1]; volatile uint8_t * port_register = port_table[port]; *port_register |= 1\u0026lt;\u0026lt;pin; } Mucho mejor, ahora la función setPins no tiene nada que ver con los pines del microcontrolador, propongo cambiar el nombre setSegments y la tabla de pins_table a segments_pins_table. Por supuesto también ser requiere una función clearPin:\nstatic void setPin(int8_t pin_number) { int8_t port = gpio_table[pin_number][0]; int8_t pin = gpio_table[pin_number][1]; volatile uint8_t * port_register = port_table[port]; *port_register |= 1\u0026lt;\u0026lt;pin; } static void clearPin(int8_t pins) { int8_t port = gpio_table[pin_number][0]; int8_t pin = gpio_table[pin_number][1]; volatile uint8_t * port_register = port_table[port]; *port_register \u0026amp;= ~(1\u0026lt;\u0026lt;pin); } La repetición es evidente, se propone condensar las dos funciones en una sola y renombrarla:\ntypedef enum {LOW=0, HIGH} PIN_LEVEL; static void setPinLevel(int8_t pin_number, PIN_LEVEL level) { int8_t port = gpio_table[pin_number][0]; int8_t pin = gpio_table[pin_number][1]; volatile uint8_t * port_register = port_table[port]; if(level == LOW) *port_register \u0026amp;= ~(1\u0026lt;\u0026lt;pin); else if(level == HIGH) *port_register |= 1\u0026lt;\u0026lt;pin; } Se ve bien. Lo mismo pasa con las renombradas setSegments y clearSegments, también se propone condensar ambas funciones:\nstatic void setSegments(uint8_t pins) { int8_t pin_number; for(int i = 0; i\u0026lt;TOTAL_PINS; i++){ pin_number = segments_pins_table[i]; if((pins\u0026amp;(1\u0026lt;\u0026lt;i)) == 0) setPinLevel(pin_number, LOW); else setPinLevel(pin_number, HIGH); } } Fantástico. Así como existe una función que indica el nivel de un pin, la función pinsAsOutput nos pide a gritos una función setPinDirection:\nstatic void setPinLevel(int8_t pin_number, PIN_LEVEL level) { int8_t port = gpio_table[pin_number][0]; int8_t pin = gpio_table[pin_number][1]; volatile uint8_t * port_register = port_table[port]; if(level == LOW) *port_register \u0026amp;= ~(1\u0026lt;\u0026lt;pin); else if(level == HIGH) *port_register |= 1\u0026lt;\u0026lt;pin; } typedef enum {INPUT=0, OUTPUT}PIN_DIR; static void setPinDirection(int8_t pin_number, PIN_DIR direction) { int8_t port = gpio_table[pin_number][0]; int8_t pin = gpio_table[pin_number][1]; volatile uint8_t * port_register = dir_table[port]; if(direction == INPUT) *port_register \u0026amp;= ~(1\u0026lt;\u0026lt;pin); else if(direction == OUTPUT) *port_register |= 1\u0026lt;\u0026lt;pin; } Casi son idénticas, podría aplicarse el mismo razonamiento y condensarlas pero una función con más de dos parámetros es muy desagradable, pero más importante estas funciones se utilizarán en dos contextos totalmente diferentes, prefiero dejarlas separadas.\nAprovechando la nueva función se hace refactoring en pinsAsOutput:\nstatic void pinsAsOutput(void) { int8_t pin; for(int i = 0; i\u0026lt;TOTAL_PINS; i++){ pin = segments_pins_table[i]; setPinDirection(pin, OUTPUT); } } Vamos bien. Finalmente se modifica display7_showNumber para que utilice las nuevas funciones:\nvoid display7_showNumber(int8_t number) { if(number \u0026lt; 0 || number \u0026gt; 9) return; uint8_t pins = segments_table[number]; setSegments(pins); } El trabajo es hecho, pero hay algo más que debe hacerse.\nCeder la responsabilidad #  Actualmente las tablas y las funciones se ven como sigue:\nuint8_t segments_pins_table[TOTAL_PINS]; const uint8_t segments_table[]; void display7_showNumber(int8_t number); static void setSegments(uint8_t pins); void display7_init(int8_t A, int8_t B, int8_t C, int8_t D, int8_t E, int8_t F, int8_t G, int8_t dot); static void pinsAsOutput(void); const int8_t gpio_table[][2]; volatile uint8_t * port_table[]; volatile uint8_t * ddr_table[]; static void setPinLevel(int8_t pin_number, PIN_LEVEL level); static void setPinDirection(int8_t pin_number, PIN_DIR direction); Nuevamente de forma explicita dejé un espacio para resaltar que las funciones de arriba únicamente utilizan las tablas superiores, mientras que las dos funciones de bajo solo utilizan las tres tablas de abajo. Dicho en forma elegante las tablas y funciones de arriba son altamente cohesivas entre ellas, y las funciones y las tablas de abajo son altamente cohesivas entre ellas, es absolutamente necesarios dividir el módulo en dos, por lo que se propone trasladar las tablas y funciones de abajo a un nuevo par de ficheros, gpio.h y gpio.c:\n#ifndef GPIO_H #define GPIO_H  #include \u0026lt;stdint.h\u0026gt; typedef enum {LOW=0, HIGH} PIN_LEVEL; typedef enum {INPUT=0, OUTPUT}PIN_DIR; void setPinLevel(int8_t pin_number, PIN_LEVEL level); void setPinDirection(int8_t pin_number, PIN_DIR direction); #endif// GPIO_H #include \u0026#34;gpio.h\u0026#34;#include \u0026lt;avr/io.h\u0026gt; enum {portB, portC, portD}; const int8_t gpio_table[][2] = { {-1, -1}, //pin 1 	{portD, PD0}, {portD, PD1}, {portD, PD2}, {portD, PD3}, {portD, PD4}, {-1, -1}, //Vcc 	{-1, -1}, //Gnd 	{portB, PB6}, {portB, PB7}, {portD, PD5}, {portD, PD6}, {portD, PD7}, {portB, PB0}, //pin 14 	{portB, PB1}, {portB, PB2}, {portB, PB3}, {portB, PB4}, {portB, PB5}, {-1, -1}, //AVcc 	{-1, -1}, //ARef 	{-1, -1}, //Gnd 	{portC, PC0}, {portC, PC1}, {portC, PC2}, {portC, PC3}, {portC, PC4}, {portC, PC5}, //pin 28 }; volatile uint8_t * port_table[] = { \u0026amp;PORTB, \u0026amp;PORTC, \u0026amp;PORTD }; volatile uint8_t * ddr_table[] = { \u0026amp;DDRB, \u0026amp;DDRC, \u0026amp;DDRD }; void setPinLevel(int8_t pin_number, PIN_LEVEL level) { int8_t port = gpio_table[pin_number][0]; int8_t pin = gpio_table[pin_number][1]; volatile uint8_t * port_register = port_table[port]; if(level == LOW) *port_register \u0026amp;= ~(1\u0026lt;\u0026lt;pin); else if(level == HIGH) *port_register |= 1\u0026lt;\u0026lt;pin; } void setPinDirection(int8_t pin_number, PIN_DIR direction) { int8_t port = gpio_table[pin_number][0]; int8_t pin = gpio_table[pin_number][1]; volatile uint8_t * port_register = port_table[port]; if(direction == INPUT) *port_register \u0026amp;= ~(1\u0026lt;\u0026lt;pin); else if(direction == OUTPUT) *port_register |= 1\u0026lt;\u0026lt;pin; } Compilando y midiendo el tamaño obtengo:\n$ avr-size --format=avr --mcu=atmega328p a.out AVR Memory Usage ---------------- Device: atmega328p Program: 612 bytes (1.9% Full) (.text + .data + .bootloader) Data: 88 bytes (4.3% Full) (.data + .bss + .noinit) No está mal, sacrificamos un poco de memoria en favor de la portabilidad.\nComentarios finales #  Ahora contamos con dos módulos que deberían verse de la siguiente forma:\n. ├── display7 │ ├── include │ │ └── display7.h │ └── src │ └── display7.c ├── gpio │ ├── include │ │ └── gpio.h │ └── src │ └── gpio.c └── main.c 6 directories, 5 files De esta manera display7 puede usar el módulo gpio simplemente con incluirlo, pero no solo eso, un módulo led, buzzer o cualquiera que requiera utilizar los puertos gpio, queda habilitado para poder usarlos, sin tener que preocuparse por los registros, mejor aun, gpio puede ser adaptado rápidamente a cualquier otro avr cambiando únicamente las tablas de pines. Por supuesto display7 también puede ser incluido dentro de cualquier otro módulo que lo requiera.\nComparando las dos versiones, es evidente que la segundo es mucho más compleja, tomo mucho más tiempo y se cometieron más errores, además ocupa más recursos y es más lenta. ¿Vale la pena realizar la sobrecarga de trabajo?, la respuesta no es simple, pienso que vale la pena cuando no existe un módulo que ya lo haga, si ya existe no pierdas el tiempo y úsalo, si no existe y solo vas a realizar un proyecto con ese dispositivo, olvídalo no vale la pena \u0026ldquo;harcodea\u0026rdquo;, si no existe y vas a utilizar de forma regular esa características, vale totalmente la pena, la verdad es muy bonito que cuando requieres comenzar un proyecto ya tengas tus bibliotecas de los periféricos listas y no tengas que andar buscando registros y pines en el data sheet.\nmódulo gpio\nmódulo display7\n"}),a.add({id:17,href:'/eleckia/posts/electronica-basica-display-de-7-segmentos/',title:"Electrónica básica.- Display de 7 segmentos.",section:"Posts",content:"Un display de 7 segmentos es un arreglo de leds distribuidos de una manera determinada, 8 leds en total, el display de 7 segmentos tiene el propósito de mostrar caracteres, usualmente números pero también puede mostrar letras.\nDisplay 7 segmentos\nel circuito equivalente es muy sencillo,\nCátodo común\nesta configuración es llamada cátodo común, puesto que el cátodo de todos los diodos está en corto circuito, es una buena característica pues tenemos un solo pin para todos los cátodos y podemos usar un solo cable para la conexión en lugar de ocho.\nÁnodo común\nLa configuración de ánodo común es similar a la de cátodo común salvo que los ánodos son los que están conectados en corto.\nEl dispositivo cuenta con nueve terminales (aveces diez, dos dedicadas para el común) una para el común y el resto para los ocho leds, para el cátodo común; la terminal común se conecta a tierra y los leds se encienden con voltaje alto, por el contrario para el ánodo común; la terminal común se conecta a Vcc y los leds se encienden con voltaje bajo.\nCada terminal es simplemente un led, por lo tanto para usarlo debemos agregar una resistencia para limitar la corriente, para nuestro atmega328p; resistencias para cada led de 330 $latex \\Omega$ o un poco mayores son suficientes. Cada led sera alimentado por 10[mA], si todos los leds se encienden al mismo tiempo, en total tenemos 80[mA], por lo que nuestro microcontrolador puede manejarlos sin problema, recordemos que la corriente máxima provista por el microcontrolador es de 200[mA] por todos los pines y 40[mA] en cada pin.\n"}),a.add({id:18,href:'/eleckia/posts/electronica-basica-led-y-su-resistencia/',title:"Electrónica básica.- Led y su resistencia.",section:"Posts",content:"La ley de Ohm es una herramienta fundamental en la electrónica, en esta ocasión vamos a calcular la resistencia adecuada para que un diodo pueda operar de forma segura.\nAntes que nada definamos que es un diodo, sin entrar en detalles, un diodo es un dispositivo que permite el flujo de corriente en una sola dirección, cuenta con dos terminales, el ánodo y el cátodo, la regla es que si se conecta un voltaje alto al ánodo y uno bajo al cátodo, entonces fluye corriente, esta operación del diodo se conoce como polarización directa, si se invierten las conexiones se dice que el diodo esta polarizado en inversa y no fluye corriente. Un circuito simple se muestra en la figura,\nCircuito con Diodo\nAhora reemplazamos el diodo por su circuito equivalente,\nDiodo en Directa\nLa resistencia \u0026ldquo;interna\u0026rdquo; del diodo es muy pequeña por lo que podemos despreciarla, no debemos olvidar que este circuito es un modelo, el modelo funciona bien porque representa el comportamiento del diodo, no significa que dentro del diodo exista una resistencia y una fuente de voltaje, el valor de la fuente de voltaje varia de diodo a diodo, debemos verificar la hoja de datos para ver que voltaje tiene el diodo en cuestión, en algunos casos el voltaje es pequeño comparado con el resto de voltajes y simplemente se desprecia, modelandolo como un simple corto circuito.\nEn el caso de la polarización inversa el circuito es aun más simple\nDiodo en Inversa\nes un circuito abierto y no hay circulación de corriente.\nLed. #  Un led es un diodo que tiene la capacidad de emitir luz, el voltaje del diodo led es mayor que el voltaje de otro tipo de diodos, siendo el rojo el mas pequeño alrededor de 1.8 [V] y el azul el más grande alrededor de 4.8 [V], esto para leds de 5mm, sin embargo esto valores cambian según el tamaño del led, lo mejor es revisar en la hoja de datos del diodo en cuestión.\nUn led generalmente se acompaña de una resistencia conectada en serie, ¿para qué?, la respuesta es simple, para limitar su corriente, entendamos que es un corto circuito.\nPartiendo del circuito anterior, tenemos una fuente en serie con una resistencia, recordemos que la corriente es\n$latex i = \\frac{V}{R}$\nun corto se entiende como una conexión eléctrica de cero resistencia entre dos terminales. De esta forma los puntos A y B en el esquema están en corto, dicho de otra manera no hay resistencia entre ellos, esto implica que la corriente puede fluir totalmente entre estos dos puntos, Las terminales C y D no están en corto pues hay una resistencia entre ellas, ¿que pasaría si quitamos la resistencia?, pues tendríamos a las terminales C y D en corto y las consecuencias serian desastrosas. de la ley de Ohm tenemos $latex i = \\frac{V}{0} = \\infty$, las fuentes no pueden otorgar energía infinita, están diseñada para dar una corriente especifica, si se sobrepasa el limite se dañaran, es por eso que nunca debes juntar las terminales de una fuente.\nRegresando a nuestro diodo led, ¿qué pasaría si no colocamos una resistencia entre el diodo y la fuente?,\nDiodo en corto\ncomo dijimos la resistencia del modelo del diodo es muy pequeña por lo tanto la fuente y el diodo están prácticamente en corto, es decir fluirá una gran cantidad de corriente desde la fuente hacia el diodo, si se tiene suerte el diodo se quemara y se abrirá el circuito, si tienes un mal día tu fuente se dañara también, los diodos están fabricados para trabajar a un cierta corriente, en el caso de los diodos pequeños de 5mm la corriente suele estar alrededor de los 10[mA], en el caso de los diodos led de iluminación es común encontrar corrientes de 300[mA]. Calculemos rápidamente la resistencia de un led de 5mm rojo de 1.8[V] y 10[mA], que se desea conectar a una fuente de 5[V]. El circuito es el siguiente.\nde la ley de Ohm\n$latex V = Ri$\ndividiendo ambos lados entre la corriente\n$latex \\frac{V}{i} = R \\frac{i}{i} = R$\npara la resistencia R\n$latex R = \\frac{V_R}{i}$\ny la aplicamos a la resistencia R, recordemos que la corriente es un flujo, por lo tanto la corriente que pasa por la resistencia es la misma que pasa por el led, sabemos que el voltaje en la terminal positiva de la resistencia es 5V y el voltaje en la terminal negativa de la resistencia es 1.8V (estamos despreciando la resistencia interna del diodo), por lo tanto el voltaje que hay entre las terminales de la resistencia R es\n$latex V_R = (5 - 1.8) [V] = 3.2[V]$\nsabemos que la corriente de operación del led es de 10[mA], por lo tanto la resistencia adecuada debe ser\n$latex R = \\frac{3.2[V]}{10[mA]} = \\frac{3.2[V]}{0.010[A]} = 320 \\Omega$\nla resistencia comercial más cercana es de 330 Ohms, usaremos esa, la corriente disminuirá una cantidad marginal.\n¿Y si quiero añadir un led adicional a la misma fuente?, podemos añadir el led de forma paralela al led ya existen y recalcular la resistencia.\nLeds en paralelo\nEl cálculo es idéntico salvo que ahora la corriente es el doble, pues se requiere satisfacer la corriente de cada diodo $latex i = i_{D1} + i_{D2} = 20[mA]$, la resistencia necesaria es $latex R = 160 \\Omega$, el problema es que la resistencia disipara más potencia, que significa que se calentara más. Un método más recomendado es conectar una segunda rama (con diodo y resistencia incluidos), en paralelo a la fuente,\nDiodos con resistencia en paralelo\nde esta forma las dos resistencias son iguales a 330 Ohms. Podemos conectar tantas ramas en paralelo como deseemos, el limite es la capacidad de corriente de nuestra fuente, hay que recordar que el limite de un pin del atmega328p es de 40[mA].\n"}),a.add({id:19,href:'/eleckia/posts/bloque-reutilizable-sin-titulo-2/',title:"res",section:"Posts",content:"La ley de Ohm es una herramienta fundamental en la electrónica, en esta ocasión vamos a calcular la resistencia adecuada para que un diodo pueda operar de forma segura.\nAntes que nada definamos que es un diodo, sin entrar en detalles, un diodo es un dispositivo que permite el flujo de corriente en una sola dirección, cuenta con dos terminales, el ánodo y cátodo, la regla es que si se conecta un voltaje alto al ánodo y uno bajo al cátodo, entonces fluye corriente, esta operación del diodo se conoce como polarización directa, si se invierten las conexiones se dice que el diodo esta polarizado en inversa y no fluye corriente. Un circuito simple se muestra en la figura,\nCircuito con Diodo\nAhora reemplazamos el diodo por su circuito equivalente,\nDiodo en Directa\nLa resistencia \u0026ldquo;interna\u0026rdquo; del diodo es muy pequeña por lo que podemos despreciarla, no debemos olvidar que este circuito es un modelo, este modelo funciona bien porque representa el comportamiento del diodo, no significa que dentro del diodo exista una resistencia y una fuente de voltaje, el valor de la fuente de voltaje varia de diodo a diodo, debemos verificar la hoja de datos para ver que voltaje tiene el diodo en cuestión, en algunos casos el voltaje es pequeño comparado con el resto de voltajes y simplemente se desprecia, modelando el diodo como un simple corto circuito.\nEn el caso de la polarización inversa el circuito es aun más simple\nDiodo en Inversa\nes un circuito y no hay circulación de corriente.\nLed. #  Un led es un diodo que tiene la capacidad de emitir luz, el voltaje del diodo led es mayor que el voltaje de otro tipo de diodos, siendo el rojo el mas pequeño alrededor de 1.8 [V] y el azul el más grande alrededor de 4.8 [V], esto para leds de 5mm, sin embargo esto valores cambian según el tamaño del led, lo mejor es revisar en la hoja de datos del diodo en cuestión.\nUn led generalmente se acompaña de una resistencia conectada en serie, ¿para qué?, la respuesta es simple, para limitar su corriente, entendamos que es un corto circuito.\nPartiendo del circuito anterior, tenemos una fuente en serie con una resistencia, recordemos que la corriente es\n$latex i = \\frac{V}{R}$\nun corto se entiende como una conexión eléctrica de cero resistencia entre dos terminales. De esta forma los puntos A y B en el esquema están en corto, dicho de otra manera no hay resistencia entre ellos, esto implica que la corriente puede fluir totalmente entre estos dos puntos, Las terminales C y D no están en corto pues hay una resistencia entre ellas, ¿que pasaría si quitamos la resistencia?, pues tendríamos a las terminales C y D en corto y las consecuencias serian desastrosas. de la ley de Ohm tenemos $latex i = \\frac{V}{0} = \\infty$, las fuentes no pueden otorgar energía infinita, están diseñada para dar una corriente establecida de corriente, si se sobrepasa el limite se dañaran, es por eso que nunca debes juntar las terminales de una fuente.\nRegresando a nuestro diodo led, ¿qué pasaría si no colocamos una resistencia entre el diodo y la fuente?,\nDiodo en corto\ncomo dijimos la resistencia del modelo del diodo es muy pequeña por lo tanto la fuente y el diodo están en corto, es decir fluirá una gran cantidad de corriente desde la fuente hacia el diodo, si se tiene suerte el diodo se quemara y se abrirá el circuito, si tienes un mal día tu fuente se dañara también, los diodos están fabricados para trabajar a un cierta corriente, en el caso de los diodos pequeños de 5mm la corriente suele estar alrededor de los 10[mA], en el caso de los diodos led de iluminación es común encontrar corrientes de 300[mA]. Calculemos rápidamente la resistencia de un led de 5mm rojo de 1.8[V] y 10[mA], que se desea conectar a una fuente de 5[V]. El circuito es el siguiente.\nde la ley de Ohm despejando la resistencia se tiene\n$latex R = \\frac{V_R}{i}$\ny la aplicamos a la resistencia R, recordemos que la corriente es un flujo, por lo tanto la corriente que pasa por la resistencia es la misma que pasa por el led, sabemos que el voltaje en la terminal positiva de la resistencia es 5V y el voltaje en la terminal negativa de la resistencia es 1.8V (estamos despreciando la resistencia interna del diodo), por lo tanto el voltaje que hay entre las terminales de la resistencia R es\n$latex V_R = (5 - 1.8) [V] = 3.2[V]$\nsabemos que la corriente de operación del led es de 10mA, por lo tanto la resistencia adecuada debe ser\n$latex R = \\frac{3.2[V]}{10[mA]} = \\frac{3.2[V]}{0.010[A]} = 320 \\Omega$\nla resistencia comercial más cercana es de 330 Ohms, usaremos esa, la corriente disminuirá una cantidad marginal.\n¿Y si quiero añadir un led adicional a la misma fuente?, podemos añadir el led de forma paralela al led ya existen y recalcular la resistencia.\nLeds en paralelo\nEl cálculo es idéntico salvo que ahora la corriente es el doble, pues se requiere satisfacer la corriente de cada diodo $latex i = i_{D1} + i_{D2} = 20[mA]$, la resistencia necesaria es $latex R = 160 \\Omega$, el problema es que la resistencia disipara más potencia, que significa que se calentara más. Un método más recomendado es conectar una segunda rama con diodo y resistencia incluidos en paralelo a la fuente,\nDiodos con resistencia en paralelo\nde esta forma las dos resistencias son iguales a 330 Ohms. Podemos conectar tantas ramas en paralelo que deseemos, el limite es la capacidad de corriente de nuestra fuente, hay que recordar que el limite de un pin del atmega328p es de 40[mA].\n"}),a.add({id:20,href:'/eleckia/docs/avr/primitivos/',title:"Variables y tipos",section:"Programación Avr en C.",content:"Variables y tipos primitivos #  El lenguaje de programación C, es un lenguaje de tipado estático, esto quiere decir que nosotros debemos indicar el tipo de dato que guarda una variable.\n¿Qué es una variable?, puede decirse que una variable es un espacio en memoria que guarda un valor determinado, y ¿qué es un tipo?, por tipo de se entiende a una indicación hacia el compilador de como se utilizará el dato. En C existen los siguientes tipos, también llamados tipos primitivos:\n int, enteros almacenan valores enteros, como: 1, 2, -100, 0b11111, 0x32, \u0026hellip; float o double, de punto Flotante, cantidades con decimales como: 1.111, 3.141598, -1.4142, \u0026hellip; char, Caracter. \u0026lsquo;a\u0026rsquo;, \u0026lsquo;y\u0026rsquo;, ' \u0026lsquo;, \u0026lsquo;\\n\u0026rsquo;, \u0026hellip; *, Apuntador, almacena direcciones de memoria.  Existen tipos adicionales pero son variantes de las anteriores, como dijimos para declarar una variable debemos especificar su tipo, esto se hace con la siguiente sintaxis,\ntipo nombre_de_variable; //Una variable entera llamado numero int numero; //Una variable de tipo carácter llamada letra char letra; //Una variable de tipo punto flotante llamada cantidad double cantidad; //Un apuntador de tipo entero llamado signal int * signal; ¿Fácil no?, pero en la vida nada es fácil :D.\nEl tamaño de los enteros, stdint.h #  Un problema importante es que el tamaño de los enteros depende del compilador y de otros factores como la arquitectura del microcontrolador, en el caso de los microcontroladores avr de 8 bits, el tamaño de los enteros declarados con int es 2 bytes, sin embargo en microcontroladores cortex-m suelen ser de 4 bytes, esto provoca que el código sea difícil de portar entre una plataforma y otra, afortunadamente podemos hacer el código más portable con la biblioteca stdint.h, con ella podemos especificar el tamaño de los enteros:\n#include \u0026lt;stdint.h\u0026gt; //entero de 8 bits llamado ocho int8_t ocho; int16_t dieciseis; int32_t treintaydos; Con esto tenemos la seguridad de que los enteros tendrán el mismo tamaño en ambas arquitecturas o en cualquier otra que soporte la biblioteca(la mayoría).\n8 bits pueden almacenar desde -128 a 127 16 bits pueden almacenar desde -32768 a 32767 32 bits pueden almacenar desde -2147483648 a 2147483647 64 bits pueden almacenar desde -9,223,372,036,854,775,808 a 9,223,372,036,854,775,807 Nosotros evitaremos utilizar la declaración común en favor de la declaración provista por la biblioteca stdint.h cuando de manipulación de registros se trate.\nEl tipo char #  El tipo char sirve para guardar caracteres tiene un tamaño de 8 bits, es muy común ver programas donde un tipo char guarda el valor de un registro:\n//variable de tipo char llamada registro que guarda el valor de DDRB; char registro = DDRB; Es preferible guardar el valor de los registros en variable enteras de 8 bits, principalmente por motivos de legibilidad, pero también por portabilidad.\n¿Y las palabras? #  En C no existe el tipo string como en otros lenguajes, ciertamente el manejo de strings o mejor dicho de cadenas de caracteres es más doloroso.\nLos strings se representan como arreglos de caracteres (los arreglos se detallan en otra entrada), los arreglos son espacios conjuntos de memoria, un string por lo tanto no es más que una serie de caracteres que son declarados de forma contigua:\nchar palabra[] = \u0026#34;Hola mundo\u0026#34;; //otra forma char * otra = \u0026#34;Adios mundo\u0026#34;; El tipo char puede almacenar los caracteres descritos por el código ASCII, incluidos los de control, por ejemplo el carácter nulo \u0026lsquo;\\0\u0026rsquo;, o el tabulador \u0026lsquo;\\t\u0026rsquo;, el uso de caracteres suele estar limitado a los dispositivos capaces de mostrarlos, como pantallas por ejemplo.```\nAlgunas personas utilizan el puerto serial para enviar comandos por medio de caracteres, sin embargo es un método ineficiente, imagina que queremos enviar el número 200 desde un microcontrolador a una PC, podrías usar el puerto serial y enviar un \u0026lsquo;2\u0026rsquo;, \u0026lsquo;0\u0026rsquo; y \u0026lsquo;0\u0026rsquo;, cada uno es un carácter y tiene un tamaño de 8 bits, en total son 3x8 bits, sin embargo el número 200 puede almacenarse sin problemas en solo 8 bits, ahora supongamos que queremos enviar el número 2,000,000,000, enviarlo carácter por carácter requeriría 8x10 bits, 80 bits, cuando perfectamente ese número puede ser almacenado en un entero de 32 bits.\nDouble y float #  El tipo double almacena números con punto decimal, por medio de una representación de punto flotante. En el lenguaje C moderno para arquitecturas de 64 bits float esta en desuso, sin embargo en microcontroladores avr de 8 bits float y double se implementan igual, ambas tienen un tamaño de 32 bits.\nLa aritmetica de punto floate es costosa y se realiza por software, otras arquitecturas como los cortex-m4 tienen hardware dedicado para punto flotante, sin embargo es pronto para preocuparse por el rendimiento, sugiero no preocuparse tanto por el comentario anterior.\nApuntadores #  Los apuntadores son la herramienta más poderosa del lenguaje C y también la más peligrosa, haré una entrada dedicada a Apuntadores.\n"}),a.add({id:21,href:'/eleckia/docs/perifericos/gpio/gpio/',title:"Puertos de entrada/salida de propósito general (GPIO)",section:"GPIO",content:"Puertos de entrada/salida de propósito general. #  Cando pensamos en programar microcontroladores, lo que queremos es hacer que el mundo se mueva, controlar un motor, un relevador, una lampara, altavoz, etc. Para ello los microcontroladores cuentan con una serie de periféricos. A grandes rasgos un periférico puede definirse como: una interfaz que permite al microcontrolador comunicarse con el exterior, en esta entrada describiremos los puertos de entrada/salida de propósito general; GPIOx.\nSegún la hoja de datos el atmega328p tiene hasta 23 pines programables, cada uno con la posibilidad de ser programado individualmente, Arduino Uno tiene 20 pines disponibles, pues 2 están destinados al reloj y el otro está destinado al pin de reset.\nLos pines están agrupados en puertos, en el atmega328 contamos con tres puertos disponibles, PORTB, PORTC, PORTD, de manera genérica los llamamos PORTx, cada uno de estos puertos cuentan con tres registros asociados, DDRx, PORTx, PINx, donde \u0026ldquo;x\u0026rdquo; es el puerto(B, C, D), estos nueve registros nos permiten configurar y acceder a los valores de cada uno de los pines del microcontrolador.\nLos pines en el microcontrolador tienen un nombre del tipo Pxn, donde x es el puerto y n es él número de pin, el pin PB0 y el pin PD7, son el pin 0 y el pin 7 del puerto B y del puerto D respectivamente.\nConfigurar un Pin como Salida. #  La primera necesidad que se resuelve al programar un microcontrolador es encender y apagar un dispositivo externo, todos los pines que corresponden a alguno de los puertos gpio pueden establecerse como salidas, establecer un pin como salida implica dotar a ese pin de la capacidad de entregar o recibir corriente eléctrica, cada unos de los pines del atmega328p puede entregar un máximo de 20[mA] y un total de 200[mA] entre todos, esto es bastante aunque no lo parezca, la mayoría de las veces tomaremos alrededor de 1[mA] de cada pin o menos, el objetivo de un microcontrolador es controlar, no dotar de potencia a los dispositivos, cuando se requiere más potencia como para manejar un motor grande, se recurre a electronica adicional dedicada a ese rubro.\nSuponiendo que requerimos encender un led (un led requiere alrededor de 10[mA]) que está conectado al pin PB4, Debemos indicarle al registro DDRB que requerimos el pin PB4 como salida:\nDDRB |= 1\u0026lt;\u0026lt;PB4; Para mayores detalles sobre como establecer un bit\nEstablecer el estado cuando el pin es configurado como salida. #  Cuando un pin es configurado como salida, puede entregar/recibir potencia, poquita, pero suficiente para mover al mundo, para ello se requiere establecer el estado del pin, asumiendo que tenemos conectado un led al pin PB4 y que dicho pin esta configurado como salida en el registro DDRB, entonces podemos establecer el estado del pin en el registro PORTB, donde un cero es nivel bajo(0 V) y un uno es nivel alto (5 V).\n//Led encendido PORTB |= 1\u0026lt;\u0026lt;PB4; //Led apagado PORTB \u0026amp;= ~(1\u0026lt;\u0026lt;PB4); Toggle #  Algo muy curioso es que sin un pin esta configurado como salida y se escribe al registro correspondiente de entrada, el pin hace un toggle o un xor, suponiendo que el pin PD1 se encuentre configurado como salida:\nPINB |= 1\u0026lt;\u0026lt;PD1; //El pin se pone en estado alto si estaba en bajo PINB |= 1\u0026lt;\u0026lt;PD1; //El pin se pone en estado bajo si estaba en alto Este es un comportamiento típico y raro pero útil de los avr de 8 bits.\nConfigurar un Pin como Entrada. #  Para poder hacer acciones más complejas requerimos que nuestro microcontrolador pueda \u0026ldquo;sentir\u0026rdquo; al mundo, los pines de nuestro microcontrolador pueden configurarse para que se pueda interpretar el estado de un pin, establecido por un elemento externo (como un botón pulsador). Para ello también se utiliza el registro DDRx, pero en esta ocasión el pin a ser configurado se establece con un cero.\nDDRC \u0026amp;= ~(1\u0026lt;\u0026lt;PC0); //Pin PC0 como entrada Establecer un pin como entrada implica que el pin es incapaz de recibir y entregar corriente, esto es muy bueno pues el dispositivo que esta enviando los pulsos requiere un gasto de energía mínimo, por otro lado el pin se vuelve extremadamente sensible a cualquier impulso incluso a las ondas electromagnéticas generadas por diferentes fuentes, como lamparas o televisores. Se dice que el pin del microcontrolador esta configurado en modo de alta impedancia. La mayoría de los microcontroladores cuentan con una resistencia de pull up que resuelve este problema.\nResistencia de Pull up. #  Para evitar que el pin configurado como entrada se vuelva loco con solo mirarlo, basta con habilitar una resistencia de pull up en el pin, la resistencia se puede poner de forma externa o habilitar la resistencia interna que el microcontrolador trae para este propósito, la resistencia de pull up no es más que una resistencia conectada entre el pin y Vcc(5[V] en condiciones normales), de tal forma que el pin se \u0026ldquo;ancla\u0026rdquo; al voltaje de Vcc. La resistencia de pull up tiene un valor grande no se requiere de mucha potencia para \u0026ldquo;desanclar\u0026rdquo; el pin de Vcc por parte del dispositivo que envía la señal.\nPara habilitar la resistencia interna de pull up, asumiendo que el pin PC0 se encuentra configurado como entrada:\nPORTC |= 1\u0026lt;\u0026lt;PC0; //PC0 con resistencia de pullUp Desafortunadamente el atmega328p no cuenta con resistencia de pull down.\nLeer el estado de un pin. #  Cuando requerimos leer el estado del pin, utilizamos el registro PINx, contiene el estado de cada unos de los pines del puerto, Para censar al pin, debemos configurarlo como entrada en el registro DDRx.\nPara leer el estado del pin PC3, asumiendo que PC3 esta conectado a 5V y que PC3 esta configurado como entrada en DDRC (con un cero),\nuint8_t entrada = PINC \u0026amp; (1\u0026lt;\u0026lt;PC3); //Es igual a entrada = 0bxxxx1xxx \u0026amp; 0b00001000; //donde las x pueden ser 0 o 1 //aplicando and bit a bit resulta en entrada = 0b00001000; //entrada es exactamente igual a entrada = 8; //si PC0 estuvera conectado a tierra, //entrada resultaría en entrada = 0bxxxx0xxx \u0026amp; 0b00001000; //aplicando and bit a bit resulta en entrada =0b00000000; //o entrada = 0; "}),a.add({id:22,href:'/eleckia/posts/electronica-basica-voltaje-corriente-resistencia-y-ley-de-ohm/',title:"Electrónica Básica.- Voltaje, Corriente, resistencia y ley de Ohm.",section:"Posts",content:"Cuando la gente de computación escucha las palabras en el titulo de esta entrada, suele entrar en pánico y no es para menos, el análisis de circuitos eléctricos puede llegar a ser muy complejo; sin embargo la electrónica descansa sobre una ley simple, la ley de Ohm,\n$latex V = iR$\nla ley de Ohm relaciona el voltaje con la corriente y la resistencia; pero esto no nos dice nada si no entendemos estos términos, comencemos con el voltaje, también llamado tensión o potencial eléctrico, en la física,\nE_l voltaje se define como la cantidad de trabajo necesaria para mover una carga desde el infinito hasta un punto determinado_.\nAhora que ya sabes y entendiste claramente el voltaje pasemos con lo siguiente (es broma obviamente), la definición no nos sirve pues se aleja demasiado de la parte práctica, una forma más laxa y útil de interpretarlo es;\nEl voltaje es una fuente de energía eléctrica que impulsa a la corriente eléctrica a fluir a través de un circuito eléctrico.\nEsta definición no rigurosa pero nos es de gran utilidad, por la definición y por la ley de Ohm, su unidad de medida es el Volt [V], si el voltaje es muy grande la corriente que puede proveer la fuente es de mayor intensidad, por el contrario si el voltaje es negativo, \u0026ldquo;absorbe\u0026rdquo; corriente eléctrica.\n¿Pero qué es la corriente eléctrica?, pues no es más que un flujo de cargas eléctricas, flujo de electrones a través de un medio, usualmente un conductor, pero puede ser incluso a través del aire formándose un arco eléctrico cuando hay voltaje muy alto, su unidad de medida es el Ampere [A], se le representa con un símbolo \u0026ldquo;i\u0026rdquo; en el esquema a continuación, la dirección de la corriente va de voltaje alto a voltaje bajo; o si solo hay una fuente va de la terminal positiva a tierra (una forma común de referirse al voltaje o potencial 0[V]).\nDirección de la corriente\nUna resistencia es un elemento que se opone a el paso de la corriente, si colocamos en un circuito eléctrico un resistencia de 10 Ohms, la corriente que pasa por ella seria mucho mayor que si colocáramos una resistencia de 1000 Ohms.\nPor ejemplo, tenemos una fuente de 5V, una resistencia de 330 Ohms conectada entre sus terminales, ¿Qué corriente pasa por la resistencia?\nsabemos que $latex V = i R$, dividiendo ambos lados entre la resistencia\n$latex \\frac{V}{R} = \\frac{iR}{R}$\npor lo tanto, la corriente es\n$latex i = \\frac{V}{R}$\n$latex = \\frac{5}{330}=0.015 [A] = 15 [mA]$\n¿Por qué es importante conocer la corriente?, debido a que cada pin de nuestro microcontrolador tiene poca capacidad de entregar o recibir potencia, dicho de otra forma la corriente que sale de cada pin está limitada, para el atmega328p la corriente máxima de cada pin es de 40mA y la corriente entre todos los pines no debe ser superior a 200mA, sobrepasar este limite implica dañar el microcontrolador, para manejar corrientes grandes mayores a 10[mA] utilizaremos componentes externos.\n"}),a.add({id:23,href:'/eleckia/posts/que-son-los-registros-en-un-microcontrolador/',title:"¿Qué son los registros en un microcontrolador?",section:"Posts",content:"Hemos hablado acerca de los registros en anteriores entradas, vamos a profundizar un poco en el tema.\nPara entender un registro, definamos que es un bit, la palabra tiene varias acepciones, para nuestro propósito un bit es la representación de un valor binario, este puede ser 1 o 0. Entonces un registro es sencillamente un conjunto de bits, en nuestro microcontrolador atmega328p, existen registros de 8bits, en otras arquitecturas como los cortex-m los registros son de 32 bits, algunos como el msp de texas instruments, tienen registros de 16 bits.\n¿Es mejor 32 que 8 bits?, no realmente, la diferencia radica en que un sistema de 32 bits requiere un bus de 32 bits, un bus podría definirse como un conjunto paralelo de cables que comunica los registros con algún otro elemento, en otras palabras un bus de 32 bits comunica mayor información por cada ciclo, a priori esto es bueno, sin embargo las instrucciones que también viajan por este bus, no necesariamente ocupan los 32 bits, esto deriva en programas más grandes para las arquitecturas de 32 bits. Hoy por hoy las arquitecturas de 32 bits son muy populares, siendo incluso más baratas y eficientes que sus contrapartes de 8 bits, la gran ventaja de los 8 bits radica en su facilidad y simpleza.\nSiguiendo con los registros, programar un microcontrolador se resume a modificar los registros, ya comentamos el registro DDRx, donde x es un puerto determinado (haremos una serie especifica sobre puertos), modificar dicho registro nos permite establecer el comportamiento de cada uno de los pines pertenecientes a dicho puerto. A lo largo de las entradas iremos revisando varios de los registros y explicaremos las implicaciones que se tienen al modificarlos. En realidad DDRx es un nemotécnico no un registro, cuando escribimos DDRB, realmente estamos escribiendo algo similar a *(0xfa020121029120), una vez que estudiemos los apuntadores detallaremos que es lo anterior, adelanto que el número entre paréntesis es la dirección del registro).\nEl tema de los registros tiene una gran exposición cuando se programa en ensamblador, el ensamblador es un lenguaje muy estimulante de aprender y el ensamblador de avr es muy limpio y sencillo, quizá en el futuro expliquemos un poco.\n"}),a.add({id:24,href:'/eleckia/docs/avr/iniciando/',title:"Programando Avr en C.- Blinky",section:"Programación Avr en C.",content:"Comenzando con avr y C #  Para iniciar en la programación de dispositivos avr, se requieren algunas cosas:\n Un compilador de C y sus utilidades para avr:  Aunque existen varios compiladores disponibles, avr_gcc es el que se encuentra en la mayoría de los proyectos.   Un editor de texto:  Nuevamente hay muchas opciones, en lo personal prefiero vim.   avrdude, este programa nos ayuda a subir el código al microcontrolador.  Escribiendo el programa #  Comenzamos creando un fichero llamado blinky.c, dentro del cual agregamos:\n#include \u0026lt;avr/io.h\u0026gt;La directiva \u0026ldquo;include\u0026lt;\u0026gt; copia el contenido del fichero indicado, en nuestro fichero blinky.c, en este caso copia el contenido del fichero io.h que se encuentra dentro del directorio avr, no nos interesa la ubicación del directorio avr, el compilador sabe donde se encuentra y lo incluye de manera automática. Lo que si nos interesa saber es que incluir el fichero io.h nos permite acceder a los registros que controlan los pines del microcontrolador.\nPosteriormente tenemos la función main:\nint main(void) { return 0; } La función main es un ente importante, cuando el programa se ejecuta, la función main es llamada automáticamente, el código dentro de las llaves se ejecutara línea por línea, lo que esté fuera de dicha función deberá ser llamado explícitamente para poder ejecutarse. Por definición la función main retorna un entero al finalizar y en el caso de microcontroladores no suele recibir argumentos por eso la palabra void (más adelante analizaremos la estructura de las funciones).\nDespués viene el superloop,\nint main(void) { while(1){ //tareas 	} return 0; } El superloop es un ciclo infinito que se ejecuta dentro del main, en general las tareas deben definirse dentro del loop de tal forma que se repitan una y otra vez.\nFinalmente tenemos un retorno, como nuestro programa se queda \u0026ldquo;ciclado\u0026rdquo; dentro del while, nunca alcanzaremos esta línea, sin embargo es conveniente poner esta línea o el compilador nos dará una advertencia.\nYa estamos un poco más familiarizados con la estructura del programa, ahora si analicemos el programa Blink,\n#include\u0026lt;avr/io.h\u0026gt;#include\u0026lt;util/delay.h\u0026gt; int main(void) { DDRB = 1\u0026lt;\u0026lt;PB5; PORTB = 0; while(1){ PORTB = 1\u0026lt;\u0026lt;PB5; _delay_ms(1000); PORTB = 0; _delay_ms(1000); } return 0; } Al inicio tenemos dos directivas include, la primera io.h, nos permite acceder a los registros de los puertos de nuestro microcontrolador, en este caso el puerto B, haré una entrada especifica para este tema, la segunda delay.h nos permite usar la función _delay_ms, que como deducirás nos permite crear un tiempo muerto.\nIniciamos con la función main y lo primero que tenemos es una asignación, te preguntaras que es DDRB, para entenderlo primero debo explicar que es un registro y lo explicare en una entrada dedicada, por ahora vamos a decir que DDRB es una variable a secas, a esta variable le asignamos el resultado de una operación 1\u0026laquo;PB5, el símbolo \u0026ldquo;\u0026laquo;\u0026rdquo; es un operado binario llamado left shift o corrimiento a la izquierda, indica que el número a la izquierda sera recorrido el número de veces que tiene a la derecha en binario, por ejemplo\n3 en binario es 0b0011 Aplicar un corrimiento a la izquierda en una unidad implica: 3\u0026lt;\u0026lt;1 es exactamente igual a: 0b0011\u0026lt;\u0026lt;1 y da como resultado 0b0110 en decimal 6 En nuestro caso, casi siempre usaremos un 1 a la izquierda del operador, por lo tanto\n1 en binario es 0b1 1\u0026lt;\u0026lt;1 da como resultado 0b10 1\u0026lt;\u0026lt;2 da como resultado 0b100 1\u0026lt;\u0026lt;3 da como resultado 0b1000 1\u0026lt;\u0026lt;7 da como result. 0b10000000 Realmente no nos interesa el valor en decimal, lo que nos interesa es donde queda posicionado el 1, al final de la operación con 1\u0026laquo;2, el 1 queda posicionado en la tercera de derecha a izquierda, con 1\u0026laquo;7, queda en la octava de derecha a izquierda.\n¿Para que es esto?, DDRB es una \u0026ldquo;variable\u0026rdquo; que le indica al microcontrolador si el pin es de entrada o de salida, si el bit es cero, el pin operara como entrada, de lo contrario opera como salida. DDRB contiene 8 bits y cada bit corresponde a un pin de nuestro microcontrolador, al inicio contiene el valor binario 0b0000 0000, si revisas la hoja de datos de tu microcontrolador te darás cuenta que los pines están rotulados con las leyendas PA0, PB0, PC0, PA1, etc, estos son los \u0026ldquo;nombres\u0026rdquo; de los pines y A,B,C, es el puerto al que pertenecen, por lo tanto el pin 5 del puerto B se llama PB5.\nEl pin PB5 esta conectado al led de nuestra tarjeta, hay que decirle a DDRB que ponga el pin 5 como salida, tan fácil como:\nDDRB = 1\u0026lt;\u0026lt;PB5; //que es exactamente igual a DDRB = 0b00100000; //bit 76543210 Lo anterior tiene la desventaja de poner al resto de pines como entrada, por ahora no es un problema, pero no es la forma correcta, en otra entrada se dará la forma correcta.\nSeguimos adelante y tenemos otra asignación, PORTB es otro registro, de igual forma asumiremos por ahora que es una variable, controla el estado del pin, el estado puede ser 0 para bajo o 1 para alto, en síntesis cuando el pin se configura en alto tendrá 5 volts y cuando se configura en bajo tendrá 0 volts, cuando necesitemos encender el led lo configuramos como alto con\nPORTB = 1\u0026lt;\u0026lt;PB5; //que es exactamente igual a PORTB = 0b00100000; ¿y si queremos ponerlo en bajo?, por ahora solo esto,\nPORTB = 0; //que es exactamente igual a PORTB = 0b00000000; Siguiendo con el programa, entramos al ciclo infinito en donde la parte interesante es la función _delay_ms(), la función se explica por si misma, cuando se llama toma el control de la ejecución del programa y espera la cantidad de tiempo indicada en milisegundos, 1000 para este ejemplo, pasado este tiempo la función termina y sigue con la ejecución del programa.\nEl programa se queda en este bucle encendiendo y apagando el led cada dos segundos.\nCompilando #  Si no tenemos instalado avr_gcc, en una terminal:\n$ sudo dnf install avr-gcc El proceso de compilación es simple, abrimos una terminal, nos dirigimos al directorio donde se encuentra nuestro fichero y escribimos:\n$ avr-gcc -mmcu=atmega328p blinky.c El compilador generará un archivo ejecutable en formato elf: a.out, sin embargo se requiere convertir este fichero a otro formato antes de poder grabarlo en el microcontrolador. El archivo a.out contiene información adicional a las instrucciones del programa, para \u0026ldquo;filtrar\u0026rdquo; la información relevante:\n$ avr-objcopy -O ihex a.out blinky.hex La herramienta avr-objcopy extrae las instrucciones y las coloca en el fichero blinky.hex.\nGrabando #  Finalmente utilizamos la herramienta avrdude para grabar el programa\n$ avrdude -c arduino -P /dev/ttyACM0 -p m328p -U flash:w:blinky.hex Un par de segundos después el led del arduino comenzara a parpadear cada dos segundos.\nEl parámetro -P /dev/ttyACM0 indica el puerto, desafortunadamente no siempre es el mismo, también puede ser /dev/ttyUSB0 o algún otro, pero por lo general es alguno de esos dos.\n"}),a.add({id:25,href:'/eleckia/posts/bloque-reutilizable-sin-titulo/',title:"save",section:"Posts",content:"El siguiente paso obvio es analizar el programa Blink, sin embargo aquí no usaremos las bibliotecas de Arduino, usaremos código c para dispositivos AVR, entonces ¿para que tanto problema instalando la maquina virtual y Arduino?, simplemente porque utilizaremos la infraestructura ya hecha para nuestro propósito, abrimos el ejemplo Blink y reemplazamos el código por:\n#include\u0026lt;avr/io.h\u0026gt; #include\u0026lt;util/delay.h\u0026gt; int main(void) { DDRB = 1 \u0026lt;\u0026lt; PB5; PORTB = 0; while(1){ PORTB |= 1 \u0026lt;\u0026lt; PB5; \\_delay\\_ms(1000); PORTB \u0026amp;= ~(1\u0026lt;\u0026lt;PB5); \\_delay\\_ms(1000); } } compilamos y subimos el código, el comportamiento es exactamente el mismo, pero el código es totalmente C y no C++, también evitamos el uso de las bibliotecas de Arduino en favor de las avr. Esto se nota de inmediato en el tamaño del programa, mientras que nuestro código usa 108 Bytes, el código de Arduino usa 924 Bytes, esto realmente no es determinante, en un proyecto complejo y grande usar una biblioteca u otra no tendrá gran impacto en el tamaño final. En realidad las Arduino usa como base las bibliotecas avr. Este pequeño hola mundo, da para comentar muchas cosas, no te preocupes por no entender el código iremos desglosándolo en las siguientes entradas, también mostrare como liberarnos del IDE y por si fuera poco como liberarnos de la tarjeta.\n¿Por qué no usar unicamente Arduino para todo?, la verdad es que la única razón verdadera y valida es que no me gusta, otras razones menos validas son:\n Te limita a un puñado de microcontroladores.- Dentro de la familia de los microcontroladores avr apenas unos cuantos son utilizados para las tarjetas Arduino, existen ports a otras arquitecturas y micros, pero suelen ser limitadas, quizá lo que requieres realizar sea un programa muy sencillo, quizá no necesites toda la potencia que te ofrece un atmega328p, tal vez lo que necesites sea un attiny13(hiper barato y pequeño), por el contrario tal vez requieres algo muy rápido y potente como un amr cortex m7, o un risc V, no siempre tenemos a disponibilidad las bibliotecas de Arduino, pienso que es importante saber hacer tus propias bibliotecas y adaptarlas a un hardware cambiante. Te obliga a usar C++, aunque es posible enlazar bibliotecas de C++ en C, es un proceso un poco traumático, el problema de C++ es que es muy difícil de leer, el ejemplo clásico es el siguiente  struct unaEstructura primero = nuevoNumero(); struct unaEstructura segundo = nuevoNumero(); // C a = primero.num + segundo.num; //En C esto tiene un significado obvio // C++ a = primero + segundo; //A priori no sabemos que esta pasando aquí pudiera parecer una trivialidad, pero de igual forma sucede con varias otras situaciones, realmente es una cuestión de simple gusto, C++ es un lenguaje muy potente, si te sientes cómodo con él úsalo y explótalo al máximo.\n El entorno en general es precario. No se puede tener todo, si es fácil tiene que haber un costo, el costo es que no tenemos herramientas de debugging, el editor es horrible, no se adapta muy bien a los proyectos colaborativos, no hay control de versiones.  Sin embargo hay muchas cosas buenas que no se encuentran en ningún otro ambiente, por lo tanto debemos equilibrar nuestras preferencias en aras de obtener el mejor rendimiento y calidad.\n"}),a.add({id:26,href:'/eleckia/docs/workstation/arduino/',title:"Arduino",section:"Estación de trabajo",content:"Arduino #  Arduino se compone tanto de software como de hardware, miremos un poco el hardware.\nHardware #  El Arduino Uno (placa de desarrollo), cuenta con un puerto usb, por el que se alimenta la placa; enviamos y recibimos datos, este puerto esta conectado a un circuito integrado FTDI que no es más que un convertidor serial-usb, igualmente este convertidor se conecta a unos pines específicos del microcontrolador. Lo importante a destacar es que esta conexión ya esta hecha y es perfectamente funcional, permitiendo la conexión entre la placa y pc sin mayores complicaciones, esta es sin duda la gran característica que dio paso al éxito, una plataforma lista para usarse sin necesidad de componentes adicionales.\nEl convertidor serial varia dependiendo de la versión de tu tarjeta, pero su comportamiento es similar en todas las versiones. Ahora nos enfocamos en conocer el microcontrolador,\nEl atmega328p es un microcontrolador avr de 8 bits con arquitectura RISC, no entraremos en detalles sobre la arquitectura. Quizá el parámetro más importante de un microcontrolador es la capacidad de memoria con la que cuenta, la asombrosa cantidad de 32KB de flash o memoria de programa y 2KB de ram, teniendo en cuenta que en este momento contamos con PCs regularmente de 8GB de ram y mayores de 1TB de almacenamiento, la memoria del atmega328p parecería poco, sin embargo se pueden hacer muchas cosas con ella y cuando digo muchas es muchas, adicionalmente cuenta con 1KB de memoria eeprom, en la cual podemos guardar datos y evitar que se pierdan cuando se corta la alimentación.\nOtro parámetro importante es la frecuencia a la que trabaja, siendo hasta 20MHz el máximo posible, internamente cuenta con un oscilador que puede ser configurado hasta 8MHz, si queremos frecuencias mayores podemos conseguirlas conectado un oscilador externo, usualmente un reloj de cuarzo, la regla es que a mayor frecuencia mayor capacidad de procesamiento, pero mayor gasto de energía. En el caso del Arduino(tarjeta), tiene un reloj de 16MHz ya conectado, por lo que el entorno esta desarrollado con este reloj en mente.\nCuenta con 23 pines programables en la versión DIP y hasta 32 en la versión de montaje superficial.\nLos periféricos con los que cuenta\n Timer con output compare ADC USART SPI I2C Y varias fuentes de interrupciones  Describiré con mucho detalle los periféricos en posteriores entradas.\nAdicionalmente la tarjeta cuenta con un par de hileras de pines donde podemos conectar componentes externos, un jack de alimentación por el cual podemos conectar hasta 9V, finalmente un LED conectado al pin 13.\nSoftware #  En cuanto al software, Arduino es un conjunto de bibliotecas que nos permiten programar el microcontrolador de una manera simple y fácil, hay bibliotecas para muchos dispositivos, muy probablemente la solución a una de tus necesidades o al menos la solución parcial se encuentre en forma de biblioteca ya programada por alguien más.\nSin Arduino #  Mi objetivo es exponer al microcontrolador per se más que al ambiente Arduino en general, tan solo sacare provecho de la tarjeta.\n"}),a.add({id:27,href:'/eleckia/docs/workstation/estacion-de-trabajo/',title:"Estación de trabajo",section:"Estación de trabajo",content:"Estación de trabajo #  No es obligatorio instalar Fedora, pero todos los ejemplos se harán desde este sistema operativo, eres libre de adaptar lo que aquí se mencione a tus circunstancias.\nPara poder trabajar a gusto es necesario disponer de un conjunto de herramientas adecuado, dejando de lado el tipo de computadora con la que se cuenta, lo importante es el sistema operativo, utilizaremos software libre, nuestro sistema operativo sera linux, concretamente Fedora, esta distribución cuenta con los paquetes necesarios para desarrollar software cómodamente, así que si utilizas algo diferente comienza borrado tu disco duro e instala Fedora (obviamente esto es broma :D).\nLa manera más sencilla de comenzar en este mundo (y la que seguiremos aquí) es con linux + arduino, hablemos rápida y brevemente de ellos.\nLinux es una pieza de software que funciona como interfaz entre el hardware de una computadora (memoria, procesador, periféricos, etc), en pocas palabras y de manera muy general, linux se encarga de administrar el hardware de una PC, por otro lado existe software (GNU y otros) que se comunica con linux para formar un sistema operativo, de ahí surgen los sistemas GNU/Linux, a grandes rasgos el software GNU se encarga de administrar el sistema, enviándole instrucciones a Linux (comúnmente llamado kernel o núcleo) y este último las ejecuta en el hardware. Para el que este interesado en entender un poco más sobre el origen y filosofía de GNU/linux y el software libre, les recomiendo ver el documental \u0026ldquo;Código linux\u0026rdquo;, disponible en youtube en español. Compañías aprovechan este conjunto de software para crear distribuciones, en nuestro caso trabajaremos con la distribución Fedora, patrocinada por Red Hat, disponible para su descarga gratuitamente.\nArduino es una plataforma de desarrollo, contiene tanto software como hardware, sera común referirnos de manera indistinta al software o hardware con la palabra Arduino, con respecto al hardware hay muchas versiones, siendo el \u0026ldquo;Arduino uno\u0026rdquo; el más común y el que utilizaremos, este Arduino cuenta con un microcontrolador atmega328p, es un microcontrolador de la empresa Microchip, anteriormente le pertenecía a Atmel, pero fue comprada por la anterior mencionada, el microcontrolador es de 8 bits y contiene numerosos periféricos. Arduino es software libre pero también hardware libre, esto implica que los clones funcionen de manera idéntica a el hardware original, aunque si puedes comprarlo original siempre es bueno apoyar a los creadores. En la parte de software Arduino cuenta con su propio entorno de desarrollo (aunque a mi me parece horrible) y cuenta con miles de bibliotecas listas para ser usadas en nuestros proyectos.\nLo que requerimos:\n-Instalar Fedora\n-Adquirir un Arduino\n-Instalar Arduino dentro de Fedora\nComencemos instalando Fedora, como mencionamos Fedora es un sistema operativo, por lo tanto requerimos instalarlo en nuestra PC, podemos instalar junto a nuestro sistema operativo actual, podemos reemplazar nuestro sistema operativo actual por Fedora o si ya utilizamos Fedora como sistema operativo principal no hay necesidad de reinstalarlo, la última opción es instalarlo en una maquina virtual, si eres usuario windows probablemente esta opción es la más adecuada para ti.\nUna maquina virtual es un entorno que permite ejecutar un sistema operativo adicional sobre uno ya en ejecución, el sistema adicional se conoce como \u0026ldquo;huesped\u0026rdquo;(guess) y el que ya esta en ejecución se le denomina \u0026ldquo;anfitrión\u0026rdquo;(host), de esta manera podemos instalar Fedora sin la necesidad de modificar nuestro sistema operativo actual.\nInstalando VirtualBox #  Procedemos a instalar la maquina virtual, para ello visitamos el enlace https://www.virtualbox.org/\ny descargamos la versión más reciente para nuestro sistema operativo anfitrion(probablemente windows), no entrare en detalles sobre como instalar virtual box puesto que cada sistema es diferente, pero confió en que sabes como instalar programas en tu sistema, para instalarlo en windows doble click sobre el ejecutable descargado, si eres usuario linux seguramente viene en los repositorios oficiales de tu distribución.\nCreando la maquina virtual #  Ahora descargaremos Fedora, accedemos al enlace\nhttps://getfedora.org/es/\nexisten varias ediciones, elegimos Workstation y la descargamos, la descarga es una imagen .iso de alrededor de 2GB, una vez descargado procedemos a instalar.\nAbrimos Virtualbox y seleccionamos \u0026ldquo;nueva\u0026rdquo;\nSe abrirá una nueva ventana escribimos \u0026ldquo;Fedora\u0026rdquo; en nombre, carpeta la dejamos por defecto, seleccionamos, tipo \u0026ldquo;Linux\u0026rdquo; y Versión \u0026ldquo;Fedora (64-bit)\u0026rdquo;, click en siguiente.\nAhora nos pide configurar la memoria, aqui aparece un control de deslizamiento, selecciona por lo menos 2GB y da click en siguiente.\nAhora nos pide configurar un nuevo disco duro, seleccionamos \u0026ldquo;Crear un disco virtual Ahora\u0026rdquo; y damos click en siguiente.\nTipo de archivo de disco duro, VDI, siguiente.\nAlmacenamiento en unidad de disco duro física, Reservado dinámicamente, siguiente.\nUbicación del archivo y tamaño, dejamos la ubicación por defecto y seleccionamos un tamaño de 20GB, siguiente.\nHemos finalizado la creación de la maquina virtual, procedemos a instalar Fedora en el siguiente post.\nInstalando Fedora dentro de VirtualBox #  Abrimos VirtualBox y seleccionamos la maquina virtual Fedora que creamos anteriormente, ahora damos click en Configuración, se nos abrirá una nueva ventana, seleccionamos Almacenamiento y en controlador IDE, seleccionamos Vació, a la derecha de unidad óptica damos click en el icono de un disco azul y seleccionamos el .iso de Fedora que descargamos anteriormente, finalmente damos click en aceptar.\nSi tienes anfitrión linux, ahí mismo en configuración seleccionamos Pantalla y cambiamos Controlador Gráfico a VBoxVGA y aumenta la memoria de video a por lo menos 64MB.\nNuevamente en Configuración, ahora seleccionamos Sistema y en la pestaña Procesador, seleccionamos el número de procesadores que tenemos, damos click en aceptar.\nNuestra maquina virtual, esta lista para arrancar y ya tiene el \u0026ldquo;disco\u0026rdquo; de instalación insertado, procedemos a iniciarla con el icono Iniciar.\nArrancamos y la primer pantalla de selección nos da tres opciones, seleccionamos la primera, Start Fedora, cuidado por defecto esta seleccionada la segunda opción.\nEsperamos a que el sistema inicie y tenemos una versión live de Fedora funcionando,\nEsta versión de Fedora es totalmente funcional, podemos jugar con ella, revisar los programas y menus, cambiar la resolución, etc, sabedores de que los cambios que hagamos no se guardaran, cuando estemos listos damos click en Install to Hard Drive. Se abrirá el asistente de instalación Anaconda (puede que tarde unos minutos), aquí elegimos el idioma y la región y damos click en continuar,\nseleccionamos nuestra distribución de teclado(probablemente español latinoamericano) y la zona horaria, click en Destino de la Instalación, sin modificar nada damos click en Hecho en la esquina superior izquierda y comenzamos la instalación.\nEsperamos unos minutos a que termine la instalación y damos click en salir.\nApagamos la maquina virtual y removemos la imagen .iso de Fedora.\nIniciamos nuevamente la maquina virtual esta vez iniciara Fedora instalado, todo lo que hagamos ahora si se guardara, nos dará la bienvenida un asistente de configuración donde nos pedirá algunos datos, de ellos lo importante es el usuario y la contraseña, los cuales debemos recordar o en su defecto anotar. Una vez ingresados nuestro sistema estará listo para poder instalar Arduino.\nInstalando Arduino #  Ya casi estamos listos, damos click en Actividades y abrimos una terminal, la terminal puede ser intimidante, pero creeme una vez te acostumbres a ella la amaras.\nEn los sistemas linux tenemos diferentes tipos de usuarios cada uno de ellos con diferentes privilegios, el usuario con más privilegios es el usuario root, puede hacer y deshacer el sistema, nuestro usuario por defecto tiene pocos privilegios para evitar que el usuario pueda romper el sistema por accidente. Al abrir la terminal tendremos algo similar a esto\n[eleckia@tuxin-lp ~]$ donde eleckia es el nombre de usuario que se eligió, y tuxin-lp es el nombre que se le dio a la pc, delante del signo $, podemos escribir.\nDNF es el manejador de paquetes de Fedora, es una herramienta que nos permite actualizar, instalar y remover los programas y/o bibliotecas instaladas en nuestro sistema, para utilizarlo simplemente tecleamos\n[eleckia@tuxin-lp ~]$ dnf nos desplegara una enorme lista de las opciones disponibles para este comando, el que nos interesa por ahora es update, esta opción nos actualiza todos los paquetes a la última versión disponible, tecleamos\n[eleckia@tuxin-lp ~]$ dnf update Error: Este comando debe ejecutarse como usuario root. el error nos indica que requerimos privilegios altos, la forma de escapar de la tiranía el usuario root, es anteponer la palabra sudo,\n[eleckia@tuxin-lp ~]$ sudo dnf update nos pedirá introducir la contraseña que creamos al iniciar Fedora por primera vez, la introducimos y nos desplegará la lista de actualizaciones disponibles, nos pedirá confirmación a lo que responderemos s. La primera vez que actualicemos, habrá muchas actualizaciones, por lo que se tardara un poco, al terminar de actualizar, reiniciaremos el sistema y abriremos nuevamente una terminal, una vez hecho esto instalaremos Arduino por fin. Para instalarlo tan fácil como escribir lo siguiente:\n[eleckia@tuxin-lp ~]$ sudo dnf install arduino terminada la descarga e instalación, ya tenemos disponible el software Arduino, hacemos click en actividades y lo ejecutamos, nos indicara que debemos agregar nuestro usuario a los grupos dialout y lock, le decimos que si e introducimos la contraseña del sistema, tenemos finalmente todo listo para comenzar a programar, tan solo nos falta conectar nuestro Arduino a un puerto usb.\nAnteriormente mencione que trabajaremos con Arduino uno, sin embargo debo confesar que cualquier Arduino de 8 bits es valido, de hecho ni siquiera es necesario instalar Fedora, puedes instalar Arduino en casi cualquier sistema operativo, la razón de instalar Fedora es que nos ofrece todas las herramientas de manera simple e inmediata, al estar dentro de una máquina virtual no debemos preocuparnos de dañar el sistema accidentalmente, yo haré todo desde Fedora, por que es mi sistema instalado, pero sientete libre de utilizar lo que más te acomode, eso si, si tienes algún problema con tu sistema no podre ayudarte puesto que yo no lo uso (windows). Lo mismo va para la tarjeta Arduino que utilices, funciona cualquiera, pero los registros de cada microcontrolador varian mucho, sobre todo de una arquitectura a otra, los microcontroladores de 8 bits no tiene nada que ver con los micros de 32 o 16 bits.\nNo es de mi interés centrarme en Arduino, pero es la opción de aprendizaje más adecuada y sería tonto no empezar con ella.\nLos lugares más comunes para adquirir la tarjeta es ebay, amazon y mercadolibre, es tu elección, también requerimos algunos dispositivos como leds, resistencias, transistores, capacitores, etc, en el siguiente post daremos algunos detalles adicionales.\nFin #  Finalizamos esta serie de post iniciales con una lista de materiales recomendada, en ebay existen una gran variedad de paquetes donde se incluyen Arduinos, resistencias, capacitores, transistores y algunos sensores, basta con ir a ebay o mercadolibre y buscar kit Arduino, adquirir uno de ellos es un buen comienzo.\nIgualmente puedes adquirir kits de resistencias, capacitores y leds, además de jumpers, cables y un par de atmega328p DIP adicionales.\nCon esto podemos comenzar nuestro estudio, más adelante requeriremos más componentes, pero se mencionarán con forme se requieran.\n"}),a.add({id:28,href:'/eleckia/posts/about/',title:"About",section:"Posts",content:"This is an example of a page. Unlike posts, which are displayed on your blog’s front page in the order they’re published, pages are better suited for more timeless content that you want to be easily accessible, like your About or Contact information. Click the Edit link to make changes to this page or add another page.\n"})})()